<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>半糖</title>
  
  <subtitle>耐得住寂寞,才能享受繁华</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-17T17:12:34.118Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>冯家鹏</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JDBC</title>
    <link href="http://example.com/2023/05/18/JDBC/"/>
    <id>http://example.com/2023/05/18/JDBC/</id>
    <published>2023-05-17T17:11:25.000Z</published>
    <updated>2023-05-17T17:12:34.118Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h1 id="1-JDBC概述"><a href="#1-JDBC概述" class="headerlink" title="1.JDBC概述"></a>1.JDBC概述</h1><h2 id="1-简述"><a href="#1-简述" class="headerlink" title="1.简述"></a>1.简述</h2><p>Java DataBase Connectivity，简称JDBC，Java数据库连接。是Java语⾔中⽤来规范客户端程序如何来访问数据库的应⽤程序接⼝，JDBC实际上就是Java中的⼀套和数据库交互的API（Application Program Interface，应⽤程序编程接⼝）。</p><h2 id="2-为什么使用JDBC"><a href="#2-为什么使用JDBC" class="headerlink" title="2.为什么使用JDBC"></a>2.为什么使用JDBC</h2><p>因为Java开发者需要连接多种数据库（Oracle、DB2、MySQL、SQL Server…）为了避免连接每⼀种数据库都学习⼀套新的API，Sun公司提出了JDBC接⼝，各个数据库⼚商根据此接⼝写实现类（驱动），这样Java开发者只需要掌握JDBC接⼝中的⽅法调⽤就可以连接任何数据库</p><h2 id="3-JDBC-API-概述"><a href="#3-JDBC-API-概述" class="headerlink" title="3.JDBC API 概述"></a>3.JDBC API 概述</h2><p>JDBC API主要位于JDK中的java.sql包中（之后扩展的内容位于javax.sql包中），主要包括：</p><p><img src="/2023/05/18/JDBC/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230517201344980.png" alt="image-20230517201344980"></p><h1 id="2-JDBC使用"><a href="#2-JDBC使用" class="headerlink" title="2.JDBC使用"></a>2.JDBC使用</h1><h2 id="1-建立连接"><a href="#1-建立连接" class="headerlink" title="1.建立连接"></a>1.建立连接</h2><p>步骤:</p><p>1.加载数据库</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>)</span><br></pre></td></tr></table></figure><p>2.建立连接</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String username=<span class="string">&quot;root&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/jdbcuseUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&quot;</span>,username,password);</span><br></pre></td></tr></table></figure><p>3.执行sql语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String sql =&quot;sql语句&quot;;</span><br></pre></td></tr></table></figure><p>4.处理结果集</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">statement.execute(sql)</span><br></pre></td></tr></table></figure><p>5.关闭连接</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">connection.close();</span><br></pre></td></tr></table></figure><h2 id="2-Statement"><a href="#2-Statement" class="headerlink" title="2.Statement"></a>2.Statement</h2><p>Statement执⾏SQL语句对象的主要⽅法⻅下。</p><p><img src="/2023/05/18/JDBC/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230517202755859.png" alt="image-20230517202755859"></p><h2 id="3-JDBC基本使用"><a href="#3-JDBC基本使用" class="headerlink" title="3.JDBC基本使用"></a>3.JDBC基本使用</h2><h3 id="1-数据准备"><a href="#1-数据准备" class="headerlink" title="1.数据准备"></a>1.数据准备</h3><p>创建jdbc数据库，将来会在该数据库中创建以下的表。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE jdbc CHARACTER SET utf8;</span><br><span class="line">USE jdbc;</span><br><span class="line"># 创建员⼯表</span><br><span class="line">CREATE TABLE emp(</span><br><span class="line"> eid INT,</span><br><span class="line"> ename VARCHAR(20),</span><br><span class="line"> sex CHAR(1),</span><br><span class="line"> salary DOUBLE,</span><br><span class="line"> hire_date DATE,</span><br><span class="line"> dept_name VARCHAR(20)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line"># 添加数据</span><br><span class="line">INSERT INTO emp VALUES(1, &#x27;孙悟空&#x27;, &#x27;男&#x27;, 15000, &#x27;2013-02-04&#x27;, &#x27;教学部&#x27;);</span><br><span class="line">INSERT INTO emp VALUES(2, &#x27;猪⼋戒&#x27;, &#x27;男&#x27;, 10000, &#x27;2010-12-02&#x27;, &#x27;教学部&#x27;);</span><br><span class="line">INSERT INTO emp VALUES(3, &#x27;唐僧&#x27;, &#x27;男&#x27;, 20000, &#x27;2008-08-08&#x27;, &#x27;教学部&#x27;); </span><br><span class="line">INSERT INTO emp VALUES(4, &#x27;⽩⻣精&#x27;, &#x27;⼥&#x27;, 5000, &#x27;2015-10-07&#x27;, &#x27;市场部&#x27;);</span><br><span class="line">INSERT INTO emp VALUES(5, &#x27;蜘蛛精&#x27;, &#x27;⼥&#x27;, 5000, &#x27;2011-03-14&#x27;, &#x27;市场部&#x27;);</span><br><span class="line">INSERT INTO emp VALUES(6, &#x27;⽟兔精&#x27;, &#x27;⼥&#x27;, 3000, &#x27;2000-03-14&#x27;, &#x27;市场部&#x27;); </span><br><span class="line">INSERT INTO emp VALUES(7, &#x27;林黛⽟&#x27;, &#x27;⼥&#x27;, 10000, &#x27;2019-10-07&#x27;, &#x27;财务&#x27;);</span><br><span class="line">INSERT INTO emp VALUES(8, &#x27;⻩蓉&#x27;, &#x27;⼥&#x27;, 3500, &#x27;2011-09-14&#x27;, &#x27;财务部&#x27;);</span><br><span class="line">INSERT INTO emp VALUES(9, &#x27;吴承恩&#x27;, &#x27;男&#x27;, 20000, &#x27;2000-03-14&#x27;, NULL); </span><br><span class="line">INSERT INTO emp VALUES(10, &#x27;孙悟饭&#x27;, &#x27;男&#x27;, 3000, &#x27;2020-03-14&#x27;, &#x27;财务部&#x27;);</span><br><span class="line">INSERT INTO emp VALUES(11, &#x27;兔⼋哥&#x27;, &#x27;⼥&#x27;, 4000, &#x27;2010-03-14&#x27;, &#x27;财务部&#x27;);</span><br><span class="line">-- 创建部⻔表(⼀⽅，主表)</span><br><span class="line">CREATE TABLE department(id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line"> dept_name VARCHAR(30),</span><br><span class="line"> dept_location VARCHAR(30)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br><span class="line">-- 创建员⼯表(多⽅，从表)</span><br><span class="line">CREATE TABLE employee(</span><br><span class="line"> eid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line"> ename VARCHAR(20),</span><br><span class="line"> age INT,</span><br><span class="line"> dept_id INT</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure><h3 id="2-创建Maven工程"><a href="#2-创建Maven工程" class="headerlink" title="2.创建Maven工程"></a>2.创建Maven工程</h3><p>1.创建⼀个项⽬名称为【jdbc】的Maven⼯程。</p><p>2.在main⽬录下创建⼀个webapp⽂件夹。</p><p>3.选择【File】-【project Structure】-【facets】-【点击+号】按钮，添加【Web】选项选择当前⼯程jdbc。</p><p>4.修改路径信息，修改成我们创建的webapp⽬录（src&#x2F;main&#x2F;webapp）。</p><p>5.完成后，在webapp⽬录下会⾃动创建WEB-INF⽬录，并⾃动⽣成web.xml配置⽂件。</p><h3 id="3-配置项目"><a href="#3-配置项目" class="headerlink" title="3.配置项目"></a>3.配置项目</h3><h4 id="1-添加插件"><a href="#1-添加插件" class="headerlink" title="**1.添加插件"></a>**1.添加插件</h4><p>添加编译插件，设置jdk编译版本。本教程使⽤jdk11，需要设置编译版本为11，这⾥需要使⽤Maven的插件来设置。在pom.xml⽂件中添加如下配置：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- properties是全局设置，可以设置整个Maven项⽬的编译器JDK版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在build中我们需要指定⼀下项⽬的JDK编译版本，Maven默认使⽤1.5版本进⾏编译。注意：build与</span></span><br><span class="line"><span class="comment">dependencies是平级关系 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">release</span>&gt;</span>11<span class="tag">&lt;/<span class="name">release</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-添加依赖"><a href="#2-添加依赖" class="headerlink" title="2.添加依赖"></a>2.添加依赖</h4><p>1.在Maven仓库中搜索mysql的驱动jar包（外⽹：maven.aliyun.com）。</p><p>2.将mysql的驱动jar包 Maven依赖 配置到本地⼯程中的pom.xml⽂件中</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-JDBC入门案例"><a href="#4-JDBC入门案例" class="headerlink" title="4.JDBC入门案例"></a>4.JDBC入门案例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">jdbcdemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line"></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span><span class="string">&quot;create table m1(id int primary key auto_increment,name varchar(255))&quot;</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">        statement.execute(sql);</span><br><span class="line">        System.out.println();</span><br><span class="line">        statement.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭连接&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-JDBC增删查改操作"><a href="#4-JDBC增删查改操作" class="headerlink" title="4.JDBC增删查改操作"></a>4.JDBC增删查改操作</h2><p>1.在项目中pom.xml文件中导入junit依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.13.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.在com.cy包下创建Demo02类，通过测试⽅法完成增删改查功能。并导⼊单元测试org.junit.Test类。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fjp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/5/16 19:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">jdbcdemo02</span> &#123;</span><br><span class="line">    Connection connection;</span><br><span class="line">    Statement statement;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span><span class="string">&quot;123456&quot;</span>;</span><br><span class="line">         connection = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&quot;</span>, username, password);</span><br><span class="line">         statement = connection.createStatement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span><span class="string">&quot;insert into emp values (12,&#x27;老余&#x27;,&#x27;男&#x27;,1500,&#x27;2022-10-1&#x27;,&#x27;开发部&#x27;) &quot;</span> ;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">execute</span> <span class="operator">=</span> statement.execute(sql);</span><br><span class="line">        connection.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;数据库更新成功!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from emp where eid = 11&quot;</span>;</span><br><span class="line">        statement.execute(sql);</span><br><span class="line">        connection.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;删除成功!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span>  <span class="title function_">update</span> <span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update emp set ename = &#x27;余余&#x27; where  eid = 12&quot;</span>;</span><br><span class="line">        statement.execute(sql);</span><br><span class="line">        connection.close();</span><br><span class="line">        System.out.println(<span class="string">&quot;数据更新成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        String sql=<span class="string">&quot;select * from emp where eid = 3&quot;</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> resultSet.getString(<span class="number">2</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> resultSet.getString(<span class="number">3</span>);</span><br><span class="line">            <span class="type">double</span> <span class="variable">salary</span> <span class="operator">=</span> resultSet.getDouble(<span class="number">4</span>);</span><br><span class="line">            <span class="type">Date</span> <span class="variable">time</span> <span class="operator">=</span> resultSet.getDate(<span class="number">5</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">deptName</span> <span class="operator">=</span> resultSet.getString(<span class="number">6</span>);</span><br><span class="line">            connection.close();</span><br><span class="line">            System.out.println(<span class="string">&quot;编号:&quot;</span>+id + <span class="string">&quot;,姓名:&quot;</span>+name + <span class="string">&quot;,性别:&quot;</span>+sex+<span class="string">&quot;,工资:&quot;</span>+salary + <span class="string">&quot;,入职时间:&quot;</span>+time + <span class="string">&quot;,部门:&quot;</span>+deptName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-DBCP"><a href="#5-DBCP" class="headerlink" title="5.DBCP"></a>5.DBCP</h2><h3 id="1-DBCP简介"><a href="#1-DBCP简介" class="headerlink" title="1.DBCP简介"></a>1.DBCP简介</h3><p>DBCP，DataBase Connection Pool，数据库连接池是Apache上的⼀个Java连接池项⽬。DBCP通过连接池预先同数据库建⽴⼀些连接放在内存中（即连接池中），应⽤程序需要建⽴数据库连接时直接到连接池中申请⼀个连接使⽤，⽤完后由连接池回收该连接，从⽽达到连接复⽤，减少资源消耗的⽬的。</p><h3 id="2-DBCP使用"><a href="#2-DBCP使用" class="headerlink" title="2.DBCP使用"></a>2.DBCP使用</h3><p>1.在pom.xml⽂件导⼊mysql-connector-java和commons-dbcp的jar包。</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-dbcp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-dbcp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.创建demo03类,编写数据库连接代码</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dbcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbcp.BasicDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fjp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/5/17 20:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBCPTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//创建数据源对象</span></span><br><span class="line">        <span class="type">BasicDataSource</span> <span class="variable">basicDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BasicDataSource</span>();</span><br><span class="line">        <span class="comment">//设置数据库连接信息</span></span><br><span class="line">        basicDataSource.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        basicDataSource.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=UTF-8&quot;</span>);</span><br><span class="line">        basicDataSource.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        basicDataSource.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="comment">//设置初始连接数量</span></span><br><span class="line">        basicDataSource.setInitialSize(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//设置最大连接数量</span></span><br><span class="line">        basicDataSource.setMaxActive(<span class="number">5</span>);</span><br><span class="line">        <span class="comment">//从连接池里面获取连接,异常抛出</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> basicDataSource.getConnection();</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="3-DBUtils工具类"><a href="#3-DBUtils工具类" class="headerlink" title="3.DBUtils工具类"></a>3.DBUtils工具类</h1><h2 id="1-为什么使用DButils"><a href="#1-为什么使用DButils" class="headerlink" title="1.为什么使用DButils"></a>1.为什么使用DButils</h2><p>因为JDBC对数据库的驱动加载、连接获取、释放资源的代码都是相同的，为了提⾼代码的复⽤性，我们可以写⼀个⼯具类，将数据库驱动加载、获取连接、资源释放的代码封装起来。同时，为了提⾼⼯具类的灵活性，可以将数据库的驱动、url、⽤户名、密码等信息以键值对的形式存放在properties⽂件中，⼯具类初始化时从配置⽂件中读取所要连接数据库的信息。当需要更改连接的数据库时，只需要更改配置⽂件即可，⽽不必改写⼯具类的代码。</p><h2 id="2-DBUtils工具类实现"><a href="#2-DBUtils工具类实现" class="headerlink" title="2.DBUtils工具类实现"></a>2.DBUtils工具类实现</h2><p>1.在 src&#x2F;main&#x2F;resources ⽬录下创建jdbc.properties⽂件，添加以下配置信息。</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DBCP配置⽂件</span></span><br><span class="line"><span class="comment"># 1.必须项</span></span><br><span class="line"><span class="comment"># 数据库驱动名</span></span><br><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="comment"># 数据库地址</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br><span class="line"><span class="comment"># ⽤户名</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="comment"># 密码</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">123456</span></span><br><span class="line"><span class="comment"># 2.可选项(扩展)</span></span><br><span class="line"><span class="comment"># 初始化连接池时的连接数</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">4</span></span><br><span class="line"><span class="comment"># 连接池中可同时连接的最⼤的连接数</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">12</span></span><br><span class="line"><span class="comment"># 连接池中最⼩的空闲的连接数，低于这个数量会被创建新的连接</span></span><br><span class="line"><span class="attr">minIdle</span>=<span class="string">3</span></span><br><span class="line"><span class="comment"># 连接池中最⼤的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限</span></span><br><span class="line"><span class="attr">maxIdle</span>=<span class="string">5</span></span><br></pre></td></tr></table></figure><p>2.编写DBUtils类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dbcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbcp.BasicDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fjp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/5/17 11:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DBUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BasicDataSource dataSource;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driverClassName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span>  String username;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String initialSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String maxActive;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String minIdle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String maxIdle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态代码块,类初始化加载数据库驱动</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//创建数据源对象</span></span><br><span class="line">        dataSource = <span class="keyword">new</span> <span class="title class_">BasicDataSource</span>();</span><br><span class="line">        <span class="comment">//加载jdbc.properties配置文件,通过反射的方式的到文件输入流</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> DBUtil.class.getClassLoader().getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建读取配置⽂件的properties对象，Properties继承了Hashtable类，Hashtable类实现了Map接⼝</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(inputStream);</span><br><span class="line">             driverClassName = properties.getProperty(<span class="string">&quot;driverClassName&quot;</span>);</span><br><span class="line">             url= properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">             username = properties.getProperty(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">             password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">             initialSize = properties.getProperty(<span class="string">&quot;initialSize&quot;</span>);</span><br><span class="line">             maxIdle = properties.getProperty(<span class="string">&quot;maxIdle&quot;</span>);</span><br><span class="line">             minIdle = properties.getProperty(<span class="string">&quot;minIdle&quot;</span>);</span><br><span class="line">             dataSource.setDriverClassName(driverClassName);</span><br><span class="line">             dataSource.setUrl(url);</span><br><span class="line">             dataSource.setUsername(username);</span><br><span class="line">             dataSource.setPassword(password);</span><br><span class="line">             dataSource.setInitialSize(Integer.parseInt(initialSize));</span><br><span class="line">             dataSource.setMinIdle(Integer.parseInt(minIdle));</span><br><span class="line">             dataSource.setMaxIdle(Integer.parseInt(maxIdle));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//获取数据库连接对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;链接成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection connection, Statement statement, ResultSet resultSet)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (resultSet != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.setAutoCommit(<span class="literal">true</span>);</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (statement != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3.测试</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> dbcp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fjp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/5/17 20:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DBUtil.getConnection();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span><span class="string">&quot;insert into emp values(25,&#x27;余正均&#x27;,&#x27;男&#x27;,500,&#x27;2002-1=5&#x27;,&#x27;公关部&#x27;)&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">        statement.execute();</span><br><span class="line">        System.out.println(<span class="string">&quot;插入成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="4-PreparedStatement"><a href="#4-PreparedStatement" class="headerlink" title="4.PreparedStatement"></a>4.PreparedStatement</h1><h2 id="1-技术原理"><a href="#1-技术原理" class="headerlink" title="1.技术原理"></a>1.技术原理</h2><p>java.sql包中的PreparedStatement接⼝继承了Statement接⼝。</p><p>PreparedStatement实例包含已编译的SQL语句。这就是使语句“准备好”。包含于PreparedStatement对象中SQL语句可具有⼀个或多个IN参数。IN参数的值在SQL语句创建时未被指定。相反的，该语句为每个IN参数保留⼀个问号（“?”）作为占位符。每个问号的值必须在该语句执⾏之前，通过适当的setXxx()⽅法来提供。</p><p>作为Statement的⼦接⼝，PreparedStatement继承了Statement的所有功能。另外它还添加了⼀整套⽅法，⽤于设置发送给数据库以取代IN参数占位符的值。同时，⽅法execute、executeQuery和executeUpdate已被更改以使之不再需要参数。这些⽅法的Statement形式（接受SQL语句参数的形式）不应该⽤于PreparedStatement对象。</p><h2 id="2-创建对象"><a href="#2-创建对象" class="headerlink" title="2.创建对象"></a>2.创建对象</h2><p>以下的代码段（其中conn是Connection对象）创建包含带两个IN参数占位符的SQL语句的PreparedStatement对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DBUtils.getConnection();</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span><span class="string">&quot;select count(*) from t_user where username = ? and password = ?&quot;</span>;</span><br><span class="line">PreparedStatement statement= connection.prepareStatement(sql);</span><br></pre></td></tr></table></figure><p>statement对象包含语句”SELECT count(*) FROM t_user WHERE username&#x3D;? and password&#x3D;?”，它已发送给DBMS，并为执⾏作好了准备。</p><h2 id="3-传递参数"><a href="#3-传递参数" class="headerlink" title="3.传递参数"></a>3.传递参数</h2><p>在执⾏PreparedStatement对象之前，必须设置每个”?”参数的值。这可通过调⽤setXxx()⽅法来完成，其中Xxx是与该参数相应的类型。例如，如果参数具有Java类型String，则使⽤的⽅法就是setString()。setXxx()⽅法的第⼀个参数是要设置的参数的序数位置，第⼆个参数是设置给该参数的值</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">statement.setString(<span class="number">1</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">statement.setString(<span class="number">2</span>,<span class="string">&quot;123456&quot;</span>);</span><br></pre></td></tr></table></figure><p>⼀旦设置了给定语句的参数值，就可⽤它多次执⾏该语句，直到调⽤clearParameters()⽅法清除它为⽌。在连接的缺省模式下（启⽤⾃动提交），当语句完成时将⾃动提交或还原该语句。</p><p>如果基本数据库和驱动程序在语句提交之后仍保持这些语句的打开状态，则同⼀个PreparedStatement可执⾏多次。</p><h2 id="4-参数类型"><a href="#4-参数类型" class="headerlink" title="4.参数类型"></a>4.参数类型</h2><p>setXxx()⽅法中的Xxx是Java类型。它是⼀种隐含的JDBC类型（⼀般SQL类型），因为驱动程序将把Java类型映射为相应的JDBC类型，并将该JDBC类型发送给数据库。开发者的责任是确保将每个IN参数的Java类型映射为与数据库所需的JDBC数据类型兼容的JDBC类型。</p><p>1.根据用户输入的内容查询员工的信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> preparedStatement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mysql.cj.exceptions.CJOperationNotSupportedException;</span><br><span class="line"><span class="keyword">import</span> dbcp.DBUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fjp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/5/17 21:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreparedTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入用户名:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入性别:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DBUtil.getConnection();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from emp where ename =? and sex = ?&quot;</span>;</span><br><span class="line">            <span class="type">PreparedStatement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">            statement.setString(<span class="number">1</span>, username);</span><br><span class="line">            statement.setString(<span class="number">2</span>, sex);</span><br><span class="line">            <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery();</span><br><span class="line">            <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> resultSet.getInt(<span class="string">&quot;eid&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i &gt;<span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;查询成功&quot;</span>);</span><br><span class="line">                    System.out.println(<span class="string">&quot;id:&quot;</span>+i);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;查询失败&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.分页查询</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> preparedStatement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> dbcp.DBUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fjp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2023/5/17 22:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">pageLimt</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入请求页数:&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">page</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入请求的条数&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DBUtil.getConnection();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from emp limit ?,?&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">        preparedStatement.setInt(<span class="number">1</span>, (page-<span class="number">1</span>)*count);</span><br><span class="line">        preparedStatement.setInt(<span class="number">2</span>,count);</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery();</span><br><span class="line">        <span class="keyword">while</span> (resultSet.next()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(<span class="number">1</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> resultSet.getString(<span class="number">2</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> resultSet.getString(<span class="number">3</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;编号:&quot;</span>+id + <span class="string">&quot;姓名&quot;</span>+name + <span class="string">&quot;性别&quot;</span>+sex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-PreparedStatement优点"><a href="#5-PreparedStatement优点" class="headerlink" title="5.PreparedStatement优点"></a>5.PreparedStatement优点</h2><p>1.使用PreparedStatement来代替Statement会使代码的可读性和可维护性提高.</p><p>2.PreparedStement极大的提高了安全性,防止sql注入</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.Statement写法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from user where username=&#x27;&quot;</span> + username + <span class="string">&quot;&#x27; and</span></span><br><span class="line"><span class="string">password=&#x27;&quot;</span> + password + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> <span class="string">&quot;admin&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;123&#x27; or &#x27;1&#x27;=&#x27;1&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from user where username=&#x27;admin&#x27; and password=&#x27;123&#x27; or</span></span><br><span class="line"><span class="string">&#x27;1&#x27;=&#x27;1&#x27;&quot;</span>;</span><br><span class="line"><span class="comment">// 2.PreparedStatement写法</span></span><br><span class="line"><span class="comment">// 如果使⽤预编译语句，传⼊的任何内容就不会和原来的语句发⽣任何匹配的关系</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select count(*) from user where username=? and password=?&quot;</span>;</span><br></pre></td></tr></table></figure><p>3.由于PreparedStement对象已经预编译过了,所以其执行速度要快于Statement对象.因此多次执行的SQL语句经常创建成PreparedStatement对象,提高效率.</p><h1 id="5-JDBC高级操作"><a href="#5-JDBC高级操作" class="headerlink" title="5.JDBC高级操作"></a>5.JDBC高级操作</h1><h2 id="1-批量操作"><a href="#1-批量操作" class="headerlink" title="1.批量操作"></a>1.批量操作</h2><h3 id="1-方法摘要"><a href="#1-方法摘要" class="headerlink" title="1.方法摘要"></a>1.方法摘要</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>void addBatch(String sql)</td><td>将给定的SQL语句添加到此Statement对象的当前命令列表中,可以提高执行效率</td></tr><tr><td>void clearBatch()</td><td>清空此Statement对象的当前SQL命令列表</td></tr><tr><td>int[] executeBatch()</td><td>将一批命令提交给数据库来执行,如果全部命令执行成功,则返回更新技术组成的数组</td></tr></tbody></table><h3 id="2-实例应用"><a href="#2-实例应用" class="headerlink" title="2.实例应用"></a>2.实例应用</h3><p>1.Statement实现批量操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">batchdemo01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> con.createStatement();</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update emp set ename = &#x27;老6&#x27; where eid =2 &quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;insert into emp values(13,&#x27;老八&#x27;,&#x27;男&#x27;,500,&#x27;1990-6-5&#x27;,&#x27;销售部&#x27;)&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update emp set ename = &#x27;老三&#x27; where eid =5 &quot;</span>;</span><br><span class="line">        statement.addBatch(sql);</span><br><span class="line">        statement.addBatch(sql1);</span><br><span class="line">        statement.addBatch(sql2);</span><br><span class="line">        statement.executeBatch();</span><br><span class="line">        System.out.println(<span class="string">&quot;批处理完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.PreparedStetement实现批处理操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo07</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DBUtils.getConnection();) &#123;</span><br><span class="line"> <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO emp VALUES(?, ?, &#x27;⼥&#x27;, 5000, &#x27;2022-10-07&#x27;, &#x27;市场</span></span><br><span class="line"><span class="string">部&#x27;)&quot;</span>;</span><br><span class="line"> <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql);</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">11</span>; i++) &#123;</span><br><span class="line"> <span class="comment">// 替换&quot;?&quot;</span></span><br><span class="line"> pstmt.setInt(<span class="number">1</span>, <span class="number">1000</span> + i);</span><br><span class="line"> pstmt.setString(<span class="number">2</span>, <span class="string">&quot;user&quot;</span> + i);</span><br><span class="line"> <span class="comment">// 添加到批量处理</span></span><br><span class="line"> pstmt.addBatch();</span><br><span class="line"> <span class="comment">// 避免内存溢出</span></span><br><span class="line"> <span class="keyword">if</span> (i%<span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line"> pstmt.executeBatch();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 执⾏批量操作</span></span><br><span class="line"> pstmt.executeBatch();</span><br><span class="line"> System.out.println(<span class="string">&quot;执⾏完成！&quot;</span>);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h2 id="2-JDBC事务"><a href="#2-JDBC事务" class="headerlink" title="2.JDBC事务"></a>2.JDBC事务</h2><h3 id="1-事务简介"><a href="#1-事务简介" class="headerlink" title="1.事务简介"></a>1.事务简介</h3><p>事务就是⼀组操作数据库的动作集合。如果⼀组处理步骤或者全部发⽣或者⼀步也不执⾏，我们称该组处理步骤为⼀个事务。当所有的步骤像⼀个操作⼀样被完整地执⾏，我们称该事务被提交。由于其中的⼀部分或多步执⾏失败，导致没有步骤被提交，则事务必须回滚到最初的系统状态。</p><p>事务必须服从ISO&#x2F;IEC所制定的ACID原则。ACID是原⼦性（atomicity）、⼀致性（consistency）、隔离性（isolation）和持久性（durability）的缩写。JDBC事务是⽤Connection对象控制的。JDBC Connection接⼝（java.sql.Connection）提供了两种事务模式：⾃动提交和⼿⼯提交。java.sql.Connection提供了以下控制事务的⽅法：</p><ul><li>public void setAutoCommit(boolean)</li><li>public boolean getAutoCommit()</li><li>public void commit()</li><li>public void rollback()</li></ul><p>使⽤JDBC事务界定时，可以将多个SQL语句结合到⼀个事务中。JDBC事务的⼀个缺点是事务的范围局限于⼀个数据库连接。⼀个JDBC事务不能跨越多个数据库。</p><h3 id="2-事务实例"><a href="#2-事务实例" class="headerlink" title="2.事务实例"></a>2.事务实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">thingDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">            con = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/jdbc?useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;123456&quot;</span>);</span><br><span class="line">            <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> con.createStatement();</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update emp set ename = &#x27;老jiu&#x27; where eid =3 &quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;insert into emp values(14,&#x27;光头强&#x27;,&#x27;男&#x27;,5000,&#x27;1990-6-5&#x27;,&#x27;开发部&#x27;)&quot;</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;update emp set ename = &#x27;老三&#x27; where eid =5 &quot;</span>;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;默认提交方式&quot;</span>+ con.getAutoCommit());</span><br><span class="line">            con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">            statement.executeUpdate(sql);</span><br><span class="line">            statement.executeUpdate(sql1);</span><br><span class="line">            statement.executeUpdate(sql2);</span><br><span class="line">            con.commit();</span><br><span class="line">            System.out.println(<span class="string">&quot;事务提交成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                con.rollback();</span><br><span class="line">                System.out.println(<span class="string">&quot;有异常,进行回滚&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-获取自增主键"><a href="#3-获取自增主键" class="headerlink" title="3.获取自增主键"></a>3.获取自增主键</h2><h3 id="1-方法摘要-1"><a href="#1-方法摘要-1" class="headerlink" title="1.方法摘要"></a>1.方法摘要</h3><p>RETURN_GENERATED_KEYS：是Statement的属性，表示与数据库的主键值绑定，在使⽤的时候可以取出来。getGeneratedKeys()：是Statement的⽅法，获取⽣成键的结果集。在使⽤Statement.RETURN_GENERATED_KEYS时，需要特别注意，被操作的数据表主键Id必须设置AUTO_INCREMENT属性。数据库⾃增的Id和⼿动插⼊的Id均可正常返回。</p><h3 id="2-应用示例"><a href="#2-应用示例" class="headerlink" title="2.应用示例"></a>2.应用示例</h3><p>1.根据⽤户输⼊的部⻔名称和部⻔地址实现数据插⼊操作，并返回⾃动⽣成的主键值。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo09</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"> System.out.println(<span class="string">&quot;请输⼊部⻔名称：&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">deptName</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">  System.out.println(<span class="string">&quot;请输⼊部⻔地址：&quot;</span>);</span><br><span class="line">  <span class="type">String</span> <span class="variable">deptLocation</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">                         <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DBUtils.getConnection();</span><br><span class="line">                         <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO department VALUES (null, ?, ?)&quot;</span>;</span><br><span class="line">                         <span class="comment">// RETURN_GENERATED_KEYS表示与数据库的主键值绑定，在使⽤的时候可以取出来</span></span><br><span class="line">                         <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql,</span><br><span class="line">                            Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">                             pstmt.setString(<span class="number">1</span>, deptName);</span><br><span class="line">                             pstmt.setString(<span class="number">2</span>, deptLocation);</span><br><span class="line">                             pstmt.executeUpdate();</span><br><span class="line">                             <span class="comment">// 获取⽣成键的结果集</span></span><br><span class="line">                             <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.getGeneratedKeys();</span><br><span class="line">                             <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                             <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line">                             System.out.println(<span class="string">&quot;执⾏完成：&quot;</span> + id);</span><br><span class="line">                             &#125;</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.根据⽤户输⼊的部⻔信息保存部⻔，并将⾃动返回的部⻔id作为员⼯的部⻔进⾏数据的保存操作。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo10</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输⼊部⻔名称：&quot;</span>);</span><br><span class="line"> <span class="type">String</span> <span class="variable">deptName</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"> System.out.println(<span class="string">&quot;请输⼊部⻔地址：&quot;</span>);</span><br><span class="line"> <span class="type">String</span> <span class="variable">deptLocation</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line"> System.out.println(<span class="string">&quot;请输⼊员⼯姓名：&quot;</span>);</span><br><span class="line">             <span class="type">String</span> <span class="variable">empName</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">             System.out.println(<span class="string">&quot;请输⼊员⼯年龄：&quot;</span>);</span><br><span class="line">             <span class="type">int</span> <span class="variable">empAge</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"> <span class="keyword">try</span>(<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DBUtils.getConnection();) &#123;</span><br><span class="line">                     <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO department VALUES (null, ?, ?)&quot;</span>;</span><br><span class="line">                     <span class="comment">// RETURN_GENERATED_KEYS表示与数据库的主键值绑定，在使⽤的时候可以取出来</span></span><br><span class="line">                     <span class="type">PreparedStatement</span> <span class="variable">pstmt1</span> <span class="operator">=</span> conn.prepareStatement(sql1,</span><br><span class="line">                    Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">                     pstmt1.setString(<span class="number">1</span>, deptName);</span><br><span class="line">                     pstmt1.setString(<span class="number">2</span>, deptLocation);</span><br><span class="line">                     pstmt1.executeUpdate();</span><br><span class="line">                     <span class="comment">// 获取⽣成键的结果集</span></span><br><span class="line">                     <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt1.getGeneratedKeys();</span><br><span class="line">                     <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                     <span class="type">int</span> <span class="variable">deptId</span> <span class="operator">=</span> rs.getInt(<span class="number">1</span>);</span><br><span class="line">                     <span class="comment">// 得到部⻔id后开始保存员⼯</span></span><br><span class="line">                     <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO employee VALUES (null, ?, ?, ?)&quot;</span>;</span><br><span class="line">                     <span class="type">PreparedStatement</span> <span class="variable">pstmt2</span> <span class="operator">=</span> conn.prepareStatement(sql2);</span><br><span class="line">                     pstmt2.setString(<span class="number">1</span>, empName);</span><br><span class="line">                     pstmt2.setInt(<span class="number">2</span>, empAge);</span><br><span class="line">                     pstmt2.setInt(<span class="number">3</span>, deptId);</span><br><span class="line">                     <span class="comment">// 执⾏保存</span></span><br><span class="line">                     pstmt2.executeUpdate();</span><br><span class="line">                     System.out.println(<span class="string">&quot;保存成功！&quot;</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">             &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">             e.printStackTrace();</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.根据⽤户输⼊的部⻔信息查询部⻔是否存在，如果不存在，先插⼊部⻔信息，然后再保存员⼯信息。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo11</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">                 <span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                 System.out.println(<span class="string">&quot;请输⼊部⻔名称：&quot;</span>);</span><br><span class="line">                 <span class="type">String</span> <span class="variable">deptName</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                 System.out.println(<span class="string">&quot;请输⼊部⻔地址：&quot;</span>);</span><br><span class="line">                 <span class="type">String</span> <span class="variable">deptLocation</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                 System.out.println(<span class="string">&quot;请输⼊员⼯姓名：&quot;</span>);</span><br><span class="line">                 <span class="type">String</span> <span class="variable">empName</span> <span class="operator">=</span> sc.nextLine();</span><br><span class="line">                 System.out.println(<span class="string">&quot;请输⼊员⼯年龄：&quot;</span>);</span><br><span class="line">                 <span class="type">int</span> <span class="variable">empAge</span> <span class="operator">=</span> sc.nextInt();</span><br><span class="line"> <span class="keyword">try</span>(<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DBUtils.getConnection();) &#123;</span><br><span class="line">                     <span class="comment">// 查询是否存在⽤户输⼊的部⻔名称</span></span><br><span class="line">                     <span class="type">String</span> <span class="variable">sql1</span> <span class="operator">=</span> <span class="string">&quot;SELECT id FROM department WHERE dept_name=?&quot;</span>;</span><br><span class="line">                     <span class="type">PreparedStatement</span> <span class="variable">pstmt1</span> <span class="operator">=</span> conn.prepareStatement(sql1);</span><br><span class="line">                     pstmt1.setString(<span class="number">1</span>, deptName);</span><br><span class="line">                     <span class="type">ResultSet</span> <span class="variable">rs1</span> <span class="operator">=</span> pstmt1.executeQuery();</span><br><span class="line">                     <span class="comment">// 存储部⻔id</span></span><br><span class="line">                     <span class="type">int</span> <span class="variable">deptId</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">                     <span class="keyword">while</span> (rs1.next()) &#123;</span><br><span class="line"></span><br><span class="line">                     deptId = rs1.getInt(<span class="number">1</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// 通过判断deptId值来确定部⻔是否存在</span></span><br><span class="line">                     <span class="keyword">if</span> (deptId == -<span class="number">1</span>) &#123; <span class="comment">// 部⻔不存在</span></span><br><span class="line">                     <span class="type">String</span> <span class="variable">sql2</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO department VALUES (null, ?, ?)&quot;</span>;</span><br><span class="line">                     <span class="comment">// RETURN_GENERATED_KEYS表示与数据库的主键值绑定，在使⽤的时候可以取出来</span></span><br><span class="line">                     <span class="type">PreparedStatement</span> <span class="variable">pstmt2</span> <span class="operator">=</span> conn.prepareStatement(sql2,</span><br><span class="line">                    Statement.RETURN_GENERATED_KEYS);</span><br><span class="line">                     pstmt2.setString(<span class="number">1</span>, deptName);</span><br><span class="line">                     pstmt2.setString(<span class="number">2</span>, deptLocation);</span><br><span class="line">                     pstmt2.executeUpdate();</span><br><span class="line">                     <span class="comment">// 获取⽣成键的结果集</span></span><br><span class="line">                     <span class="type">ResultSet</span> <span class="variable">rs2</span> <span class="operator">=</span> pstmt2.getGeneratedKeys();</span><br><span class="line">                     <span class="keyword">while</span> (rs2.next()) &#123;</span><br><span class="line">                     deptId = rs2.getInt(<span class="number">1</span>);</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">                         <span class="comment">// 开始保存员⼯信息</span></span><br><span class="line">                         <span class="type">String</span> <span class="variable">sql3</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO employee VALUES (null, ?, ?, ?)&quot;</span>;</span><br><span class="line">                         <span class="type">PreparedStatement</span> <span class="variable">pstmt3</span> <span class="operator">=</span> conn.prepareStatement(sql3);</span><br><span class="line">                         pstmt3.setString(<span class="number">1</span>, empName);</span><br><span class="line">                         pstmt3.setInt(<span class="number">2</span>, empAge);</span><br><span class="line">                         pstmt3.setInt(<span class="number">3</span>, deptId);</span><br><span class="line">                     <span class="comment">// 执⾏保存</span></span><br><span class="line">                     pstmt3.executeUpdate();</span><br><span class="line">                     System.out.println(<span class="string">&quot;保存成功！&quot;</span>);</span><br><span class="line">                     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                     e.printStackTrace();</span><br><span class="line">                     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-元数据"><a href="#4-元数据" class="headerlink" title="4.元数据"></a>4.元数据</h2><p>元数据（MetaData）是关于数据的数据。元数据是描述数据库内数据的结构和建⽴⽅法的数据。元数据分类：数据库元数据和表的元数据</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo12</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="keyword">try</span> (<span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> DBUtils.getConnection();) &#123;</span><br><span class="line"> <span class="comment">// 获取数据库元数据</span></span><br><span class="line"> <span class="type">DatabaseMetaData</span> <span class="variable">dbmd</span> <span class="operator">=</span> conn.getMetaData();</span><br><span class="line"> System.out.println(<span class="string">&quot;数据库⼚商：&quot;</span> + dbmd.getDatabaseProductName());</span><br><span class="line"> System.out.println(<span class="string">&quot;驱动版本：&quot;</span> + dbmd.getDriverVersion());</span><br><span class="line"> System.out.println(<span class="string">&quot;连接地址：&quot;</span> + dbmd.getURL());</span><br><span class="line"> System.out.println(<span class="string">&quot;⽤户名：&quot;</span> + dbmd.getUserName());</span><br><span class="line"> <span class="comment">// 获取表的元数据信息需要先进⾏查询操作</span></span><br><span class="line"> <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> conn.createStatement();</span><br><span class="line"> <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> statement.executeQuery(<span class="string">&quot;SELECT * FROM emp&quot;</span>);</span><br><span class="line"> <span class="comment">// 获取表的元数据</span></span><br><span class="line"> <span class="type">ResultSetMetaData</span> <span class="variable">rsmd</span> <span class="operator">=</span> rs.getMetaData();</span><br><span class="line"> <span class="comment">// 获取表字段数量</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> rsmd.getColumnCount();</span><br><span class="line"> <span class="comment">// 遍历每个字段的名字和类型</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line"> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> rsmd.getColumnName(i);</span><br><span class="line"> <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> rsmd.getColumnTypeName(i);</span><br><span class="line"> System.out.println(name + <span class="string">&quot;:&quot;</span> + type);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-什么是JDBC-JNDI-DBCP-DataSource"><a href="#5-什么是JDBC-JNDI-DBCP-DataSource" class="headerlink" title="5.什么是JDBC,JNDI,DBCP,DataSource"></a>5.什么是JDBC,JNDI,DBCP,DataSource</h2><p>JDBC: Java DataBase Connectivity  java数据库连接和执行SQL语句的API</p><p>JNDI: Java Naming and Directory Interface ,Java命名和目录接口,JNDI是指使用数据源连接数据库的这种方式,简单的可以将JDNI理解成所有DataScource的集合</p><p>DBCP: DataBase Connection Pool,数据库连接池,数据连接池就是连接数据库进程的集合,一般的SQL执行都是”建立数据库连接-执行SQL-关闭数据库”,对于平凡的数据库连接应用,这样反复建立连接-关闭连接是非常消耗系统资源的</p><p>DataSource: 数据源,就是将IP,数据库,用户名,密码,封装起来对外只提供一个JNDI名称,在应用中只要调用这个JNDI就能连接数据库,而不需要在代码中写入用户名,密码等.这样的好处是,当用户名.密码乃至数据库发生变化时,只需要去修改JNDI的xml文件而不需要修改代码</p><p><img src="/2023/05/18/JDBC/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230518011005100.png" alt="image-20230518011005100"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JDBC&quot;&gt;&lt;a href=&quot;#JDBC&quot; class=&quot;headerlink&quot; title=&quot;JDBC&quot;&gt;&lt;/a&gt;JDBC&lt;/h1&gt;&lt;h1 id=&quot;1-JDBC概述&quot;&gt;&lt;a href=&quot;#1-JDBC概述&quot; class=&quot;headerlink&quot; title=&quot;1</summary>
      
    
    
    
    <category term="JDBC" scheme="http://example.com/categories/JDBC/"/>
    
    
    <category term="JDBC" scheme="http://example.com/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>mysql笔记</title>
    <link href="http://example.com/2023/05/17/mysql%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2023/05/17/mysql%E7%AC%94%E8%AE%B0/</id>
    <published>2023-05-17T12:07:49.000Z</published>
    <updated>2023-05-18T01:16:20.191Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h1 id="一-数据库的基本概念"><a href="#一-数据库的基本概念" class="headerlink" title="一.数据库的基本概念"></a>一.数据库的基本概念</h1><h2 id="1-数据库的基本概念"><a href="#1-数据库的基本概念" class="headerlink" title="1,数据库的基本概念"></a>1,数据库的基本概念</h2><p>数据库（Database）是“按照数据结构来组织、存储和管理数据的仓库”。是⼀个⻓期存储在计算机内的、有组织的、可共享的、统⼀管理的⼤量数据的集合。其本质是⼀个⽂件系统，还是以⽂件的⽅式，将数据保存在电脑上。</p><h2 id="2-什么是数据库管理系统"><a href="#2-什么是数据库管理系统" class="headerlink" title="2.什么是数据库管理系统"></a>2.什么是数据库管理系统</h2><p>数据库管理系统（Database Management System）是⼀种操纵和管理数据库的⼤型软件，⽤于建⽴、使⽤和维护数据库，简称 DBMS。它对数据库进⾏统⼀的管理和控制，以保证数据库的安全性和完整性。</p><h2 id="3-数据库的优点"><a href="#3-数据库的优点" class="headerlink" title="3.数据库的优点"></a>3.数据库的优点</h2><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230512210528327.png" alt="image-20230512210528327"></p><h1 id="二-SQL"><a href="#二-SQL" class="headerlink" title="二.SQL"></a>二.SQL</h1><h2 id="1-SQL的概念"><a href="#1-SQL的概念" class="headerlink" title="1.SQL的概念"></a>1.SQL的概念</h2><p>结构化查询语⾔（Structured Query Language）简称SQL，是⼀种特殊的编程语⾔，是⼀种数据库查询和程序设计语⾔，⽤于存取数据以及查询、更新和管理关系数据库系统。</p><h2 id="2-SQL的作用"><a href="#2-SQL的作用" class="headerlink" title="2.SQL的作用"></a>2.SQL的作用</h2><blockquote><p>1.是所有关系型数据库的统⼀查询规范，不同的关系型数据库都⽀持SQL。</p><p>2.所有的关系型数据库都可以使⽤SQL。</p><p>3.不同数据库之间的SQL有⼀些区别（⽅⾔）。</p></blockquote><h2 id="3-SQL-通用语法"><a href="#3-SQL-通用语法" class="headerlink" title="3.SQL 通用语法"></a>3.SQL 通用语法</h2><blockquote><p>1.SQL语句可以单⾏或者多⾏书写，以”;”分号结尾。</p><p>2.可以使⽤空格和缩进来增加语句的可读性。</p><p>3.MySQL中使⽤SQL不区分⼤⼩写，⼀般关键字⼤写，数据库名、表名、列名⼩写。</p><p>4.注释方式</p><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230512211550227.png" alt="image-20230512211550227"></p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#show databases; 单⾏注释</span><br><span class="line">-- show databases; 单⾏注释</span><br><span class="line">/*</span><br><span class="line">多⾏注释</span><br><span class="line">show databases;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h2 id="4-SQL的分类"><a href="#4-SQL的分类" class="headerlink" title="4.SQL的分类"></a>4.SQL的分类</h2><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230512211654785.png" alt="image-20230512211654785"></p><p>数据库管理系统、数据库和表的关系如图所示：</p><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230512211715005.png" alt="image-20230512211715005"></p><h2 id="5-DDL-操作数据库"><a href="#5-DDL-操作数据库" class="headerlink" title="5.DDL 操作数据库"></a>5.DDL 操作数据库</h2><h3 id="1-创建数据库"><a href="#1-创建数据库" class="headerlink" title="1 创建数据库"></a>1 创建数据库</h3><p>​创建数据库的方式:</p><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>CREATE DATABASE 数据库名</td><td>创建指定名称的数据库</td></tr><tr><td>CREATE DATABASE IF NOT EXISTSN 数据库名;</td><td>判断数据库是否存在,不存在则创建数据库</td></tr><tr><td>CREATE DATABASE 数据库名 CHARCTER SET 字符集;</td><td>创建指定名称的数据库,并且指定字符集(一般指定utf8)</td></tr></tbody></table><p>实例代码</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--创建指定名称的数据库</span></span><br><span class="line"><span class="keyword">create</span> database mydb;</span><br><span class="line"><span class="comment">--判断数据库是否存在,不存在则创建数据库</span></span><br><span class="line"><span class="keyword">create</span> database if <span class="keyword">not</span> exist mydb;</span><br><span class="line"><span class="comment">--创建指定名称的数据库,并且指定字符集(一般指定utf8)</span></span><br><span class="line"><span class="keyword">create</span> database mydb <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br></pre></td></tr></table></figure><h3 id="2-查看数据库"><a href="#2-查看数据库" class="headerlink" title="2.查看数据库"></a>2.查看数据库</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>SHOW DATABASE;</td><td>查看MySQL中都有哪些数据库</td></tr><tr><td>SHOW CREATE DATABASE 数据库名;</td><td>查看一个数据库的定义信息</td></tr></tbody></table><p>实例代码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查看MySQL中都有哪些数据库</span><br><span class="line">show database</span><br><span class="line">-- 查看MySQL中都有哪些数据库</span><br><span class="line">show create database mydb;</span><br></pre></td></tr></table></figure><h3 id="3-修改数据库"><a href="#3-修改数据库" class="headerlink" title="3.修改数据库"></a>3.修改数据库</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>ALTER DATABASE 数据库名 CHARACTER SET 字符集</td><td>数据库字符集操作</td></tr></tbody></table><p>实例代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 数据库字符集操作</span><br><span class="line">alter database mydb character set utf8;</span><br><span class="line">-- 查看数据库信息是否修改成功</span><br><span class="line">show create database mydb;</span><br></pre></td></tr></table></figure><h3 id="4-删除数据库"><a href="#4-删除数据库" class="headerlink" title="4.删除数据库"></a>4.删除数据库</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>drop database 数据库名</td><td>从mysql中永久的删除某个数据库</td></tr></tbody></table><p>实例代码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop database mydb</span><br></pre></td></tr></table></figure><h3 id="5-使用数据库"><a href="#5-使用数据库" class="headerlink" title="5.使用数据库"></a>5.使用数据库</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>USE 数据库;</td><td>使用切换数据库</td></tr><tr><td>select database();</td><td>查看当前正在使用的数据库,使用mysql中的全局函数</td></tr></tbody></table><p>实例代码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 切换数据库</span><br><span class="line">use mydb</span><br><span class="line">-- 查看当前使用的数据库</span><br><span class="line">select database();</span><br></pre></td></tr></table></figure><h2 id="6-DDL操作数据库"><a href="#6-DDL操作数据库" class="headerlink" title="6.DDL操作数据库"></a>6.DDL操作数据库</h2><h3 id="1-mysql数据类型"><a href="#1-mysql数据类型" class="headerlink" title="1.mysql数据类型"></a>1.mysql数据类型</h3><p>常见数据类型:</p><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230513113553336.png" alt="image-20230513113553336"></p><p>详细数据类型:</p><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230513113622938.png" alt="image-20230513113622938"></p><p><strong>char与varchar 区别:</strong></p><blockquote><p><strong>char</strong>类型是固定长度,根据定义的字符串长度分配足够的空间,适合存储固定长度的字符串,比如密码,性别</p><p><strong>varchar</strong>类型是可变长度,只使用字符串长度所需的空间,适合存储在一定范围内长度变化的字符串</p></blockquote><h3 id="1-创建表"><a href="#1-创建表" class="headerlink" title="1.创建表"></a>1.创建表</h3><p>语法格式:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">字段名1 数据类型(长度),</span><br><span class="line">字段名2 数据类型(长度),</span><br><span class="line">    .....</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>实例代码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建学生表,包括学号,姓名,性别等</span><br><span class="line">create table student (</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">name varchar(255),</span><br><span class="line">sex varchar</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 注意: primary key 代表主键</span><br><span class="line">-- auto_increment 代表自动增加</span><br></pre></td></tr></table></figure><h3 id="2-快速创建一个表结构相同的表"><a href="#2-快速创建一个表结构相同的表" class="headerlink" title="2.快速创建一个表结构相同的表**"></a>2.快速创建一个表结构相同的表**</h3><p>语法格式:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 新表名 like 旧表名</span><br></pre></td></tr></table></figure><p>代码实例:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 需求创建一个和student表结构相同的stu表</span><br><span class="line">create table stu like student</span><br><span class="line">-- 查看stu的表结构</span><br><span class="line">desc stu</span><br></pre></td></tr></table></figure><h3 id="3-comment-注释"><a href="#3-comment-注释" class="headerlink" title="3.comment 注释"></a>3.comment 注释</h3><p>语法格式:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名( </span><br><span class="line">字段名 字段类型 comment &#x27;字段的注释&#x27;</span><br><span class="line">) comment = &#x27;表注释&#x27;;</span><br></pre></td></tr></table></figure><h3 id="4-查看表"><a href="#4-查看表" class="headerlink" title="4.查看表"></a>4.查看表</h3><h4 id="1-查询命令"><a href="#1-查询命令" class="headerlink" title="1.查询命令"></a>1.查询命令</h4><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>SHOW TABLES</td><td>查看当前数据库中的所有表名</td></tr><tr><td>DESC 表名</td><td>查看数据表的结构</td></tr><tr><td>SHOW CREATE TABLE 表名</td><td>查看创建表的SQL语句</td></tr></tbody></table><p>实例代码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查看当前数据库中的所有表名</span><br><span class="line">show tables</span><br><span class="line">-- 查看数据库的表结构</span><br><span class="line">DESC 表名</span><br><span class="line">-- 查看创建表的SQL语句</span><br><span class="line">show create table 表名</span><br></pre></td></tr></table></figure><h4 id="2-MySQL存储引擎"><a href="#2-MySQL存储引擎" class="headerlink" title="2.MySQL存储引擎"></a>2.MySQL存储引擎</h4><h5 id="1-MyISAM"><a href="#1-MyISAM" class="headerlink" title="1.MyISAM"></a>1.MyISAM</h5><blockquote><p>优势:速度快,磁盘空间占用少;某个库或表的磁盘占用状况即能够经过操作系统查看相应的文件的大小.也能经过SQL语句 SHOW TABLE TATUS 查的</p><p>缺点:没有数据完整性机制,既不支持事务和外键</p></blockquote><h5 id="2-InnoDB"><a href="#2-InnoDB" class="headerlink" title="2.InnoDB"></a>2.InnoDB</h5><blockquote><p>优势:支持事务和外键,数据完整性机制比较完备;能够用SHOW TABLE STATUS 查看某个库或表的磁盘占用</p><p>缺点:速度超慢,磁盘空间占用多,全部库都存于一个或者多个文件中,没发经过操作系统了解某个库或表的占用空间</p></blockquote><h3 id="3-删除表"><a href="#3-删除表" class="headerlink" title="3.删除表"></a>3.删除表</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>DROP TABLE 表名;</td><td>删除表(从数据库中永久删除某一张表)</td></tr><tr><td>DROP  TABLE  EXISTS 表名</td><td>判断表是否存在,存在删除,不存在不执行SQL语句</td></tr></tbody></table><p>实例代码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table nydb;</span><br><span class="line">drop table exists mydb;</span><br></pre></td></tr></table></figure><h3 id="4-修改表"><a href="#4-修改表" class="headerlink" title="4.修改表"></a>4.修改表</h3><h4 id="1-修改表名"><a href="#1-修改表名" class="headerlink" title="1.修改表名"></a>1.修改表名</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rename table 旧表名 to 新表名</span><br></pre></td></tr></table></figure><h4 id="2-修改表的存储引擎和字符集"><a href="#2-修改表的存储引擎和字符集" class="headerlink" title="2.修改表的存储引擎和字符集"></a>2.修改表的存储引擎和字符集</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 enging = 引擎类型 charset = 字符集;</span><br></pre></td></tr></table></figure><h4 id="3-向表中添加列"><a href="#3-向表中添加列" class="headerlink" title="3.向表中添加列"></a>3.向表中添加列</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 add 字段名 字段类型</span><br></pre></td></tr></table></figure><p>实例代码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 需求:向表中添加sex char</span><br><span class="line">alter table mydb add sex char; # 添加在到最后面</span><br><span class="line">alter table mydb add sex char first; #添加到最前面</span><br><span class="line">alter table mydb add sex char name; #添加到name字段的后面</span><br></pre></td></tr></table></figure><h4 id="4-修改表中列的数据类型或长度或者字段位置"><a href="#4-修改表中列的数据类型或长度或者字段位置" class="headerlink" title="4.修改表中列的数据类型或长度或者字段位置"></a>4.修改表中列的数据类型或长度或者字段位置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 默认字段追加在最后面</span><br><span class="line">alter table 表名 modify 字段名称 新字段类型</span><br><span class="line">-- 将字段添加到第一个位置</span><br><span class="line">alter table 表名 modify 字段名称 字段类型 first;</span><br><span class="line">-- 将字段添加到指定字段后面</span><br><span class="line">alter table 表名 字段名称 字段类型 xxx;</span><br></pre></td></tr></table></figure><h4 id="5-修改列的名称"><a href="#5-修改列的名称" class="headerlink" title="5.修改列的名称"></a>5.修改列的名称</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 change 旧列名 新列名 新类型;</span><br></pre></td></tr></table></figure><h4 id="6-删除列"><a href="#6-删除列" class="headerlink" title="6.删除列"></a>6.删除列</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 drop 列名</span><br></pre></td></tr></table></figure><h4 id="7-修改表和列的注释"><a href="#7-修改表和列的注释" class="headerlink" title="7.修改表和列的注释"></a>7.修改表和列的注释</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 修改表的注释</span><br><span class="line">alter table 表名 comment &#x27;表的注释内容</span><br><span class="line">--修改字段的注释</span><br><span class="line">alter table 表名 modify column 字段名称 字段类型 comment = &#x27;字段注释&#x27;</span><br></pre></td></tr></table></figure><h2 id="7-DML操作表中数据"><a href="#7-DML操作表中数据" class="headerlink" title="7.DML操作表中数据"></a>7.DML操作表中数据</h2><p>SQL中DML用于对表中的数据进行增删该操作</p><h3 id="1-插入数据"><a href="#1-插入数据" class="headerlink" title="1.插入数据"></a>1.插入数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into 表名 (字段1,字段2.....) values (值1,值2....);</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><blockquote><ol><li>值与字段必须一一对应,个数相同且数据类型相同</li><li>数值的数据大小,必须在字段指定的长度范围内</li><li>char varchar date类型的值必须使用单引号,或者双引号</li><li>如果要插入空值,可以忽略不写,或者插入null</li><li>如果插入指定字段的值,必须写上列名</li></ol></blockquote><h3 id="2-更改数据"><a href="#2-更改数据" class="headerlink" title="2.更改数据"></a>2.更改数据</h3><h4 id="1-不带条件的修改数据"><a href="#1-不带条件的修改数据" class="headerlink" title="1.不带条件的修改数据"></a>1.不带条件的修改数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update 表明 set 字段名 = 值</span><br></pre></td></tr></table></figure><h4 id="2-带条件的修改数据"><a href="#2-带条件的修改数据" class="headerlink" title="2.带条件的修改数据"></a>2.带条件的修改数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update 表名 set 列名 = 值 where 条件表达式</span><br></pre></td></tr></table></figure><h3 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3.删除数据"></a>3.删除数据</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>delete from 表名;</td><td>不推荐,有多少记录删除多少记录的操作,效率低</td></tr><tr><td>truncate table 表名;</td><td>推荐,先删除整张表,然后再重新创建一张一模一样的表,效率高</td></tr></tbody></table><h2 id="8-DQL查询表中的数据"><a href="#8-DQL查询表中的数据" class="headerlink" title="8.DQL查询表中的数据"></a>8.DQL查询表中的数据</h2><h3 id="1-简单查询"><a href="#1-简单查询" class="headerlink" title="1.简单查询"></a>1.简单查询</h3><h4 id="1-查alter-table询所有的列"><a href="#1-查alter-table询所有的列" class="headerlink" title="1.查alter table询所有的列"></a>1.查alter table询所有的列</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 表名</span><br></pre></td></tr></table></figure><h4 id="2-查询指定列"><a href="#2-查询指定列" class="headerlink" title="2.查询指定列"></a>2.查询指定列</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段名1,字段名2.... from student </span><br></pre></td></tr></table></figure><h4 id="3-指定列的别名查询"><a href="#3-指定列的别名查询" class="headerlink" title="3.指定列的别名查询"></a>3.指定列的别名查询</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段名 as 别名,字段名2 as 别名...from 表名 as 表别名</span><br></pre></td></tr></table></figure><h4 id="4-清除重复值"><a href="#4-清除重复值" class="headerlink" title="4.清除重复值"></a>4.清除重复值</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select distinct 字段名 from 表名</span><br></pre></td></tr></table></figure><h4 id="5-查询结果参与运算"><a href="#5-查询结果参与运算" class="headerlink" title="5.查询结果参与运算"></a>5.查询结果参与运算</h4><p>某列和固定值运算</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段名+固定值 from 表名;</span><br></pre></td></tr></table></figure><p>列和列进行运算</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 列1+列2 from 表名</span><br></pre></td></tr></table></figure><h3 id="2-条件查询"><a href="#2-条件查询" class="headerlink" title="2.条件查询"></a>2.条件查询</h3><p>在实际应用中,通过指定查询条件进行过滤</p><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1.语法"></a>1.语法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 列名 from 表名 where 条件表达式;</span><br></pre></td></tr></table></figure><h4 id="2-比较运算符"><a href="#2-比较运算符" class="headerlink" title="2.比较运算符"></a>2.比较运算符</h4><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230513145907355.png" alt="image-20230513145907355"></p><h4 id="4-null-运算符"><a href="#4-null-运算符" class="headerlink" title="4.null 运算符"></a>4.null 运算符</h4><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230513145935508.png" alt="image-20230513145935508"></p><h4 id="5-逻辑运算符"><a href="#5-逻辑运算符" class="headerlink" title="5.逻辑运算符"></a>5.逻辑运算符</h4><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230513145955604.png" alt="image-20230513145955604"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询age⼤于35且性别为男的学⽣(两个条件同时满⾜)</span><br><span class="line">select * from student3 where age&gt;35 and sex=&#x27;男&#x27;;</span><br><span class="line">-- 查询age⼤于35或性别为男的学⽣(两个条件其中⼀个满⾜)</span><br><span class="line">select * from student3 where age&gt;35 or sex=&#x27;男&#x27;;</span><br><span class="line">-- 查询id是1或3或5的学⽣</span><br><span class="line">select * from student3 where id=1 or id=3 or id=5;</span><br><span class="line">-- 查询性别不是&#x27;男&#x27;的所有学⽣</span><br><span class="line">select * from student3 where not sex=&#x27;男&#x27;;</span><br></pre></td></tr></table></figure><h4 id="6-in关键字"><a href="#6-in关键字" class="headerlink" title="6.in关键字"></a>6.in关键字</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段名 from 表名 字段名 in (数据1,是数据2...);</span><br></pre></td></tr></table></figure><p>in中每个数据都会作为一次条件,只要满足条件就会显示</p><p>实例代码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from student id  in (1,2,3);</span><br><span class="line">-- 查询满足id=1或id=2或id=3的所有信息</span><br></pre></td></tr></table></figure><h4 id="7-范围查询"><a href="#7-范围查询" class="headerlink" title="7.范围查询"></a>7.范围查询</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">between 值1 and 值2;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--需求查询student表中 成绩score大于60小于75 的学生信息</span><br><span class="line">select * from student score between 60 and 75;</span><br></pre></td></tr></table></figure><h4 id="8-like-关键字"><a href="#8-like-关键字" class="headerlink" title="8.like 关键字"></a>8.like 关键字</h4><p>like模糊查询:</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表名 <span class="keyword">where</span> 字段名 <span class="keyword">like</span> <span class="operator">=</span>&quot;统配字符串&quot;;</span><br></pre></td></tr></table></figure><p>通配符:</p><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230513150627774.png" alt="image-20230513150627774"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查询含有&#x27;精&#x27;字的所有员⼯信息</span><br><span class="line"></span><br><span class="line">SELECT * FROM emp WHERE ename LIKE &#x27;%精%&#x27;;</span><br><span class="line"></span><br><span class="line"># 查询以&#x27;孙&#x27;开头的所有员⼯信息</span><br><span class="line"></span><br><span class="line">SELECT * FROM emp WHERE ename LIKE &#x27;孙%&#x27;;</span><br><span class="line"></span><br><span class="line"># 查询第⼆个字为&#x27;兔&#x27;的所有员⼯信息</span><br><span class="line">SELECT * FROM emp WHERE ename LIKE &#x27;_兔%&#x27;;</span><br></pre></td></tr></table></figure><h1 id="三-单表"><a href="#三-单表" class="headerlink" title="三.单表"></a>三.单表</h1><h2 id="1-DQL操作单表"><a href="#1-DQL操作单表" class="headerlink" title="1.DQL操作单表"></a>1.DQL操作单表</h2><h3 id="1-数据库间表的复制"><a href="#1-数据库间表的复制" class="headerlink" title="1.数据库间表的复制"></a>1.数据库间表的复制</h3><p>.在Navicat Premium窗⼝中，选择【⼯具】选项下的【数据传输】，在新打开的窗⼝中将“源”数据库中的表，通过“连接”复制到“⽬标”数据库中</p><h3 id="2-排序"><a href="#2-排序" class="headerlink" title="2.排序"></a>2.排序</h3><p>通过order by子句,可以查询出的结果集按照一个列或者多个列进行排序(不影响正式数据)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段名 from 表名 where 字段名 = 值 order by 字段名 asc/desc </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asc:升序(默认)</span><br><span class="line">desc:降序.</span><br></pre></td></tr></table></figure><h4 id="1-单列排序"><a href="#1-单列排序" class="headerlink" title="1.单列排序:"></a>1.单列排序:</h4><p>只按照某一个字段进行排序,就是单列排序</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 需求:使用salary 对emp数据进行排序</span><br><span class="line">-- 默认</span><br><span class="line">select * from emp order by salary;</span><br><span class="line">-- 降序</span><br><span class="line">select * from emp order by salary desc;</span><br></pre></td></tr></table></figure><h4 id="2-组合排序"><a href="#2-组合排序" class="headerlink" title="2.组合排序"></a>2.组合排序</h4><p>同时对多个字段进行排序,如果第一个字段相同就按照第二个字段排序,以此类推.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 在薪水salary的基础上,再使用eid进行排序,如果薪水相同就以eid做降序排序</span><br><span class="line">select * from emp order by salary desc,eid desc</span><br></pre></td></tr></table></figure><h2 id="3-聚合函数"><a href="#3-聚合函数" class="headerlink" title="3.聚合函数"></a>3.聚合函数</h2><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 聚合函数(字段名) from 表名;</span><br></pre></td></tr></table></figure><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230513154226811.png" alt="image-20230513154226811"></p><h3 id="1-instr函数"><a href="#1-instr函数" class="headerlink" title="1.instr函数:"></a>1.instr函数:</h3><p><strong>简介:</strong></p><p>有时,想要在字符串中查找子字符串或检查字符串中是否存在子字符串,在这种情况下可以使用字符串内置instr()函数</p><p>instr()函数返回字符串中子字符串第一次出现的位置,如果在str中找不到子字符串,则instr()函数返回0;</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">instr(str,substr);</span><br><span class="line"> str:要搜索的字符串</span><br><span class="line"> substr:要搜苏的子字符串</span><br><span class="line"> </span><br><span class="line">instr不区分大小写搜索, 如果要强制区分大小写 在substr前使用 binary</span><br></pre></td></tr></table></figure><h3 id="2-instr函数和like运算符"><a href="#2-instr函数和like运算符" class="headerlink" title="2.instr函数和like运算符"></a>2.instr函数和like运算符</h3><p>1.假设要查找名称包含Car关键字产品,可以使用instr函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name from 表名 where instr(name,&#x27;Car&#x27;)&gt;0;</span><br></pre></td></tr></table></figure><p>2.除了instr函数,还可以使用like运算符进行匹配</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select name  from 表名 where name like &#x27;%Car%&#x27;</span><br></pre></td></tr></table></figure><h3 id="3-group-concat-函数"><a href="#3-group-concat-函数" class="headerlink" title="3.group_concat()函数"></a>3.group_concat()函数</h3><p>mysql中group_concat()函数将组中的字符串连接成具有各种选项的单个字符串</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">group_concat( distinct expression order by expression separator sep);</span><br></pre></td></tr></table></figure><h2 id="4-分组"><a href="#4-分组" class="headerlink" title="4.分组"></a>4.分组</h2><h3 id="1-group-by"><a href="#1-group-by" class="headerlink" title="1.group by"></a>1.group by</h3><p>分组查询指的是使用gruop by 语句结合聚合函数,根据一个或着多个列对结果进行分组,相同数据作为一组</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 分组字段,聚合函数 from 表名 group by 分组字段1,分组字段2...;</span><br></pre></td></tr></table></figure><p>注意:分组时可以查询要分组的字段,或者使用聚合函数进行统计操作,使用*查询其他字段没有意义.</p><p>实例代码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.查询所有部⻔信息</span><br><span class="line">select * from dept;</span><br><span class="line"># 2.查询每个部⻔的平均薪资</span><br><span class="line">select name, avg(salary) from dept group by name;</span><br><span class="line"># 3.查询每个部⻔的平均薪资，部⻔名称不能为null</span><br><span class="line">select name,avg(salary) from dept where name is not null group by name;</span><br></pre></td></tr></table></figure><h3 id="2-HAVING"><a href="#2-HAVING" class="headerlink" title="2.HAVING"></a>2.HAVING</h3><p>通常having和group by组合使用,在having后面写聚合函数的条件,having子句可以筛选分组后的各组数据.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 分组字段, 聚合函数 from 表名 group by 分组字段 ,having 条件;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.查询平均薪资⼤于6000的部⻔</span><br><span class="line"></span><br><span class="line">-- ⽅式1：需要在分组后再次进⾏过滤，使⽤having</span><br><span class="line"></span><br><span class="line">SELECT</span><br><span class="line"></span><br><span class="line"> dept_name,</span><br><span class="line"></span><br><span class="line"> AVG(salary)</span><br><span class="line"></span><br><span class="line">FROM emp WHERE dept_name IS NOT NULL GROUP BY dept_name HAVING AVG(salary) &gt; 6000;</span><br></pre></td></tr></table></figure><h4 id="where和having的区别"><a href="#where和having的区别" class="headerlink" title="where和having的区别"></a>where和having的区别</h4><p>通常在WHERE后⾯写普通字段的条件，⽽HAVING后⾯也可以写普通字段的条件，但是不推荐</p><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230513161659381.png" alt="image-20230513161659381"></p><h2 id="5-limit分页"><a href="#5-limit分页" class="headerlink" title="5.limit分页"></a>5.limit分页</h2><p>limit关键字的作用:</p><ul><li>limit是限制的作用,用于限制返回的查询结果的行数</li><li>limit是mysql的方言,用来完成分页</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段1,字段2,....from 表名 limit offset, length;</span><br><span class="line"></span><br><span class="line">参数说明:</span><br><span class="line">limit offset,length:关键字可以接受一个或两个为0或者正整数的参数</span><br><span class="line">offset:起始行数,从0开始计数,如果省略则默认为0</span><br><span class="line">length:返回的行数</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">各种关键字的顺序:</span><br><span class="line">select 字段1 from 表名 where 条件表达式 gruop by 分组字段 having 条件表达式 order by 字段名 asc/desc limit offset,length;</span><br></pre></td></tr></table></figure><p>分页公式:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">起始索引 = (当前页-1) * 每页条数</span><br></pre></td></tr></table></figure><p>实例代码:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.查询emp表中的前5条数据</span><br><span class="line">-- 参数1：起始值，默认是0；参数2：要查询的条数</span><br><span class="line">SELECT * FROM emp LIMIT 5;</span><br><span class="line">SELECT * FROM emp LIMIT 0, 5;</span><br><span class="line"># 2.查询emp表中从第4条开始，查询6条</span><br><span class="line">-- 起始值默认是从0开始的</span><br><span class="line">SELECT * FROM emp LIMIT 3, 6;</span><br></pre></td></tr></table></figure><h1 id="四-约束"><a href="#四-约束" class="headerlink" title="四.约束"></a>四.约束</h1><p>约束:创建表时给字段添加限制条件</p><h2 id="1-SQL约束介绍"><a href="#1-SQL约束介绍" class="headerlink" title="1.SQL约束介绍"></a>1.SQL约束介绍</h2><h3 id="1-约束的作用"><a href="#1-约束的作用" class="headerlink" title="1.约束的作用"></a>1.约束的作用</h3><p>对表中的数据进一步限制,从而保证数据的正确性&#x2F;有效性&#x2F;完整性,违反约束的不正确数据,无法插入到表中.</p><h3 id="2-常见约束"><a href="#2-常见约束" class="headerlink" title="2.常见约束"></a>2.常见约束</h3><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230513162917159.png" alt="image-20230513162917159"></p><h2 id="2-默认值约束"><a href="#2-默认值约束" class="headerlink" title="2.默认值约束"></a>2.默认值约束</h2><p>默认值约束用来指定某列的默认值.如在数据库里有一项数据重复,可以设置为默认值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名 字段类型 default 默认值.</span><br></pre></td></tr></table></figure><h2 id="3-主键约束"><a href="#3-主键约束" class="headerlink" title="3.主键约束"></a>3.主键约束</h2><p>主键:是表中的一个或多个字段,它的值用于唯一的标识表中的某一条记录.</p><p>主键约束:要求主键列数据唯一,并且不允许为null</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名 字段类型 primary key;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ⽅式1：创建⼀个带主键的表</span><br><span class="line">CREATE TABLE emp3(</span><br><span class="line"> -- 设置主键，唯⼀⾮空</span><br><span class="line"> eid INT PRIMARY KEY,</span><br><span class="line"> ename VARCHAR(20),</span><br><span class="line"> sex CHAR(1)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- ⽅式2：创建⼀个带主键的表</span><br><span class="line">CREATE TABLE emp3(</span><br><span class="line"> eid INT,</span><br><span class="line"> ename VARCHAR(20),</span><br><span class="line"> sex CHAR(1),</span><br><span class="line"> -- 指定主键为eid字段</span><br><span class="line"> PRIMARY KEY (eid)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- ⽅式3：创建⼀个带主键的表</span><br><span class="line">CREATE TABLE emp3(</span><br><span class="line"> eid INT ,</span><br><span class="line"> ename VARCHAR(20),</span><br><span class="line"> sex CHAR(1)</span><br><span class="line">)</span><br><span class="line">-- 创建的时候不指定主键，然后通过DDL语句进⾏设置</span><br><span class="line">ALTER TABLE emp3 ADD PRIMARY KEY (eid);</span><br></pre></td></tr></table></figure><p><strong>删除主键</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 使⽤DDL语句删除表中的主键</span><br><span class="line">ALTER TABLE emp3 DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure><p>删除主键约束说明：</p><ul><li>删除主键后唯⼀性约束失效，即字段数据可以重复；</li><li>删除主键后⾮空性约束保留，即字段数据不能为空</li></ul><p><strong>主键自增</strong></p><p>当主键定义为⾃增⻓后，那么这个主键的值就不需要⽤户输⼊数据，⽽由数据库系统根据定义⾃动赋值。当增加⼀条记录时，主键⾃动的以相同的步⻓来进⾏增⻓，这个步⻓是在建表的时候⽤户⾃⼰定义的。⼀般⾃增⻓数据只能是数值类型。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名 字段类型 primary key auto_increment</span><br></pre></td></tr></table></figure><p>修改自增起始值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建主键⾃增的表 ,⾃定义⾃增其实值</span><br><span class="line">CREATE TABLE emp5(</span><br><span class="line"> eid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line"> ename VARCHAR(20),</span><br><span class="line"> sex CHAR(1)</span><br><span class="line">) AUTO_INCREMENT=100;</span><br></pre></td></tr></table></figure><p>delete和truncate对自增的影响</p><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230513165449513.png" alt="image-20230513165449513"></p><h2 id="4-非空约束"><a href="#4-非空约束" class="headerlink" title="4.非空约束"></a>4.非空约束</h2><p>特点:某一列不能为null</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名 字段类型 NOT NULL</span><br></pre></td></tr></table></figure><h2 id="3-唯一约束"><a href="#3-唯一约束" class="headerlink" title="3.唯一约束"></a>3.唯一约束</h2><p>唯⼀约束的特点：表中的某⼀列的值不能重复（对NULL值不做唯⼀约束的判断，但只能出现⼀个空值）。</p><p>语法格式：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">字段名 字段类型 unique;</span><br></pre></td></tr></table></figure><p><strong>主键约束和唯一约束的区别</strong></p><p>1.主键约束,唯一且不能为空</p><p>2.唯一约束,唯一但可以为null</p><p>3.一个表中只能有一个主键,但可以有多个唯一约束</p><h2 id="4-外键约束"><a href="#4-外键约束" class="headerlink" title="4.外键约束"></a>4.外键约束</h2><h3 id="1-什么是外键约束"><a href="#1-什么是外键约束" class="headerlink" title="1.什么是外键约束"></a>1.什么是外键约束</h3><p>1.外键指的是在从表中与主表的主键对应的那个字段；⽐如员⼯表的dept_id，就是外键。</p><p>2.使⽤外键约束可以让两张表之间产⽣⼀个对应关系，从⽽保证主从表的引⽤的完整性。</p><p>3.多表关系中的主表和从表：</p><p>​主表：主键id所在的表，是约束别的表的表；</p><p>​从表：外键所在的表，是被约束的表。</p><h3 id="2-创建外键约束"><a href="#2-创建外键约束" class="headerlink" title="2.创建外键约束"></a>2.创建外键约束</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新建表时添加外键约束</span><br><span class="line">constraint 外键约束名称 foreing key 外键字段名 references 主表(主键字段名);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在已有的表添加外键约束</span><br><span class="line">alter table 表名 add constraint 外键约束名 foreing key 外键字段名 referencrs 主表(主键字段名);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 重新创建employee表，添加外键约束</span><br><span class="line">CREATE TABLE employee(</span><br><span class="line"> eid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line"> ename VARCHAR(20),</span><br><span class="line"> age INT,</span><br><span class="line"> dept_id INT,</span><br><span class="line"> -- 添加外键约束</span><br><span class="line"> CONSTRAINT emp_dept_fk FOREIGN KEY(dept_id) REFERENCES department(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- ⽅式1：添加外键约束</span><br><span class="line">ALTER TABLE employee ADD CONSTRAINT emp_dept_fk FOREIGN KEY (dept_id) REFERENCES</span><br><span class="line">department(id);</span><br><span class="line">-- ⽅式2：可以省略外键名称，系统会⾃动⽣成⼀个</span><br><span class="line">ALTER TABLE employee ADD FOREIGN KEY (dept_id) REFERENCES department (id);</span><br></pre></td></tr></table></figure><h3 id="3-删除外键"><a href="#3-删除外键" class="headerlink" title="3.删除外键"></a>3.删除外键</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 从表 drop foreing key 外键名称;</span><br></pre></td></tr></table></figure><h3 id="4-级联删除"><a href="#4-级联删除" class="headerlink" title="4.级联删除"></a>4.级联删除</h3><p>如果主键表中的记录被删除,则外键表中该行数据也会被删除</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">on delete cascade</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 重新创建添加级联操作</span><br><span class="line">CREATE TABLE employee(</span><br><span class="line"> eid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line"> ename VARCHAR(20),</span><br><span class="line"> age INT,</span><br><span class="line"> dept_id INT,</span><br><span class="line"> CONSTRAINT emp_dept_fk FOREIGN KEY(dept_id) REFERENCES department(id)</span><br><span class="line"> -- 添加级联删除</span><br><span class="line"> ON DELETE CASCADE</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h1 id="五-事务"><a href="#五-事务" class="headerlink" title="五.事务"></a>五.事务</h1><h2 id="1-数据库事务"><a href="#1-数据库事务" class="headerlink" title="1.数据库事务"></a>1.数据库事务</h2><h3 id="1-事务"><a href="#1-事务" class="headerlink" title="1.事务"></a>1.事务</h3><h4 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1.什么是事务"></a>1.什么是事务</h4><p>事务是一个整体,由一条或多条sql语句组成,这些sql语句要么都执行成功,要么都执行失败,只要有一条出现异常,整个操作就会回滚,整个业务将执行失败,不会出现部分成功部分失败的情况.</p><p>在mysql中只有使用了InnDB数据库存储引擎才支持事务,事务用来管理inster,update,delete语句,事务处理可以用来维护数据库的完整性,保证成批的sql语句要么全部执行,要么全部不执行.</p><h4 id="2-什么是回滚"><a href="#2-什么是回滚" class="headerlink" title="2.什么是回滚"></a>2.什么是回滚</h4><p>即在事务运行的过程中发生某种故障,事务不能继续执行,系统将事务中对数据的所有已完成操作全部撤销,滚回到事务开始时的状态.</p><h2 id="2-MySQL事务操作"><a href="#2-MySQL事务操作" class="headerlink" title="2.MySQL事务操作"></a>2.MySQL事务操作</h2><p>MySQL中可以有两种方式进行事务的操作</p><ul><li>手动提交事务</li><li>自动提交事务</li></ul><h3 id="1-手动提交事务"><a href="#1-手动提交事务" class="headerlink" title="1.手动提交事务"></a>1.手动提交事务</h3><h4 id="1-语法格式"><a href="#1-语法格式" class="headerlink" title="1.语法格式"></a>1.语法格式</h4><table><thead><tr><th>功能</th><th>语句</th></tr></thead><tbody><tr><td>BEGIN&#x2F;START TRANSACTION</td><td>开启事务</td></tr><tr><td>COMMIT</td><td>提交事务</td></tr><tr><td>ROLLBACK</td><td>回滚事务</td></tr><tr><td>SAVEPOINT identifier</td><td>savepoint允许在事务中创建一个保存点,一个事务中可以有多个savepoint</td></tr><tr><td>RELEASE SAVEPOINT identifier</td><td>删除一个事务的保存点,当没有指定的保存点时,执行该语句会抛出一个异常</td></tr><tr><td>ROLLBACK TO identifier</td><td>把事务回滚到标记点</td></tr><tr><td>SET transaction</td><td>用来设置事务的隔离级别</td></tr></tbody></table><p>START TRANSACTION：这条语句⽤于显式地标记⼀个事务的起始点。</p><p>COMMIT：表示提交事务，即提交事务的所有操作，具体地说，就是将事务中所有对数据库的更新都写到磁盘上的物理数据库中，事务正常结束。</p><p>ROLLBACK：表示撤销事务，即在事务运⾏的过程中发⽣了某种故障，事务不能继续执⾏，系统将事务中对数据库的所有已完成的操作全部撤销，回滚到事务开始时的状态。</p><h4 id="2-手动提交事务流程"><a href="#2-手动提交事务流程" class="headerlink" title="2.手动提交事务流程"></a>2.手动提交事务流程</h4><p>执行成功的情况: 开启事务-&gt;执行多条SQL语句-&gt;成功提交事务</p><p>执行失败的情况: 开启事务-&gt;执行多条SQL语句-&gt;事务回滚</p><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230515142841588.png" alt="image-20230515142841588"></p><h4 id="3-成功案例演示"><a href="#3-成功案例演示" class="headerlink" title="3.成功案例演示"></a>3.成功案例演示</h4><p>需求:模拟张三给李四转账500元</p><p>1.执行以下SQL</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 使用db2数据库</span><br><span class="line">use db2;</span><br><span class="line">-- 开启事务</span><br><span class="line">start transaction;</span><br><span class="line">-- tom账户-500</span><br><span class="line">update account set money = money - 500 where name = &#x27;tom&#x27;;</span><br><span class="line">-- Jack账户+500</span><br><span class="line">update account set money = money +500 where name = &#x27;jack&#x27;;</span><br></pre></td></tr></table></figure><p>2.此时我们使用navicat 查看表,发现数据并没有改变</p><p>3.在控制台执行commit提交事务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure><p>4.再次使用navicat查看,数据在事务提交后发生改变</p><h4 id="4-回滚点演示"><a href="#4-回滚点演示" class="headerlink" title="4.回滚点演示"></a>4.回滚点演示</h4><p>1.保存回滚点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">update commit set money = money +1000 where id=2;</span><br><span class="line">savepoint p1;</span><br><span class="line">update account set money = money + 200 where id = 3;</span><br><span class="line">savepoint p2;</span><br><span class="line">update account set money = money +300 where id =5;</span><br></pre></td></tr></table></figure><p>2.回滚到指定的回滚点</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rollback to p2;</span><br></pre></td></tr></table></figure><p>3.提交事务,观察id为2的账户资金取值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit;</span><br></pre></td></tr></table></figure><h3 id="2-自动提交事务"><a href="#2-自动提交事务" class="headerlink" title="2.自动提交事务"></a>2.自动提交事务</h3><p>MySQL默认每一条DML语句都是一个单独的事务,每条语句都会自动开启一个事务,语句执行完毕自动提交事务,MySQL默认是自动提交事务的.</p><h4 id="1-自动提交事务"><a href="#1-自动提交事务" class="headerlink" title="1.自动提交事务"></a>1.自动提交事务</h4><p>1.将tom账户金额+500元</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update account set money = money +500 where name =&quot;tom&quot;;</span><br></pre></td></tr></table></figure><p>2.使用navicat查看数据库,发生数据已经改变</p><h4 id="2-取消自动提交"><a href="#2-取消自动提交" class="headerlink" title="2.取消自动提交"></a>2.取消自动提交</h4><p>MySQL默认是自动提交事务,看通过autocommit变量名设置事务的默认提交状态</p><p>autocommit变量名取值含义:</p><table><thead><tr><th>属性值</th><th>功能描述</th></tr></thead><tbody><tr><td>ON</td><td>自动提交</td></tr><tr><td>OFF</td><td>手动提交</td></tr></tbody></table><p>1.登录mysql,通过autocommit查看事务默认提交状态</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;autocommit&#x27;;</span><br></pre></td></tr></table></figure><p>2.autocommit改成OFF,即手动提交</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set @@autocommit = OFF;</span><br></pre></td></tr></table></figure><p>3.修改autocommit后,需要commit后才会更新数据</p><h2 id="3-事务的四大特征"><a href="#3-事务的四大特征" class="headerlink" title="3.事务的四大特征"></a>3.事务的四大特征</h2><table><thead><tr><th>特性</th><th>含义</th></tr></thead><tbody><tr><td>原子性</td><td>Atomicity,每个事务都是一个整体,不可拆分,事务中所有的SQL语句要么都执行成功,要么都失败</td></tr><tr><td>一致性</td><td>Consistency,事务在执行前数据库的状态与执行后数据库的状态保持一致,如:转账后两个账户要通知更新</td></tr><tr><td>隔离性</td><td>Isolation,数据库允许多个并发事务同时对其数据进行读写和修改的操作,隔离性可以防止多个事务并发执行时由于交叉执行而导致数据不一致</td></tr><tr><td>持久性</td><td>Durability,一旦事务执行成功,对数据库的修改是持久的.就算关机,数据也要保存下来</td></tr></tbody></table><h2 id="4-MySQL事务隔离级别"><a href="#4-MySQL事务隔离级别" class="headerlink" title="4.MySQL事务隔离级别"></a>4.MySQL事务隔离级别</h2><h3 id="1-数据的并发访问"><a href="#1-数据的并发访问" class="headerlink" title="1.数据的并发访问"></a>1.数据的并发访问</h3><p>一个数据库可能拥有多个访问客户端,这些客户端都可以并发的方式访问数据库,数据库的相同数据可能被多个事务同时访问如果不采取隔离措施,就会导致各种问题,破坏数据的完整性</p><h3 id="2-并发访问会产生的问题"><a href="#2-并发访问会产生的问题" class="headerlink" title="2.并发访问会产生的问题"></a>2.并发访问会产生的问题</h3><p>事务在操作时的理想状态,所有的事务之间保持隔离,互补影响.但是,因为并发操作,多个用户同时访问同一个数据,可能引发并发访问的问题.</p><table><thead><tr><th>并发访问问题</th><th>说明</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读取到另一个事务尚未提交的数据</td></tr><tr><td>不可重复读</td><td>一个事务中两次读取的数据内容不一致,要求的是在一个事务中多次读取时数据是一致的.这是进行update操作时引发的问题</td></tr><tr><td>幻读</td><td>一个事务中,某一次的select操作得到的结果所表征的数据状态,无法支撑后续的业务操作.查询得到的数据状态不准确,导致幻读.</td></tr></tbody></table><h3 id="3-四种隔离级别"><a href="#3-四种隔离级别" class="headerlink" title="3.四种隔离级别"></a>3.四种隔离级别</h3><p>通过设置隔离级别,可以防止上面的三种并发问题</p><p>MySQL数据库有四种隔离级别,上面的级别最低,下面的级别最高.</p><table><thead><tr><th>级别</th><th>名字</th><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>数据库的默认隔离界别</th></tr></thead><tbody><tr><td>1</td><td>读未提交</td><td>read uncommitted</td><td>✔</td><td>✔</td><td>✔</td><td></td></tr><tr><td>2</td><td>读已提交</td><td>read committed</td><td>✘</td><td>✔</td><td>✔</td><td>Oracle和SQL Server</td></tr><tr><td>3</td><td>可重复读</td><td>replacetable read</td><td>✘</td><td>✘</td><td>✔</td><td>MySQL</td></tr><tr><td>4</td><td>串行化</td><td>serializable</td><td>✘</td><td>✘</td><td>✘</td><td></td></tr></tbody></table><h3 id="4-隔离级别相关命令"><a href="#4-隔离级别相关命令" class="headerlink" title="4.隔离级别相关命令"></a>4.隔离级别相关命令</h3><p>1.查看隔离级别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure><blockquote><p>说明:MySQL的默认隔离级别是可重复读,可以防止脏读&#x2F;不可重复读,但不能防止幻读</p></blockquote><p>2.设置事务隔离级别.需要退出MySQL,再重新登录才能看到隔离界别的变化</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global transaction isolation level 事务隔离级别</span><br><span class="line"></span><br><span class="line">read uncommitted 读未提交</span><br><span class="line">read committed 读已提交</span><br><span class="line">replacetable read 可重复读</span><br><span class="line">serializable 串行化</span><br></pre></td></tr></table></figure><p>3.例如:修改隔离级别为读未提交</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global transaction isolation level read uncommitted;</span><br></pre></td></tr></table></figure><h2 id="5-隔离性问题演示"><a href="#5-隔离性问题演示" class="headerlink" title="5.隔离性问题演示"></a>5.隔离性问题演示</h2><h3 id="1-脏读演示"><a href="#1-脏读演示" class="headerlink" title="1.脏读演示"></a>1.脏读演示</h3><p>脏读:一个事务读取到了另一个事务中尚未提交的数据</p><h4 id="1-脏读问题演示"><a href="#1-脏读问题演示" class="headerlink" title="1.脏读问题演示"></a>1.脏读问题演示</h4><p>1.打开窗口登录mySQL,设置全局的隔离级别为最低.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 登录mysql数据库</span><br><span class="line"># 使用db2数据库</span><br><span class="line">use db2;</span><br><span class="line"># 设置隔离级别为最低,读未提交</span><br></pre></td></tr></table></figure><p>2.关闭窗口,开一个新的窗口A,再次查询隔离级别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 开启新的窗口A</span><br><span class="line"># 查询隔离级别</span><br><span class="line">select @tx_isolation; --已修改为读未提交,read-uncommited</span><br></pre></td></tr></table></figure><p>3.再开启一个新的窗口B</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 登录MySQL数据库</span><br><span class="line"># 选择数据库</span><br><span class="line">use db2;</span><br><span class="line"># 开启事务</span><br><span class="line">start transaction;</span><br><span class="line">#查询</span><br><span class="line">select * from account; </span><br></pre></td></tr></table></figure><p>4.窗口A执行sql语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 选择数据库</span><br><span class="line">use db;</span><br><span class="line">-- 开启事务</span><br><span class="line">start transaction;</span><br><span class="line">-- 执行修改操作</span><br><span class="line">update account set money -500 where name =&#x27;tom&#x27;;</span><br><span class="line">update account set money = money +500 where name =&#x27;jack&#x27;;</span><br></pre></td></tr></table></figure><p>5.窗口b查询数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from account</span><br></pre></td></tr></table></figure><p>6.窗口a转账异常,进行回滚</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rollback;</span><br></pre></td></tr></table></figure><p>7.窗口b再次查询账户</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from account;</span><br></pre></td></tr></table></figure><h4 id="2-解决脏读"><a href="#2-解决脏读" class="headerlink" title="2.解决脏读"></a>2.解决脏读</h4><p>脏读是非常危险的,比如张三向李四购买商品,张三开启事务,向李四账号转入500,然后打电话给李四说钱已经转了,李四一查询钱到账了,发货给张三,张三收到货后回滚事务,李四再查看钱没了</p><p>解决方案:将全局的隔离级别进行提示:read committed</p><p>1.在窗口a设置全局的隔离级别为read committed</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global transaction isolation level read commited;</span><br></pre></td></tr></table></figure><p>2.重新开启窗口a,查看设置是否成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@tx_isolation;</span><br></pre></td></tr></table></figure><p>3.开启窗口b,a和b窗口选择数据库后,都开启事务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 窗口a</span><br><span class="line">-- 1.选择数据库</span><br><span class="line">use db2;</span><br><span class="line">-- 2.开启事务</span><br><span class="line">start transaction;</span><br><span class="line"></span><br><span class="line">#窗口b;</span><br><span class="line">-- 1.选择数据库</span><br><span class="line">use db2;</span><br><span class="line">-- 2.开启事务</span><br><span class="line">start transaction;</span><br></pre></td></tr></table></figure><p>4.窗口a只更新两个人的数据库,不提交事务.</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update account set money = money-500 where name =&#x27;tom&#x27;;</span><br><span class="line">update account set money = money+500 where name =&#x27;jack&#x27;;</span><br></pre></td></tr></table></figure><p>5.窗口b进行查询,没有查询到结果</p><p>6.窗口a通过commit提交事务</p><p>7.窗口b可以查到数据</p><h3 id="2-不可重复读"><a href="#2-不可重复读" class="headerlink" title="2.不可重复读"></a>2.不可重复读</h3><p>不可重复读:同一事务中,进行查询操作,但是每一次读取的内容不一样</p><h4 id="1-不可重复读演示"><a href="#1-不可重复读演示" class="headerlink" title="1.不可重复读演示"></a>1.不可重复读演示</h4><p>1.恢复数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update account set money = 1000;</span><br></pre></td></tr></table></figure><p>2.打开窗口a和窗口b,分别进行选择数据库后并开启事务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use db2;</span><br><span class="line">start transaction;</span><br><span class="line">use db2;</span><br><span class="line">start transaction;</span><br></pre></td></tr></table></figure><p>3.窗口b开启事务后,先进行一次数据查询</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from account</span><br></pre></td></tr></table></figure><p>4.在窗口a开启事务后,将tom的账户+500,然后提交事务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update account set money = money + 500 where name= &#x27;tom&#x27;;</span><br></pre></td></tr></table></figure><p>5.窗口b再次查询数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from account;</span><br></pre></td></tr></table></figure><p>6.两次查询输出的结果不同，到底哪次是对的？</p><p>不知道以哪次为准。很多⼈认为这种情况就对了；⽆须困惑，当然是后⾯的为准。 我们可以考虑这样⼀种情况：⽐如银⾏程序需要将查询结果分别输出到电脑屏幕和发短信给客户，结果在⼀个事务中针对不同的输出⽬的地进⾏的两次查询不⼀致，即导致⽂件和屏幕中的结果不⼀致，银⾏⼯作⼈员就不知道以哪个为准了.</p><h4 id="2-解决不可重复读的问题"><a href="#2-解决不可重复读的问题" class="headerlink" title="2.解决不可重复读的问题"></a>2.解决不可重复读的问题</h4><p>将全局隔离级别提升为 repeatable read</p><p>1.恢复数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE account SET money = 1000;</span><br></pre></td></tr></table></figure><p>2.打开窗⼝A，设置隔离级别为：repeatable read。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查看隔离级别</span><br><span class="line">select @@tx_isolation;</span><br><span class="line"></span><br><span class="line">--设置事务的隔离级别</span><br><span class="line">set global transaction isolaction level repeatable read;</span><br></pre></td></tr></table></figure><p>3.重新开启A、B窗⼝，选择数据库，同时开启事务。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 窗⼝A</span><br><span class="line">use db2;</span><br><span class="line">start transaction;</span><br><span class="line"># 窗⼝B</span><br><span class="line">use db2;</span><br><span class="line">start transaction;</span><br></pre></td></tr></table></figure><p>4.窗⼝B事务先进⾏第⼀次查询。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 窗⼝B的事务第⼀次查询结果（tom账户⾦额为1000、jack账户⾦额为1000）</span><br><span class="line">select * from account;</span><br></pre></td></tr></table></figure><p>5.窗⼝A更新数据，然后提交事务。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 修改数据</span><br><span class="line">update account set money = money + 500 where name = &#x27;tom&#x27;;</span><br><span class="line">-- 提交事务</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>6.窗⼝B再次查询数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> # 窗⼝B的事务第⼆次查询结果（tom账户⾦额为1000、jack账户⾦额为1000）</span><br><span class="line">select * from account; -- 窗⼝B再次查询，数据跟上次保持⼀致，没有出现不可重复读问题</span><br></pre></td></tr></table></figure><p>同⼀个事务中为了保证多次查询数据⼀致，必须使⽤repeatable read隔离级别。MySQL的默认隔离级别就是repeatable read。</p><h3 id="3-幻读演示"><a href="#3-幻读演示" class="headerlink" title="3.幻读演示"></a>3.幻读演示</h3><p>幻读：SELECT查询某条记录是否存在，不存在，则准备插⼊此条记录；但执⾏INSERT插⼊时，发现此条记录已经存在，⽆法插⼊，此时就发⽣了幻读</p><h4 id="1-幻读问题演示"><a href="#1-幻读问题演示" class="headerlink" title="1.幻读问题演示"></a>1.幻读问题演示</h4><p>1.打开A、B窗⼝，选择数据库并开启事务。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 窗⼝A</span><br><span class="line">use db2;</span><br><span class="line">start transaction;</span><br><span class="line"># 窗⼝B</span><br><span class="line">use db2;</span><br><span class="line">start transaction;</span><br></pre></td></tr></table></figure><p>2.窗⼝A先执⾏⼀次查询操作。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 假设要再添加⼀条id为3的数据，在添加之前先判断是否存在</span><br><span class="line">select * from account where id = 3; -- 查询结果为：不存在此条记录，则表示可以插⼊</span><br></pre></td></tr></table></figure><p>3.窗⼝B插⼊⼀条数据，然后提交事务。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 窗⼝B插⼊⼀条，主键id为3的数据</span><br><span class="line">INSERT INTO account VALUES(3, &#x27;lucy&#x27;, 1000);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>4.窗⼝A执⾏插⼊操作，发现报错，出现幻读。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO account VALUES(3, &#x27;lucy&#x27;, 1000);</span><br></pre></td></tr></table></figure><h4 id="2-解决幻读问题"><a href="#2-解决幻读问题" class="headerlink" title="2.解决幻读问题"></a>2.解决幻读问题</h4><p>将事务隔离级别设置到最⾼SERIALIZABLE ，以挡住幻读的发⽣。</p><p>如果⼀个事务使⽤了SERIALIZABLE——可串⾏化隔离级别时，在这个事务没有被提交之前 , 其他的线程，只能等到当前操作完成之后，才能进⾏操作，这样会⾮常耗时，⽽且影响数据库的性能，数据库不会使⽤这种隔离级别。</p><p>1.恢复数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE FROM account WHERE id = 3;</span><br><span class="line">UPDATE account SET money = 1000;</span><br></pre></td></tr></table></figure><p>2.打开窗⼝A将数据隔离级别提升到最⾼。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global transaction isolation level SERIALIZABLE;</span><br></pre></td></tr></table></figure><p>3.打开A、B窗⼝，选择数据库并开启事务。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 窗⼝A</span><br><span class="line">use db2;</span><br><span class="line">start transaction;</span><br><span class="line"># 窗⼝B</span><br><span class="line">use db2;</span><br><span class="line">start transaction;</span><br></pre></td></tr></table></figure><p>4.窗⼝A先执⾏⼀次查询操作。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM account WHERE id = 3;</span><br></pre></td></tr></table></figure><p>5.窗⼝B插⼊⼀条数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 这条操作⽆法进⾏，光标⼀直在闪烁</span><br><span class="line">INSERT INTO account VALUES(3, &#x27;lucy&#x27;, 1000);</span><br></pre></td></tr></table></figure><p>6.窗⼝A执⾏插⼊操作，提交事务数据插⼊成功。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 窗⼝A数据插⼊成功，没有出现幻读</span><br><span class="line">INSERT INTO account VALUES(3, &#x27;lucy&#x27;, 1000);</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure><p>7.窗⼝B在窗⼝A提交事务之后，再执⾏，但是主键冲突出现错误。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ERROR 1062 (23000): Duplicate entry &#x27;3&#x27; for key &#x27;PRIMARY&#x27;</span><br></pre></td></tr></table></figure><p>总结：serializable串⾏化可以彻底解决幻读，但是事务只能排队执⾏，严重影响效率，数据库不会使⽤这种隔离级别。</p><h1 id="六-索引"><a href="#六-索引" class="headerlink" title="六.索引"></a>六.索引</h1><h2 id="1-mysql索引"><a href="#1-mysql索引" class="headerlink" title="1.mysql索引"></a>1.mysql索引</h2><h3 id="1-什么是索引"><a href="#1-什么是索引" class="headerlink" title="1.什么是索引"></a>1.什么是索引</h3><p>索引是数据库中为提⾼查询效率（检索速度）的技术，数据量越⼤索引效果越明显。拿汉语字典的⽬录⻚（索引）打⽐⽅，我们可以按拼⾳、笔画、偏旁部⾸等排序的⽬录（索引）快速查找到需要的字。索引类似于⽬录。</p><p>数据库中的数据会零散的保存在磁盘中的每个磁盘块中，如果不使⽤索引，查找数据只能挨个遍历每⼀个磁盘块进⾏查找；如果使⽤了索引，磁盘块会以树桩结构进⾏保存，查找数据时⼤⼤降低了磁盘块的访问量，从⽽达到了提⾼查询效率的⽬的。如果合理的设计且使⽤索引的MySQL看作是⼀辆兰博基尼的话，那么没有设计和使⽤索引的MySQL就是⼀个⼈⼒三轮⻋。</p><h3 id="2-索引分类"><a href="#2-索引分类" class="headerlink" title="2.索引分类"></a>2.索引分类</h3><p>分类方式1</p><table><thead><tr><th>索引名称</th><th>说明</th></tr></thead><tbody><tr><td>唯一索引(unique)</td><td>唯一索引指的是索引列的所有值都只能出现一次,必须唯一</td></tr><tr><td>主键索引(primary key)</td><td>主键是一种唯一索引,每个表只能有一个主键,用于标识数据表中的每一条记录</td></tr><tr><td>普通索引(index)</td><td>最常见的索引,作用就是加快数据的访问速度</td></tr></tbody></table><p>分类方式2</p><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230515195114914.png" alt="image-20230515195114914"></p><h5 id="显示所有"><a href="#显示所有" class="headerlink" title="显示所有"></a>显示所有</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show index from table_name;</span><br></pre></td></tr></table></figure><h3 id="3-索引存储结构"><a href="#3-索引存储结构" class="headerlink" title="3.索引存储结构"></a>3.索引存储结构</h3><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230515195337008.png" alt="image-20230515195337008"></p><h2 id="2-普通索引"><a href="#2-普通索引" class="headerlink" title="2.普通索引"></a>2.普通索引</h2><p>普通索引（由关键字key或index定义的索引）的唯一任务就是加快对数据的访问速度，因此，应该只为那些最经常出现的查询条件和排序条件中的数据创建索引</p><h3 id="1-语法格式-1"><a href="#1-语法格式-1" class="headerlink" title="1.语法格式"></a>1.语法格式</h3><h4 id="（1）创建表的时候添加索引"><a href="#（1）创建表的时候添加索引" class="headerlink" title="（1）创建表的时候添加索引"></a>（1）创建表的时候添加索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">creat table(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">index 索引名(字段名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="2-使用create-index语句创建-即在已有表上创建索引"><a href="#2-使用create-index语句创建-即在已有表上创建索引" class="headerlink" title="(2)使用create index语句创建,即在已有表上创建索引"></a>(2)使用create index语句创建,即在已有表上创建索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index 索引名 on 表名(字段名);</span><br></pre></td></tr></table></figure><h4 id="3-修改表结构添加普通索引"><a href="#3-修改表结构添加普通索引" class="headerlink" title="(3) 修改表结构添加普通索引"></a>(3) 修改表结构添加普通索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 add index 索引名(字段名);</span><br></pre></td></tr></table></figure><h3 id="2-案例演示"><a href="#2-案例演示" class="headerlink" title="2.案例演示"></a>2.案例演示</h3><p>(1).创建数据库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database db4 character utf8;</span><br></pre></td></tr></table></figure><p>(2).创建表添加普通索引</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table student(</span><br><span class="line">id int primary key auto_increing,</span><br><span class="line">name varchar,</span><br><span class="line">sex varchar,</span><br><span class="line">    address varcher</span><br><span class="line">index index_name(name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(3).使用create index对student的sex添加索引</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table index_sex on student(sex);</span><br></pre></td></tr></table></figure><p>(4).修改表结构给address字段添加普通索引</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter  table student add index index_adress(address);</span><br></pre></td></tr></table></figure><h2 id="3-主键索引"><a href="#3-主键索引" class="headerlink" title="3.主键索引"></a>3.主键索引</h2><p>特点:主键是一种唯一性索引,每个表只能有一个主键,用于标识数据表中的某一天记录,一个表可以没有主键,但最多只能有一个主键,并且主键值不能包含null.</p><h3 id="1-语法格式-2"><a href="#1-语法格式-2" class="headerlink" title="1.语法格式"></a>1.语法格式</h3><h4 id="1-创建表的时候直接添加主键索引"><a href="#1-创建表的时候直接添加主键索引" class="headerlink" title="(1).创建表的时候直接添加主键索引"></a>(1).创建表的时候直接添加主键索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">字段名 字段类型 primary key,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="2-修改表结构-添加主键索引"><a href="#2-修改表结构-添加主键索引" class="headerlink" title="(2).修改表结构,添加主键索引"></a>(2).修改表结构,添加主键索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 add primary key (字段名);</span><br></pre></td></tr></table></figure><h3 id="2-案例演示-1"><a href="#2-案例演示-1" class="headerlink" title="2.案例演示"></a>2.案例演示</h3><p>(1) 创建pk_index_tab表</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE pk_index_tab (</span><br><span class="line"> did INT,</span><br><span class="line"> name VARCHAR(20),</span><br><span class="line"> hobby VARCHAR(30),</span><br><span class="line"> address VARCHAR(30)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(2).为pk_index_tab表添加主键索引。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE pk_index_tab ADD PRIMARY KEY (did);</span><br></pre></td></tr></table></figure><h2 id="4-唯一索引"><a href="#4-唯一索引" class="headerlink" title="4.唯一索引"></a>4.唯一索引</h2><p>索引列的所有值都只能出现一次,必须唯一,所在的列允许空值.如果是组合索引,则列值的组合必须唯一.</p><p>唯一索引可以保证数据记录的唯一性,事实上,在许多场合,人们创建唯一索引的目的往往不是为了提高访问速度,而是为了避免数据重复出现.</p><h3 id="1-语法格式-3"><a href="#1-语法格式-3" class="headerlink" title="1.语法格式"></a>1.语法格式</h3><h4 id="1-创建表时添加唯一索引"><a href="#1-创建表时添加唯一索引" class="headerlink" title="(1)创建表时添加唯一索引"></a>(1)创建表时添加唯一索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">字段名 字段类型,</span><br><span class="line">unique index 索引名(字段名)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="2-使用create在已有表上添加索引"><a href="#2-使用create在已有表上添加索引" class="headerlink" title="(2)使用create在已有表上添加索引"></a>(2)使用create在已有表上添加索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create unique index 索引名 on 表名(字段名);</span><br></pre></td></tr></table></figure><h4 id="3-修改表结构添加索引"><a href="#3-修改表结构添加索引" class="headerlink" title="(3).修改表结构添加索引"></a>(3).修改表结构添加索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 add unique index 索引名(字段名);</span><br></pre></td></tr></table></figure><h3 id="2-案例演示-2"><a href="#2-案例演示-2" class="headerlink" title="2.案例演示"></a>2.案例演示</h3><p>(1) 案例：创建un_index_tab表的时候直接添加唯⼀索引。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE un_index_tab (</span><br><span class="line"> did INT,</span><br><span class="line"> name VARCHAR(20),</span><br><span class="line"> hobby VARCHAR(30),</span><br><span class="line"> address VARCHAR(30),</span><br><span class="line"> UNIQUE INDEX index_name (name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>(2) 案例：为hobby字段添加唯⼀索引。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE UNIQUE INDEX index_hobby ON un_index_tab (hobby);</span><br></pre></td></tr></table></figure><p>(3) 案例：为address字段添加唯⼀索引。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE un_index_tab ADD UNIQUE INDEX index_address (address);</span><br></pre></td></tr></table></figure><p>(4) 案例：向表中插⼊违反唯⼀索引的数据，观察⽇志输出信息。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 唯⼀索引保证了数据的唯⼀性，索引的效率也提升了</span><br><span class="line">INSERT INTO un_index_tab VALUES (1, &#x27;张三&#x27;, &#x27;编程&#x27;, &#x27;⻄安&#x27;);</span><br><span class="line"># 报错Duplicate entry &#x27;张三&#x27; for key &#x27;index_name&#x27;</span><br><span class="line">INSERT INTO un_index_tab VALUES (2, &#x27;张三&#x27;, &#x27;游戏&#x27;, &#x27;⻓沙&#x27;);</span><br></pre></td></tr></table></figure><h2 id="5-删除索引"><a href="#5-删除索引" class="headerlink" title="5.删除索引"></a>5.删除索引</h2><p>由于索引会占用一定的磁盘空间,因此为了避免印象数据库的性能,应该及时删除不再使用索引.</p><h3 id="1-语法格式-4"><a href="#1-语法格式-4" class="headerlink" title="1.语法格式"></a>1.语法格式</h3><h4 id="1-删除普通索引-x2F-唯一索引"><a href="#1-删除普通索引-x2F-唯一索引" class="headerlink" title="(1)删除普通索引&#x2F;唯一索引"></a>(1)删除普通索引&#x2F;唯一索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table 表名 drop index 索引名;</span><br></pre></td></tr></table></figure><h4 id="2-删除主键索引"><a href="#2-删除主键索引" class="headerlink" title="(2)删除主键索引"></a>(2)删除主键索引</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.如果主键是非自增类型,则直接删除主键索引</span><br><span class="line">alter table 表名 drop primary key;</span><br><span class="line"># 2.如果主键是自增类型,则需要先取消主键自增,然后删除主键索引</span><br><span class="line">alter table 表名 modify 主键字段名 字段类型;</span><br><span class="line">--删除主键索引</span><br><span class="line">alter table 表名 drop primary key;</span><br></pre></td></tr></table></figure><h3 id="2-案例演示-3"><a href="#2-案例演示-3" class="headerlink" title="2.案例演示"></a>2.案例演示</h3><p>1.案例：通过修改表的定义，删除普通索引和唯⼀索引。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除nor_index_tab表中名为index_hobby的普通索引</span><br><span class="line">ALTER TABLE nor_index_tab DROP INDEX index_hobby;</span><br><span class="line"># 删除un_index_tab表中名为index_address的唯⼀索引</span><br><span class="line">ALTER TABLE un_index_tab DROP INDEX index_address;</span><br></pre></td></tr></table></figure><p>2.案例：删除pk_index_tab表的主键索引。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ⽅式1：如果pk_index_tab表的主键是⾮⾃增类型，则直接删除主键索引</span><br><span class="line">ALTER TABLE pk_index_tab DROP PRIMARY KEY;</span><br><span class="line"># ⽅式2：如果pk_index_tab表的主键是⾃增类型，则先取消⾃增，然后再删除主键索引</span><br><span class="line">ALTER TABLE pk_index_tab MODIFY did int;</span><br><span class="line">ALTER TABLE pk_index_tab DROP PRIMARY KEY;</span><br></pre></td></tr></table></figure><h2 id="6-索引的优缺点"><a href="#6-索引的优缺点" class="headerlink" title="6.索引的优缺点"></a>6.索引的优缺点</h2><h3 id="1-索引的优点"><a href="#1-索引的优点" class="headerlink" title="1.索引的优点"></a>1.索引的优点</h3><ul><li>大大提高了查询速度</li><li>可以显著的减少查询中分组和排序的时间</li></ul><h3 id="2-索引的缺点"><a href="#2-索引的缺点" class="headerlink" title="2.索引的缺点"></a>2.索引的缺点</h3><ul><li>创建索引和维护索引需要时间,而且数据量越大时间越长</li><li>当对表中的数据进行增加,删除,修改的时候,索引也要同时进行维护,降低了数据的维护速度,因为更新表时,mysql不仅要保存数据,还要保存索引.</li></ul><h3 id="3-有索引就⼀定好吗？"><a href="#3-有索引就⼀定好吗？" class="headerlink" title="3.有索引就⼀定好吗？"></a>3.有索引就⼀定好吗？</h3><p>不是，如果数据量⽐较⼩的话使⽤索引反⽽会降低查询效率，只有数据量⽐较⼤时才使⽤索引。</p><h3 id="4-索引是越多越好吗？"><a href="#4-索引是越多越好吗？" class="headerlink" title="4.索引是越多越好吗？"></a>4.索引是越多越好吗？</h3><p>不是，因为建⽴索引会占⽤磁盘空间的索引⽂件，只针对查询数据时频繁使⽤的字段创建索引。</p><h1 id="七-视图"><a href="#七-视图" class="headerlink" title="七.视图"></a>七.视图</h1><h2 id="1-什么是视图"><a href="#1-什么是视图" class="headerlink" title="1.什么是视图"></a>1.什么是视图</h2><ol><li>视图是一种虚拟表</li><li>视图是建立在已有表的基础上,视图赖以建立的表称为基表</li><li>向视图提供数据内容的语句为select语句,可以将视图理解为存储起来的select语句</li><li>视图向用户提供基表数据的另一种表现形式</li></ol><h2 id="2-视图的作用"><a href="#2-视图的作用" class="headerlink" title="2.视图的作用"></a>2.视图的作用</h2><p>1.权限控制时可以使用;</p><ul><li>​例如，某⼏个列可以运⾏⽤户查询，其他列不允许，可以开通视图查询特定的列，起到权限控制的作⽤。</li></ul><p>2.简化复杂的多表查询.</p><ul><li><p>视图本身就是⼀条SQL查询语句，我们可以将⼀次复杂的查询构建成⼀张视图，⽤户只要查询视图就可以获取想要得到的信息（不需要再编写复杂的SQL语句）。</p></li><li><p>视图主要就是为了简化多表的查询。</p></li></ul><h2 id="3-视图的使用"><a href="#3-视图的使用" class="headerlink" title="3.视图的使用"></a>3.视图的使用</h2><h3 id="1-创建视图"><a href="#1-创建视图" class="headerlink" title="1.创建视图"></a>1.创建视图</h3><h4 id="1-语法格式-5"><a href="#1-语法格式-5" class="headerlink" title="1.语法格式:"></a>1.语法格式:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create view 视图名 as select语句;</span><br></pre></td></tr></table></figure><p>语法解析</p><ul><li>create view:表示创建视图</li><li>column_list:可选参数,表示字段清单,指定视图中各个字段的名称,默认情况下与select语句中查询的字段名称相同</li><li>as 表示视图要执行的操作</li><li>select语句:向视图提供数据内容</li></ul><h4 id="2-视图分类"><a href="#2-视图分类" class="headerlink" title="2.视图分类"></a>2.视图分类</h4><p>1.简单视图：创建视图的⼦查询SQL语句中不包含，去重、聚合函数、分组查询、关联查询的视图称为简单视图。可以对简单视图中的数据进⾏增删改查操作。</p><p>2.复杂视图：与简单视图相反。只能对复杂视图中的数据进⾏查询操作。</p><h4 id="3-案例演示"><a href="#3-案例演示" class="headerlink" title="3.案例演示"></a>3.案例演示</h4><p>1.创建一张视图</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.先编写查询语句</span><br><span class="line"># 查询所有商品和商品的对应分类情况</span><br><span class="line">select * from products p left join categroy c on p.category_id = c.cid; </span><br><span class="line"># 2.基于上面的查询语句,创建一张视图</span><br><span class="line">create view 视图名 as select * from products p left join categroy c on p.category_id = c.cid; </span><br></pre></td></tr></table></figure><p>2.创建一个显示每个部门平均工资,最高工资,最低工资的复杂视图</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create view 视图名 as (select dept_name,avg(salary),min(salary))from emp group by dept_name ;</span><br></pre></td></tr></table></figure><h3 id="2-视图查询语句"><a href="#2-视图查询语句" class="headerlink" title="2.视图查询语句"></a>2.视图查询语句</h3><h4 id="1-视图查询语句"><a href="#1-视图查询语句" class="headerlink" title="1.视图查询语句"></a>1.视图查询语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 字段名 from 视图名;</span><br></pre></td></tr></table></figure><h4 id="2-视图案例查询"><a href="#2-视图案例查询" class="headerlink" title="2.视图案例查询"></a>2.视图案例查询</h4><p>需求:查询各个分类下的商品平均价格</p><p>(1).通过多表连接查询各个分类下的商品平均价格</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select cname as &#x27;分类名称&#x27;,avg(p.price) as &#x27;平均价格&#x27;</span><br><span class="line">from products p left join category c on p.category_id = c.id group by c.name</span><br></pre></td></tr></table></figure><p>(2).通过视图查询各个分类下的商品平均价格</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select cname,avg(price) from 视图名 group by cname;</span><br></pre></td></tr></table></figure><p>需求:查询鞋服分类下最贵的商品的全部信息</p><p>(1).通过多表连接查询鞋服分类下最贵的商品的全部信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 先求出鞋服类下最高商品价格</span><br><span class="line">select max(price)from products left join category on category_id = cid where cname = &#x27;鞋服&#x27;;</span><br><span class="line"></span><br><span class="line">#将上面的查询作为条件使用</span><br><span class="line">select * from products left join category on category_id = cid where cname = &#x27;鞋服&#x27; and price =(select max(price)from products left join category on category_id = cid where cname = &#x27;鞋服&#x27;;);</span><br></pre></td></tr></table></figure><p>(2).通过视图查询鞋服分类下最贵的商品的全部信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from products_category_view pcv</span><br><span class="line">where pcv.name =&#x27;鞋服&#x27; and pcv.price = (SELECT MAX(price) FROM products_category_view WHERE cname = &#x27;鞋服&#x27;);</span><br></pre></td></tr></table></figure><h3 id="3-视图增删改语句"><a href="#3-视图增删改语句" class="headerlink" title="3.视图增删改语句"></a>3.视图增删改语句</h3><p>对视图数据进行增删改查的操作方式与table的操作是一样的</p><h4 id="1-向视图中插入数据"><a href="#1-向视图中插入数据" class="headerlink" title="1.向视图中插入数据"></a>1.向视图中插入数据</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create view emp_view as(select * from emp where dept_name =&#x27;财务部&#x27; );</span><br><span class="line"></span><br><span class="line">insert into emp_view values(12,&#x27;如来&#x27;,&#x27;男&#x27;,200,&#x27;1580-5-4&#x27;,&#x27;财务部&#x27;);</span><br></pre></td></tr></table></figure><p>2.如果向视图中插入一条视图中不可见但是原表可见的数据称为数据污染,如何禁止出现数据污染的情况;在创建视图是使用with check option关键字</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create view emp_view as (select * from emp) with check option;</span><br><span class="line"></span><br><span class="line">insert into emp_view values (13,&#x27;张催化&#x27;,&#x27;女&#x27;,2000,&#x27;2022-02-04&#x27;,&#x27;市场部&#x27;);</span><br></pre></td></tr></table></figure><p>3.对视图中的数据进行删除和修改时,只能对视图中存在的数据进行相应的操作</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from emp_view where eid = 1; </span><br></pre></td></tr></table></figure><p>4.创建或替换视图</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create or replace view emp_view as (select *from emp where dept_name = &#x27;教学部&#x27;);</span><br></pre></td></tr></table></figure><p>5.删除视图</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop view emp_view</span><br></pre></td></tr></table></figure><p>6.视图别名: 如果创建视图的子查询sql语句中使用了别名,则对视图进行操作时也只能使用别名</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create view emp_view_03 as(celect eid,ename name,sex from emp where dept_name=&#x27;财务部&#x27;);</span><br></pre></td></tr></table></figure><h2 id="4-视图与表的区别"><a href="#4-视图与表的区别" class="headerlink" title="4.视图与表的区别"></a>4.视图与表的区别</h2><p>1.视图是建立在表的基础上,表存储数据库中的数据,二属兔知识做一个数据的展示</p><p>2.通过视图不能改变表中的数据(一般情况下视图中的数据都是表中的列经过计算得到的结果,不允许更新)</p><p>3.删除视图,表不受影响,.删除表,视图不起作用</p><h1 id="八-MySQL存储过程"><a href="#八-MySQL存储过程" class="headerlink" title="八.MySQL存储过程"></a>八.MySQL存储过程</h1><h2 id="1-什么是存储过程"><a href="#1-什么是存储过程" class="headerlink" title="1.什么是存储过程"></a>1.什么是存储过程</h2><p>MySQL5.0版本开始支持存储过程</p><p>存储过程是一种在数据库中存储复杂程序,以便外部程序调用的一种数据库对象,存储过程是为了完成特定功能的SQL语句集,经编译并保存在数据库中,用户可已通过指定存储过程的名字并给定参数来调用执行</p><p>简单理解,存储过程其实就是一堆sql语句的合并,中间加入了一些逻辑控制</p><h2 id="2-存储过程的优缺点"><a href="#2-存储过程的优缺点" class="headerlink" title="2.存储过程的优缺点"></a>2.存储过程的优缺点</h2><h3 id="1-优点"><a href="#1-优点" class="headerlink" title="1.优点"></a>1.优点</h3><p>存储过程一旦调试完成后,就可以稳定运行;存储过程减少业务系统与数据库的交互,降低耦合,数据库交互更加快捷</p><h3 id="2-缺点"><a href="#2-缺点" class="headerlink" title="2.缺点"></a>2.缺点</h3><p>1.在互联网行业中,大量使用MySQL,MySQL的存储过程与Oracle的相比较弱,所以较少使用,并且互联网需求变化比较快也是原因之一</p><p>2.尽量在简单的逻辑中使用,存储过程移植十分困难,数据库集群环境</p><p>,保证各个库之间存储过程变更一致也十分困难</p><p>3.阿里代码规范里提出了禁止使用存储过程,存储过程维护麻烦</p><h2 id="3-存储过程的创建方式"><a href="#3-存储过程的创建方式" class="headerlink" title="3.存储过程的创建方式"></a>3.存储过程的创建方式</h2><h3 id="1-创建⽆参存储过程"><a href="#1-创建⽆参存储过程" class="headerlink" title="1.创建⽆参存储过程"></a>1.<strong>创建⽆参存储过程</strong></h3><h4 id="1-语法格式-6"><a href="#1-语法格式-6" class="headerlink" title="1.语法格式"></a>1.语法格式</h4><p>创建简单的存储过程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $$ -- 声明语句结束符，可以⾃定义，⼀般使⽤$$</span><br><span class="line">CREATE PROCEDURE 存储过程名() -- 声明存储过程</span><br><span class="line">BEGIN -- 开始编写存储过程</span><br><span class="line"> -- 要执⾏的操作</span><br><span class="line">END $$ -- 存储过程结束</span><br></pre></td></tr></table></figure><p>调⽤⽆参存储过程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL 存储过程名;</span><br><span class="line"># 或</span><br><span class="line">CALL 存储过程名();</span><br></pre></td></tr></table></figure><h4 id="2-案例演示-4"><a href="#2-案例演示-4" class="headerlink" title="2.案例演示"></a>2.案例演示</h4><p>1.数据准备：创建商品表与订单表，并向商品表中添加数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 商品表</span><br><span class="line">CREATE TABLE goods (</span><br><span class="line"> gid INT,</span><br><span class="line"> name VARCHAR(20),</span><br><span class="line"> num INT -- 库存</span><br><span class="line">);</span><br><span class="line"># 订单表</span><br><span class="line">CREATE TABLE orders (</span><br><span class="line"> oid INT,</span><br><span class="line"> gid INT,</span><br><span class="line"> price INT -- 订单价格</span><br><span class="line">);</span><br><span class="line"># 向商品表中添加3条数据</span><br><span class="line">INSERT INTO goods VALUES(1, &#x27;奶茶&#x27;, 20);</span><br><span class="line">INSERT INTO goods VALUES(2, &#x27;绿茶&#x27;, 100);</span><br><span class="line">INSERT INTO goods VALUES(3, &#x27;花茶&#x27;, 25);</span><br></pre></td></tr></table></figure><p>2.需求：编写存储过程，查询所有商品数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE goods_proc()</span><br><span class="line">BEGIN</span><br><span class="line"> SELECT * FROM goods;</span><br><span class="line">END $$</span><br></pre></td></tr></table></figure><p>3.调⽤存储过程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 调⽤存储过程 查询goods表所有数据</span><br><span class="line">CALL goods_proc;</span><br><span class="line">-- 或</span><br><span class="line">CALL goods_proc();</span><br></pre></td></tr></table></figure><h3 id="2-创建输⼊参数存储过程"><a href="#2-创建输⼊参数存储过程" class="headerlink" title="2.创建输⼊参数存储过程"></a>2.<strong>创建输⼊参数存储过程</strong></h3><h4 id="1-语法格式-7"><a href="#1-语法格式-7" class="headerlink" title="1.语法格式"></a><strong>1.语法格式</strong></h4><p>1.IN输⼊参数：表示调⽤者向存储过程传⼊值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE 存储过程名(IN 参数名 参数类型)</span><br><span class="line">BEGIN</span><br><span class="line"> -- 要执⾏的操作</span><br><span class="line">END $$</span><br></pre></td></tr></table></figure><p>2.调⽤有参存储过程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL 存储过程名(参数值);</span><br></pre></td></tr></table></figure><h4 id="2-案例演示-5"><a href="#2-案例演示-5" class="headerlink" title="2.案例演示**"></a>2.案例演示**</h4><p>1.需求：创建⼀个存储过程，能够接收⼀个商品id，并根据id删除商品数据</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE goods_proc02(IN goods_id INT)</span><br><span class="line">BEGIN</span><br><span class="line"> DELETE FROM goods WHERE gid = goods_id;</span><br><span class="line">END $$</span><br></pre></td></tr></table></figure><p>2.调⽤存储过程传递参数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 删除id为2的商品</span><br><span class="line">CALL goods_proc02(3);</span><br></pre></td></tr></table></figure><h3 id="3-创建输出参数存储过程"><a href="#3-创建输出参数存储过程" class="headerlink" title="3.创建输出参数存储过程**"></a>3.创建输出参数存储过程**</h3><h4 id="1-语法格式-8"><a href="#1-语法格式-8" class="headerlink" title="1.语法格式"></a><strong>1.语法格式</strong></h4><p>1.变量赋值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @变量名 = 值;</span><br></pre></td></tr></table></figure><p>2.OUT输出参数：表示存储过程向调⽤者传出值</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUT 变量名 数据类型</span><br></pre></td></tr></table></figure><p>3.创建带有输出参数存储过程语法格式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE 存储过程名(IN 参数名 参数类型, ..., OUT 变量名 数据类型)</span><br><span class="line">BEGIN</span><br><span class="line"> -- 要执⾏的操作</span><br><span class="line"> -- 设置变量的值</span><br><span class="line"> SET @变量名 = 值;</span><br><span class="line"> -- 返回变量名的值</span><br><span class="line"> SELECT @变量名;</span><br><span class="line">END $$</span><br></pre></td></tr></table></figure><p>4.调⽤带有输出参数值的存储过程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL 存储过程名(参数值1, ..., @变量名);</span><br></pre></td></tr></table></figure><h4 id="2-案例演示-6"><a href="#2-案例演示-6" class="headerlink" title="2.案例演示"></a>2.案例演示</h4><p>1.需求：向订单表插⼊⼀条数据，如果返回值为1，则表示插⼊成功</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建存储过程，接收参数插⼊数据，并返回受影响的⾏数</span><br><span class="line">DELIMITER $$</span><br><span class="line">CREATE PROCEDURE orders_proc(IN o_oid INT, IN o_gid INT, IN o_price INT, OUT out_num</span><br><span class="line">INT)</span><br><span class="line">BEGIN</span><br><span class="line"> -- 执⾏插⼊操作</span><br><span class="line"> INSERT INTO orders VALUES (o_oid, o_gid, o_price);</span><br><span class="line"> -- 设置num的值为1</span><br><span class="line"> SET @out_num = 1;</span><br><span class="line"> -- 返回out_num的值</span><br><span class="line"> SELECT @out_num;</span><br><span class="line">END $$</span><br></pre></td></tr></table></figure><p>2.调⽤带有输出参数值的存储过程</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 调⽤存储过程插⼊数据，获取返回值</span><br><span class="line">CALL orders_proc(1, 2, 30, @out_num);</span><br></pre></td></tr></table></figure><h1 id="九-Mysql触发器"><a href="#九-Mysql触发器" class="headerlink" title="九.Mysql触发器"></a>九.Mysql触发器</h1><h2 id="1-触发器简介"><a href="#1-触发器简介" class="headerlink" title="1.触发器简介"></a>1.触发器简介</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>触发器（trigger）是MySQL提供给程序员和数据分析员来保证数据完整性的⼀种⽅法，它是与表事件相关的特殊的存储过程，它的执⾏不是由程序调⽤，也不是⼿⼯启动，⽽是由事件来触发，⽐如当对⼀个表进⾏操作（INSERT&#x2F;DELETE&#x2F;UPDATE）时就会激活它执⾏。</p><p>简单来说，当我们执⾏⼀条SQL语句的时候，这条SQL语句的执⾏会⾃动去触发执⾏其他的SQL语句</p><h3 id="2-四要素"><a href="#2-四要素" class="headerlink" title="2.四要素"></a>2.四要素</h3><blockquote><p>1.监视地点(table)</p><p>2.监视事件(insert&#x2F;delete&#x2F;update)</p><p>3.监视事件(before&#x2F;after)</p><p>4.触发事件(insert&#x2F;delete&#x2F;update)</p></blockquote><h2 id="2-创建触发器"><a href="#2-创建触发器" class="headerlink" title="2.创建触发器"></a>2.创建触发器</h2><h3 id="1-语法格式-9"><a href="#1-语法格式-9" class="headerlink" title="1.语法格式"></a>1.语法格式</h3><p>1.创建触发器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create trigger trigger_name,trigger_time on tbl_name for each row trigger_stmt</span><br></pre></td></tr></table></figure><p>2.创建有多个执行语句的触发器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELIMITER $ -- 将MySQL的结束符号从&quot;;&quot;改为&quot;$&quot;，避免执⾏出现错误</span><br><span class="line">CREATE TRIGGER 触发器名</span><br><span class="line">触发时间 触发事件 ON 表名 FOR EACH ROW</span><br><span class="line">BEGIN</span><br><span class="line"> 执⾏语句列表</span><br><span class="line">END $ -- $表示结束标记</span><br></pre></td></tr></table></figure><p>3.语法说明</p><blockquote><ul><li>其中,begin和end之间的执行语句列表参数表示需要执行多个语句,不同语句用分号隔开</li><li>一般情况下,MySQL默认以;作为结束的标志,与触发器中需要的分行起冲突;为解决此问题可以使用delimiter分隔符.例如:delimiter $ 作为开始符号,可以将结束符号变成$</li></ul></blockquote><h3 id="2-语法说明"><a href="#2-语法说明" class="headerlink" title="2.语法说明"></a>2.<strong>语法说明</strong></h3><p><strong>trigger_name</strong></p><p>触发器的名称，触发器在当前数据库中必须具有唯⼀的名称。如果要在某个特定数据库中创建，名称前⾯应该加上数据库的名称。</p><p><strong>tirgger_time</strong></p><p>触发时间，取值BEFORE或AFTER。触发器被触发的时刻，表示触发器是在激活它的语句之前或之后触发。若希望验证新数据是否满⾜条件，则使⽤BEFORE选项；若希望在激活触发器的语句执⾏之后完成⼏个或更多的改变，则通常使⽤AFTER选项。</p><p><strong>trigger_event</strong></p><p>触发事件，⽤于指定激活触发器的语句的种类，取值INSERT、DELETE或UPDATE。</p><p>INSERT：将新⾏插⼊表时激活触发器。例如，通过INSERT、LOAD DATA和REPLACE语句。</p><p>DELETE：从表中删除某⼀⾏数据时激活触发器，例如，通过DELETE和REPLACE语句。</p><p>UPDATE：更改表中某⼀⾏数据时激活触发器，例如，通过UPDATE语句。</p><p><strong>FOR EACH ROW</strong></p><p>⼀般是指⾏级触发，对于受触发事件影响的每⼀⾏都要激活触发器的动作。例如，使⽤INSERT语句向某个表中插⼊多⾏数据时，触发器会对每⼀⾏数据的插⼊都执⾏相应的触发器动作。</p><p>注意：每个表都⽀持INSERT、UPDATE和DELETE的BEFORE与AFTER，因此每个表最多⽀持6个触发器。每个表的每个事件每次只允许有⼀个触发器。单⼀触发器不能与多个事件或多个表关联。</p><p><strong>tbl_name</strong></p><p>与触发器相关联的表名，此表必须是永久性表，不能将触发器与临时表或视图关联起来。在该表上触发事件发⽣时才会激活触发器。同⼀个表不能拥有两个具有相同触发时刻和事件的触发器。例如，对于⼀张数据表，不能同时有两个BEFORE UPDATE触发器，但可以有⼀个BEFORE UPDATE触发器和⼀个BEFORE INSERT触发器，或⼀个BEFORE UPDATE 触发器和⼀个AFTER UPDATE触发器。</p><p><strong>trigger_stmt</strong></p><p>是当触发程序激活时执⾏的SQL语句。如果你打算执⾏多个语句，可使⽤BEGIN…END复合语句结构。</p><h2 id="3-触发器操作"><a href="#3-触发器操作" class="headerlink" title="3.触发器操作"></a>3.触发器操作</h2><p>1.在MySQL中，若需要查看数据库中已有的触发器，则可以使⽤ SHOW TRIGGERS 语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show triggers</span><br></pre></td></tr></table></figure><p>2.删除触发器</p><p>(1)直接删除</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop trigger 触发器名称;</span><br></pre></td></tr></table></figure><p>(2)先判断触发器是否存在,如果存在则删除</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if(object_id(&#x27;触发器名&#x27;)is not null)</span><br><span class="line">drop trigger 触发器名</span><br><span class="line">go</span><br></pre></td></tr></table></figure><h2 id="4-触发器限制"><a href="#4-触发器限制" class="headerlink" title="4.触发器限制"></a>4.触发器限制</h2><p>1.⼀个表最多只能有三个触发器（INSERT&#x2F;DELETE&#x2F;UPDATE）</p><p>2.每个触发器只能⽤于⼀个表</p><p>3.不能对视图、临时表创建触发器</p><p>4.truncate table能删除表，但不能触发触发器</p><p>5.不能将触发器⽤于系统表</p><h2 id="5-触发器案例"><a href="#5-触发器案例" class="headerlink" title="5.触发器案例"></a>5.触发器案例</h2><p>需求：在下订单的时候，对应的商品的库存量要相应的减少，即卖出商品之后减少库存量</p><p>1.编写触发器</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 1.修改结束标识</span><br><span class="line">DELIMITER $</span><br><span class="line">-- 2.创建触发器</span><br><span class="line">CREATE TRIGGER t1</span><br><span class="line">-- 3.指定触发的时机和要监听的表</span><br><span class="line">AFTER INSERT ON orders</span><br><span class="line">-- 4.⾏触发器，固定写法</span><br><span class="line">FOR EACH ROW</span><br><span class="line">-- 5.触发后具体要执⾏的事件</span><br><span class="line">BEGIN</span><br><span class="line"> -- 订单+1，库存-1</span><br><span class="line"> UPDATE goods SET num = num - 1 WHERE gid = 1;</span><br><span class="line">END $</span><br></pre></td></tr></table></figure><p>2.查询goods表中gid&#x3D;1的商品的库存量。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 输出gid=1的商品库存为20</span><br><span class="line">SELECT * FROM goods WHERE gid = 1;</span><br></pre></td></tr></table></figure><p>3.3.向订单表orders中添加⼀条订单数据。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO orders VALUES(1, 1, 15);</span><br></pre></td></tr></table></figure><p>4.再次查看goods表中gid&#x3D;1的商品的库存量</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 输出gid=1的商品库存为19，商品的库存储量减1</span><br><span class="line">SELECT * FROM goods WHERE gid = 1;</span><br></pre></td></tr></table></figure><h1 id="十-DCL"><a href="#十-DCL" class="headerlink" title="十.DCL"></a>十.DCL</h1><p>数据控制语⾔（Data Control Language）在SQL语⾔中，是⼀种可对数据访问权进⾏控制的指令，它可以控制特定⽤户账户对数据表、查看表、存储程序、⽤户⾃定义函数等数据库对象的控制权。由GRANT和REVOKE两个指令组成。</p><p>MySQL默认使⽤的都是root⽤户，超级管理员，拥有全部的权限。除了root⽤户以外，我们还可以通过DCL语⾔来定义⼀些权限较⼩的⽤户，分配不同的权限来管理和维护数据库。</p><h2 id="1-创建用户"><a href="#1-创建用户" class="headerlink" title="1.创建用户"></a>1.创建用户</h2><h3 id="1-语法结构"><a href="#1-语法结构" class="headerlink" title="1.语法结构"></a>1.语法结构</h3><h4 id="1-语法格式-10"><a href="#1-语法格式-10" class="headerlink" title="1.语法格式"></a>1.语法格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create user &#x27;username&#x27;@&#x27;host&#x27; identified by &#x27;password&#x27;;</span><br></pre></td></tr></table></figure><h4 id="2-参数说明"><a href="#2-参数说明" class="headerlink" title="2.参数说明"></a>2.参数说明</h4><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230517195423511.png" alt="image-20230517195423511"></p><h3 id="2-案例演示-7"><a href="#2-案例演示-7" class="headerlink" title="2.案例演示"></a>2.案例演示</h3><p>1.创建admin01⽤户，只能在localhost这个服务器登录MySQL服务器，登陆密码为123456</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;admin01&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure><p>2.创建的新⽤户在名字为mysql的数据库中的user视图表中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM mysql.user;</span><br></pre></td></tr></table></figure><p>3.创建admin02⽤户可以在任何电脑上登录MySQL服务器，登陆密码设置为123456。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE USER &#x27;admin02&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure><h2 id="2-用户授权"><a href="#2-用户授权" class="headerlink" title="2.用户授权"></a>2.用户授权</h2><h3 id="1-语法结构-1"><a href="#1-语法结构-1" class="headerlink" title="1.语法结构"></a>1.语法结构</h3><h4 id="1-语法格式-11"><a href="#1-语法格式-11" class="headerlink" title="1.语法格式"></a>1.语法格式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT 权限1, 权限2... ON 数据库名.表名 TO &#x27;⽤户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure><h4 id="2-参数说明-1"><a href="#2-参数说明-1" class="headerlink" title="2.参数说明"></a>2.参数说明</h4><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230517195636411.png" alt="image-20230517195636411"></p><h3 id="2-案例演示-8"><a href="#2-案例演示-8" class="headerlink" title="2.案例演示"></a>2.案例演示</h3><p>1.给admin01⽤户分配对db4数据库中goods表的操作权限为“查询”。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT SELECT ON db4.goods TO &#x27;admin01&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><p>2.给admin02⽤户分配所有权限，对所有数据库的所有表。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT ALL ON *.* TO &#x27;admin02&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><p>3.使⽤admin01⽤户（密码123456）登录数据库测试权限。发现在数据库db4中，只有goods表。</p><p>5.在goods表上执⾏查询操作，正常执⾏。</p><p>6.在goods表上执⾏插⼊操作，发现不允许执⾏，没有权限。</p><h2 id="3-查看权限"><a href="#3-查看权限" class="headerlink" title="3.查看权限"></a>3.查看权限</h2><h3 id="1-语法格式-12"><a href="#1-语法格式-12" class="headerlink" title="1.语法格式"></a>1.语法格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW GRANTS FOR &#x27;⽤户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure><h3 id="2-查看root用户权限"><a href="#2-查看root用户权限" class="headerlink" title="2.查看root用户权限"></a>2.查看root用户权限</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查看root⽤户的权限</span><br><span class="line">SHOW GRANTS FOR &#x27;root&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><p>说明：显示的结果中GRANT ALL PRIVILEGES关键字表示拥有所有权限。</p><h2 id="4-删除用户"><a href="#4-删除用户" class="headerlink" title="4.删除用户"></a>4.删除用户</h2><p>1.语法格式</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP USER &#x27;⽤户名&#x27;@&#x27;主机名&#x27;;</span><br></pre></td></tr></table></figure><p>2.删除admin01用户</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 删除admin01⽤户</span><br><span class="line">DROP USER &#x27;admin01&#x27;@&#x27;localhost&#x27;;</span><br></pre></td></tr></table></figure><p>3.删除admin02⽤户</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 1.删除admin02⽤户，出现如下异常：</span><br><span class="line">-- 1396 - Operation DROP USER failed for &#x27;admin02&#x27;@&#x27;localhost&#x27;</span><br><span class="line">DROP USER &#x27;admin02&#x27;@&#x27;localhost&#x27;;</span><br><span class="line"># 2.如果主机为“％”，每当尝试使⽤localhost删除⽤户时，就会产⽣1396错误。因此需使⽤主机“％”删除⽤户</span><br><span class="line">DROP USER &#x27;admin02&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure><h2 id="5-查询用户"><a href="#5-查询用户" class="headerlink" title="5.查询用户"></a>5.查询用户</h2><p>选择名为mysql的数据库，直接查询user表即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> 查询所有⽤户</span><br><span class="line"># SELECT * FROM USER;</span><br><span class="line">SELECT * FROM mysql.user;</span><br></pre></td></tr></table></figure><h1 id="十一-数据库的备份与还原"><a href="#十一-数据库的备份与还原" class="headerlink" title="十一.数据库的备份与还原"></a>十一.数据库的备份与还原</h1><h2 id="1-Navicat-备份与还原"><a href="#1-Navicat-备份与还原" class="headerlink" title="1.Navicat 备份与还原"></a>1.Navicat 备份与还原</h2><h3 id="1-Navicat数据备份"><a href="#1-Navicat数据备份" class="headerlink" title="1.Navicat数据备份"></a>1.Navicat数据备份</h3><p>1.选中要备份的数据库（db4），右键选择【转储SQL⽂件】-【结构和数据】选项。</p><p>2.指定⽂件位置，选择导出即可</p><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230517200207841.png" alt="image-20230517200207841"></p><h3 id="2-Navicat数据还原"><a href="#2-Navicat数据还原" class="headerlink" title="2.Navicat数据还原"></a>2.Navicat数据还原</h3><p>1.先删除db4数据库。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE db4;</span><br></pre></td></tr></table></figure><p>2.选中新建连接MyMariaDB，然后【右键】选择【运⾏SQL⽂件】选项。</p><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230517200301875.png" alt="image-20230517200301875"></p><p>3.通过【⽂件】选项，定位选择【db4.sql】数据库脚本⽂件；然后点击【开始】运⾏SQL脚本⽂件。</p><p><img src="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230517200318468.png" alt="image-20230517200318468"></p><h2 id="2-命令行备份与还原"><a href="#2-命令行备份与还原" class="headerlink" title="2.命令行备份与还原"></a>2.命令行备份与还原</h2><h3 id="1-命令行备份"><a href="#1-命令行备份" class="headerlink" title="1.命令行备份"></a>1.命令行备份</h3><p>进⼊到MySQL安装⽬录的bin⽬录下，打开DOS命令⾏</p><p>1.语法格式。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -u ⽤户名 -p 密码 数据库 &gt; ⽂件路径</span><br></pre></td></tr></table></figure><p>2.执⾏备份，备份db4中的数据到桌⾯的db4.sql⽂件中。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -uroot -p123456 db4 &gt; /Users/yuanxin/Desktop/db4.sql</span><br></pre></td></tr></table></figure><h3 id="2-命令行还原"><a href="#2-命令行还原" class="headerlink" title="2.命令行还原"></a>2.命令行还原</h3><p>1.先删除db4数据库，在对应的数据库上右键，选择【删除数据库】选项。</p><p>2.还原的时候需要先创建⼀个db4数据库；或者在sql脚本⽂件中包含有db4数据库的创建语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE db4 CHARACTER SET utf8;</span><br></pre></td></tr></table></figure><p>3.恢复数据，还原db4数据库中的数据。</p><figure class="highlight dos"><table><tr><td class="code"><pre><span class="line"># 语法格式</span><br><span class="line">source sql⽂件地址;</span><br><span class="line"># <span class="number">1</span>.Windows系统</span><br><span class="line">-- 直接进⼊Command Line Client终端</span><br><span class="line">-- 选中所创建的db4数据库</span><br><span class="line">MariaDB&gt; USE db4;</span><br><span class="line">-- 通过命令执⾏db4.sql数据库脚本⽂件</span><br><span class="line">MariaDB&gt; source C:\User\yuanxin\Desktop\db4.sql;</span><br><span class="line"># <span class="number">2</span>.Mac系统</span><br><span class="line">-- 在Mac终端输⼊登录MySQL数据库的命令(回⻋后需要输⼊数据库的登录登录密码)</span><br><span class="line">mysql -u root -p</span><br><span class="line">-- 选中所创建的db4数据库</span><br><span class="line">MariaDB [(none)]&gt; USE db4;</span><br><span class="line">-- 通过命令执⾏db4.sql数据库脚本⽂件</span><br><span class="line">MariaDB [(none)]&gt; source /Users/yuanxin/Desktop/db4.sql;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL&quot;&gt;&lt;a href=&quot;#MySQL&quot; class=&quot;headerlink&quot; title=&quot;MySQL&quot;&gt;&lt;/a&gt;MySQL&lt;/h1&gt;&lt;h1 id=&quot;一-数据库的基本概念&quot;&gt;&lt;a href=&quot;#一-数据库的基本概念&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="mysql" scheme="http://example.com/categories/mysql/"/>
    
    
    <category term="mysql" scheme="http://example.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>IO</title>
    <link href="http://example.com/2023/05/05/IO/"/>
    <id>http://example.com/2023/05/05/IO/</id>
    <published>2023-05-05T12:33:38.000Z</published>
    <updated>2023-05-06T13:25:47.416Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、List"><a href="#一、List" class="headerlink" title="一、List"></a>一、List</h1><h2 id="1、ArrayList"><a href="#1、ArrayList" class="headerlink" title="1、ArrayList"></a>1、ArrayList</h2><h3 id="1-底层操作机制"><a href="#1-底层操作机制" class="headerlink" title="1.底层操作机制"></a>1.底层操作机制</h3><blockquote><ol><li>ArrayList中维护了一个Object类型的数组elementData.transient Object[] elementData;</li><li>当创建ArrayList对象时,如果使用的是无参构造器,则初始elementData容量为0,第一次添加,则扩容elementData为10,如果需要再次扩容,则扩容elementData为1.5倍.</li><li>如果使用的是指定大小的构造器,则初始elementData容量为指定大小,如果需要扩容,则直接扩容elementData为1.5倍</li></ol></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、List&quot;&gt;&lt;a href=&quot;#一、List&quot; class=&quot;headerlink&quot; title=&quot;一、List&quot;&gt;&lt;/a&gt;一、List&lt;/h1&gt;&lt;h2 id=&quot;1、ArrayList&quot;&gt;&lt;a href=&quot;#1、ArrayList&quot; class=&quot;header</summary>
      
    
    
    
    <category term="java强化" scheme="http://example.com/categories/java%E5%BC%BA%E5%8C%96/"/>
    
    
    <category term="io" scheme="http://example.com/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>java基础练习--图书管理系统</title>
    <link href="http://example.com/2023/05/03/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2023/05/03/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-05-03T09:43:47.000Z</published>
    <updated>2023-05-04T01:35:21.237Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图书管理系统"><a href="#图书管理系统" class="headerlink" title="图书管理系统;"></a>图书管理系统;</h2><h3 id="1-功能"><a href="#1-功能" class="headerlink" title="1.功能:"></a>1.功能:</h3><blockquote><p>添加图书</p><p>删除图书</p><p>查找图书</p><p>​根据书名查找</p><p>​根据借阅状态查找</p><p>​查找全部</p><p>​退出</p><p>更新图书</p><p>借书</p><p>还书</p></blockquote><h3 id="2-准备"><a href="#2-准备" class="headerlink" title="2.准备:"></a>2.准备:</h3><h4 id="读取"><a href="#读取" class="headerlink" title="读取:"></a>读取:</h4><p>从文件中读取图书信息,完成持久化存储</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">     <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;book.txt&quot;</span>);</span><br><span class="line">         <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line">         books = (ArrayList&lt;Book&gt;) objectInputStream.readObject();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         books = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Book&gt;();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>将图书信息写入文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;book.txt&quot;</span>);</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream);</span><br><span class="line">    <span class="comment">//这里是将集合对象写入文件</span></span><br><span class="line">    objectOutputStream.writeObject(books);</span><br><span class="line">    objectOutputStream.flush();</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-实体类-图书类"><a href="#3-实体类-图书类" class="headerlink" title="3.实体类(图书类)"></a>3.实体类(图书类)</h3><p>包括:id ,书名,作者,价格,类型,状态</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LibraryMessageSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * date: 2023/5/3 15:11</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fjp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">//书名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//作者</span></span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="comment">//价格</span></span><br><span class="line">    <span class="keyword">private</span> String price;</span><br><span class="line">    <span class="comment">//书本的风格</span></span><br><span class="line">    <span class="keyword">private</span> String style;</span><br><span class="line">    <span class="comment">//是否借出</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String id, String name,String author, String price, String style, String status)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.style = style;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(String price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStyle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> style;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStyle</span><span class="params">(String style)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.style = style;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(String status)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAuthor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthor</span><span class="params">(String author)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  id+<span class="string">&quot;\t\t &quot;</span>+ name+<span class="string">&quot;\t\t&quot;</span>+author+<span class="string">&quot;\t\t&quot;</span>+price+<span class="string">&quot;\t\t &quot;</span>+style+<span class="string">&quot;\t    &quot;</span>+status+<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-添加图书"><a href="#4-添加图书" class="headerlink" title="4.添加图书"></a>4.添加图书</h3><p>从键盘输入添加的图书信息,添加到集合中,图书编号随机生成</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inputBooks</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span>(<span class="type">int</span>) Math.floor( Math.random()*<span class="number">1000</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">newid</span> <span class="operator">=</span> Integer.toString(id);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入图书名:&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入作者名:&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">author</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入图书价格:&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">price</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入图书种类:&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">style</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入图书状态:&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">status</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">    book.setId(newid);</span><br><span class="line">    book.setName(name);</span><br><span class="line">    book.setAuthor(author);</span><br><span class="line">    book.setPrice(price);</span><br><span class="line">    book.setStyle(style);</span><br><span class="line">    book.setStatus(status);</span><br><span class="line">    books.add(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将集合写入文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addBook</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    inputBooks();</span><br><span class="line">    write();</span><br><span class="line">    System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-删除图书"><a href="#5-删除图书" class="headerlink" title="5.删除图书"></a>5.删除图书</h3><p>根据书名进行删除图书</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteBook</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入要删除图书的书名:&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    <span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">        <span class="keyword">if</span> (book.getName().equals(next))&#123;</span><br><span class="line">            books.remove(book);</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                write();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;未找到图书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-查找图书"><a href="#6-查找图书" class="headerlink" title="6.查找图书"></a>6.查找图书</h3><p>根据书名查找</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findName</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入要查找的书名&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    <span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">        <span class="keyword">if</span> (book.getName().equals(name))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;编号       书名          作者       价格      类型       状态&quot;</span>);</span><br><span class="line">            System.out.println(book);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;未找到图书,请重新输入&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据借阅状态查找</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findStatus</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入要查找的图书类别&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">style</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    <span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">        <span class="keyword">if</span> (book.getStatus().equals(<span class="string">&quot;未借&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;编号       书名          作者       价格      类型       状态&quot;</span>);</span><br><span class="line">            System.out.println(book);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(book.getStatus().equals(<span class="string">&quot;已借&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;编号       书名          作者       价格      类型       状态&quot;</span>);</span><br><span class="line">            System.out.println(book);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;状态输入有误,您可以输入未借/已借&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找全部图书信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findBook</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;编号       书名          作者       价格      类型       状态&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-更新图书信息"><a href="#7-更新图书信息" class="headerlink" title="7.更新图书信息"></a>7.更新图书信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyBook</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入要更新图书的编号或书名:&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    <span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">        <span class="keyword">if</span> (book.getName().equals(next)||book.getId().equals(next))&#123;</span><br><span class="line">            System.out.println(book);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入要修改的内容:&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;书名&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;作者:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">author</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;价格&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">price</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;类别:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">style</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;状态&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">status</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            book.setName(name);</span><br><span class="line">            book.setPrice(price);</span><br><span class="line">            book.setAuthor(author);</span><br><span class="line">            book.setStyle(style);</span><br><span class="line">            book.setStatus(status);</span><br><span class="line">            System.out.println(<span class="string">&quot;修改成功&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                write();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入正确的书名或编号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-借书"><a href="#8-借书" class="headerlink" title="8.借书"></a>8.借书</h3><p>首先遍历看图书是否存在,存在接着判断图书状态,未借可借,更改图书状态,已借,不能借阅</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">borrow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;输入要借阅的书名:&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    <span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">        <span class="keyword">if</span> (book.getName().equals(name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (book.getStatus().equals(<span class="string">&quot;未借&quot;</span>)) &#123;</span><br><span class="line">                book.setStatus(<span class="string">&quot;已借&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;借阅成功,请爱惜图书&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    write();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (book.getStatus().equals(<span class="string">&quot;已借&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;已借出,换本书吧&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;图书不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-还书"><a href="#9-还书" class="headerlink" title="9.还书"></a>9.还书</h3><p>输入归还的书名,更改图书状态</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">returnBook</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;输入要归还的书名:&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    <span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">        book.setStatus(<span class="string">&quot;未借&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;归还成功&quot;</span>);</span><br><span class="line">        write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-环境类"><a href="#10-环境类" class="headerlink" title="10.环境类"></a>10.环境类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LibraryMessageSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * date: 2023/5/3 15:11</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fjp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LibraryMessageSystem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot; -------------------------------------------------------------&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;|                           图书管理系统                       |&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;| 1.增加图书  2.删除图书  3.查找图书  4.更新图书  5.借书  6.还书 |&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot; -------------------------------------------------------------&quot;</span>);</span><br><span class="line">           <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">           System.out.println(<span class="string">&quot;请选择你需要的操作:&quot;</span>);</span><br><span class="line">           <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">           <span class="keyword">switch</span> (i)&#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                   BookUtil.addBook();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                   BookUtil.deleteBook();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                   tag=<span class="literal">true</span>;</span><br><span class="line">                   <span class="keyword">while</span>(tag) &#123;</span><br><span class="line">                       System.out.println(<span class="string">&quot;1.书名查找    2.状态查找    3.查找全部    4.返回上一级&quot;</span>);</span><br><span class="line">                       System.out.println(<span class="string">&quot;请选择查询方式:&quot;</span>);</span><br><span class="line">                       <span class="type">int</span> <span class="variable">nextInt</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                       <span class="keyword">if</span> (nextInt == <span class="number">1</span>) &#123;</span><br><span class="line">                           BookUtil.findName();</span><br><span class="line"></span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (nextInt == <span class="number">2</span>) &#123;</span><br><span class="line">                           BookUtil.findStatus();</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (nextInt == <span class="number">3</span>) &#123;</span><br><span class="line">                           BookUtil.findBook();</span><br><span class="line"></span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (nextInt == <span class="number">4</span>) &#123;</span><br><span class="line">                           tag = <span class="literal">false</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                   BookUtil.modifyBook();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                   BookUtil.borrow();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                   BookUtil.returnBook();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;图书管理系统&quot;&gt;&lt;a href=&quot;#图书管理系统&quot; class=&quot;headerlink&quot; title=&quot;图书管理系统;&quot;&gt;&lt;/a&gt;图书管理系统;&lt;/h2&gt;&lt;h3 id=&quot;1-功能&quot;&gt;&lt;a href=&quot;#1-功能&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="java练习" scheme="http://example.com/categories/java%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="图书管理系统" scheme="http://example.com/tags/%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>java基础练习--学生管理系统</title>
    <link href="http://example.com/2023/05/03/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2023/05/03/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-05-03T05:57:55.000Z</published>
    <updated>2023-05-03T06:06:55.367Z</updated>
    
    <content type="html"><![CDATA[<p>java基础学习结束,写一个学生信息管理系统,包括增加学生信息,删除学生信息,查找学生信息,更改学生信息.</p><blockquote><p>增加学生信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从键盘录入学生的基本信息,存入txt文件,达到持久化存储</span><br></pre></td></tr></table></figure><p>删除学生信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">遍历集合中存储的信息,根据学生的学号删除学生xinx</span><br></pre></td></tr></table></figure><p>查找学生信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查找学生信息</span><br><span class="line">查找全部</span><br><span class="line">根据学号查找</span><br></pre></td></tr></table></figure><p>修改学生信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据学号进行更改</span><br></pre></td></tr></table></figure></blockquote><p>代码:</p><p>​学生类(Student)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> studentmassagesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * date: 2023/5/3 8:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fjp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 学号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 性别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 班级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String grade;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 学院</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String collage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String id ,String name, String sex, String phone, String grade, String collage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">        <span class="built_in">this</span>.grade = grade;</span><br><span class="line">        <span class="built_in">this</span>.collage = collage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGrade</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGrade</span><span class="params">(String grade)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCollage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> collage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCollage</span><span class="params">(String collage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.collage = collage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id +<span class="string">&quot;\t    &quot;</span>+name+<span class="string">&quot;\t&quot;</span>+sex+<span class="string">&quot;\t    &quot;</span>+phone+<span class="string">&quot;\t    &quot;</span>+grade+<span class="string">&quot;\t    &quot;</span>+collage+<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>工具类(实现具体的增删查改,创建输入输出流)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> studentmassagesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * date: 2023/5/3 9:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fjp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 学生管理系统的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Student&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个输入流读取文件中的学生信息,完成持久化存储</span></span><br><span class="line"><span class="comment">     * 添加学生信息,存储到文件中</span></span><br><span class="line"><span class="comment">     * 静态代码块只执行一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个文件字节输入流,将student.txt的内容读取到程序,进行操作</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;student.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//将创建的输入流,转为对象输入流,这里要对Student进行操作</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line">                <span class="comment">//读取对象</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> objectInputStream.readObject();</span><br><span class="line">                <span class="comment">//将读取到的对象赋值给Arraylist,这里是将内存地址给了list</span></span><br><span class="line">                list = (ArrayList&lt;Student&gt;) object;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//list指向新的引用</span></span><br><span class="line">            list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addMessage</span><span class="params">()</span> &#123;</span><br><span class="line">       keyBoard();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加成功!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据学号删除学生信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要删除的学生学号:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (student.getId().equals(id))&#123;</span><br><span class="line">                list.remove(student);</span><br><span class="line">                System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    writeFile();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;未找到学号为&quot;</span>+id+<span class="string">&quot;的学生&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找所有学生信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学号\t&quot;</span>+<span class="string">&quot;姓名\t&quot;</span> +<span class="string">&quot;性别\t&quot;</span>+<span class="string">&quot;电话\t&quot;</span>+<span class="string">&quot;班级\t&quot;</span>+<span class="string">&quot;学院\t&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showIdMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要查找的学生学号:&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (student.getId().equals(id))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;学号\t&quot;</span>+<span class="string">&quot;姓名\t&quot;</span> +<span class="string">&quot;性别\t&quot;</span>+<span class="string">&quot;电话\t&quot;</span>+<span class="string">&quot;班级\t&quot;</span>+<span class="string">&quot;学院\t&quot;</span>);</span><br><span class="line">                System.out.println(student);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;未找到学号为&quot;</span>+id+<span class="string">&quot;的学生&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据学号修改学信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要修改的学生学号:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (student.getId().equals(id))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;输入修改后的内容:&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;姓名:&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">newName</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                System.out.println(<span class="string">&quot;性别:&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">newSex</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                System.out.println(<span class="string">&quot;电话:&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">newPhone</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                System.out.println(<span class="string">&quot;班级:&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">newGrade</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                System.out.println(<span class="string">&quot;学院:&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">newCollage</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                student.setName(newName);</span><br><span class="line">                student.setSex(newSex);</span><br><span class="line">                student.setPhone(newPhone);</span><br><span class="line">                student.setGrade(newGrade);</span><br><span class="line">                student.setCollage(newCollage);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    writeFile();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;修改成功&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;未找到学号为&quot;</span>+id+<span class="string">&quot;的学生&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 键盘输入的方法,从键盘录入学生信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">keyBoard</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生学号:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="comment">//判断是否存在</span></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (student.getId().equals(id))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;该学生已存在,请重新输入&quot;</span>);</span><br><span class="line">                keyBoard();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生姓名:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入性别:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入联系方式:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入班级:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">grade</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学院:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">collage</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student1.setId(id);</span><br><span class="line">        student1.setName(name);</span><br><span class="line">        student1.setSex(sex);</span><br><span class="line">        student1.setPhone(phone);</span><br><span class="line">        student1.setGrade(grade);</span><br><span class="line">        student1.setCollage(collage);</span><br><span class="line">        list.add(student1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list写入文本文件中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建文件输出流,对象输出流</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//将内容写入到txt文件</span></span><br><span class="line">        fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;student.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//文件输出流转对象输出流</span></span><br><span class="line">        objectOutputStream = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream);</span><br><span class="line">        <span class="comment">//将list写入文件</span></span><br><span class="line">        objectOutputStream.writeObject(list);</span><br><span class="line">        <span class="comment">//冲刷</span></span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动类(Application)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> studentmassagesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.generic.BREAKPOINT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * date: 2023/5/3 10:26</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fjp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;|                 xxxxxx学生管理系统                                |\n&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;| 1.增加学生    2.删除学生   3.查找学生信息   4.修改学生信息   5.退出 |\n&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;-------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入要执行的操作(eg:1/2/3/4/5):&quot;</span>);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="type">int</span> <span class="variable">tag</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="keyword">switch</span> (tag)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    StudentUtil.addMessage();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    StudentUtil.deleteMessage();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">tag1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">while</span> (tag1)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;1.查找全部学生信息   2.根据学号查找  3.返回上一级&quot;</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                        <span class="keyword">if</span> (i==<span class="number">1</span>)&#123;</span><br><span class="line">                            StudentUtil.showMessage();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (i==<span class="number">2</span>)&#123;</span><br><span class="line">                            StudentUtil.showIdMessage();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (i==<span class="number">3</span>)&#123;</span><br><span class="line">                            tag1=<span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    StudentUtil.modifyMessage();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;java基础学习结束,写一个学生信息管理系统,包括增加学生信息,删除学生信息,查找学生信息,更改学生信息.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;增加学生信息&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    <category term="java练习" scheme="http://example.com/categories/java%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="学生管理系统" scheme="http://example.com/tags/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础</title>
    <link href="http://example.com/2023/05/01/JAVA%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2023/05/01/JAVA%E5%9F%BA%E7%A1%80/</id>
    <published>2023-05-01T12:08:37.000Z</published>
    <updated>2023-05-01T12:09:49.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><h2 id="一、准备阶段W"><a href="#一、准备阶段W" class="headerlink" title="一、准备阶段W"></a>一、准备阶段W</h2><h2 id="1-JAVA的执行流程"><a href="#1-JAVA的执行流程" class="headerlink" title="1.JAVA的执行流程"></a>1.JAVA的执行流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.Java文件（源文件）——&gt;javac编译——&gt;.class文件（字节码文件）——&gt;java运行——&gt;结果</span><br></pre></td></tr></table></figure><h2 id="2-开发细节"><a href="#2-开发细节" class="headerlink" title="2.开发细节"></a>2.开发细节</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.区分大小写</span><br><span class="line">2.Java方法是一条语句，以分号结束</span><br><span class="line">3.大括号成对出现</span><br><span class="line">4.一个Java文件中只能有一个public类。其它类个数不限。</span><br><span class="line">5.如果源文件包含一个public类，则文件名必须按照该类名命名。</span><br><span class="line">6.一个源文件中最多只能有一个public类，其他类个数不限，也可以将main方法写在非public类中，然后指定运行非public类，这样入口方法就是非public的main方法。</span><br></pre></td></tr></table></figure><h2 id="3-命名规则"><a href="#3-命名规则" class="headerlink" title="3..命名规则"></a>3..命名规则</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.有字母数字下划线组成</span><br><span class="line">2.数字不能开头</span><br><span class="line">3.不能使用关键字和保留字，但可以包含关键字和保留字</span><br><span class="line">4.Java中严格区分大小写，长度无限制</span><br><span class="line">5.标识符不能包含空格</span><br><span class="line">6.不能使用特殊符号,除$和_</span><br></pre></td></tr></table></figure><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.包名，多单词组成时所有字母都小写。如aaa.bbb.ccc</span><br><span class="line">2.类名，接口名,注解名,枚举名:多单词组成时，所有单词首字母都大写。如：TalkBankGame</span><br><span class="line">3.变量名，方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写。如aaaBbbCcc</span><br><span class="line">4.常量名：所有的字母都大写，多单词时每个单词用下划线连接。XXX_YYY_ZZZ</span><br></pre></td></tr></table></figure><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><h2 id="1-整型"><a href="#1-整型" class="headerlink" title="1.整型"></a>1.整型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int 整型 4字节</span><br><span class="line">short 短整型 2字节</span><br><span class="line">long  长整型 8字节，对于long需要加上L或l后缀区分</span><br><span class="line">byte  1字节</span><br></pre></td></tr></table></figure><h2 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2.浮点型"></a>2.浮点型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.float：单精度浮点型  4字节，后缀加f</span><br><span class="line">2.double：双精度浮点型   8字节</span><br></pre></td></tr></table></figure><h2 id="3-字符型"><a href="#3-字符型" class="headerlink" title="3.字符型"></a>3.字符型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char 字符型  2字节，用单引号括起来，仅有一个字符</span><br><span class="line">注意：</span><br><span class="line">1)字符常量用单引号‘ ’</span><br><span class="line">2）java中允许使用转义符‘\’来将其后的字符转换为特殊字符常量    例如：char a=‘\n’;表示换行符</span><br><span class="line">3）在java中，char的本质是一个整数，在输出时，是Unicode码对应的字符</span><br><span class="line">4）可以直接给char附一个整数，然后输出时，会按照对应的Unicode字符输出</span><br><span class="line">5)char‘类型是可以进行运算的，相当于一个整数，因为都有对应的Unicode码</span><br></pre></td></tr></table></figure><h2 id="4-Boolean"><a href="#4-Boolean" class="headerlink" title="4.Boolean"></a>4.Boolean</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">布尔型，值为true和false</span><br></pre></td></tr></table></figure><h2 id="5-引用数据类型"><a href="#5-引用数据类型" class="headerlink" title="5.引用数据类型"></a>5.引用数据类型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">除过上述的四种基本数据类型，其余都是引用数据类型</span><br><span class="line">常用的String用于定义字符串</span><br></pre></td></tr></table></figure><h2 id="6-基本数据类型转换"><a href="#6-基本数据类型转换" class="headerlink" title="6.基本数据类型转换"></a>6.基本数据类型转换</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">精度小的自动转换为精度大的数据类型：自动类型转换</span><br><span class="line">数据类型按照精度大小排序为(规则)：char ——&gt;int ——&gt;long ——&gt;float ——&gt;double </span><br><span class="line"></span><br><span class="line">byte ——&gt;short ——&gt;int ——&gt;long ——&gt;float ——&gt;double</span><br><span class="line"></span><br><span class="line">基本数据类型转字符串：将基本类型的值+“ ”即可</span><br><span class="line"></span><br><span class="line">String转基本数据类型：通过基本类型的包装类调用parseXX方法即可</span><br></pre></td></tr></table></figure><h2 id="三、运算符"><a href="#三、运算符" class="headerlink" title="三、运算符"></a>三、运算符</h2><h2 id="1-算数运算符"><a href="#1-算数运算符" class="headerlink" title="1.算数运算符"></a>1.算数运算符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加 +</span><br><span class="line">减 —</span><br><span class="line">乘 *</span><br><span class="line">除 /</span><br><span class="line">取余 %</span><br><span class="line">自增 ++</span><br><span class="line">自减 --</span><br></pre></td></tr></table></figure><h2 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2.关系运算符"></a>2.关系运算符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">instanceof：检查是否是类的对象</span><br><span class="line">&gt; 大于</span><br><span class="line">&lt; 小于</span><br><span class="line">= 赋值</span><br><span class="line">== 全等于</span><br><span class="line">基本数据类型判断值是否相同</span><br><span class="line">引用数据类型判断内存地址是否相同</span><br><span class="line">&gt;= 大于等于</span><br><span class="line">&lt;= 小于等于</span><br><span class="line">!= 不等于</span><br><span class="line">基本数据类型判断值是否不相同</span><br><span class="line">引用数据类型判断内存地址是否不相同</span><br></pre></td></tr></table></figure><h2 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3.逻辑运算符"></a>3.逻辑运算符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">短路与&amp;&amp;</span><br><span class="line">全真为真，有假为假（第一个为假，后面条件不再判断）</span><br><span class="line">短路或||</span><br><span class="line">有真为真，全假为假，（判断第一个条件为真，不再判断结果为真）</span><br><span class="line">逻辑与&amp;</span><br><span class="line">全真为真（第一个条件为false，后面的条件任然判断）</span><br><span class="line">逻辑或|</span><br><span class="line">有真为真（第一个第二个条件都要判断）</span><br><span class="line">^逻辑异或</span><br><span class="line">相同为假，不同为真</span><br><span class="line">！非运算</span><br><span class="line">取反</span><br></pre></td></tr></table></figure><h2 id="4-三元运算符"><a href="#4-三元运算符" class="headerlink" title="4.三元运算符"></a>4.三元运算符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件表达式？表达式1:表达式2;</span><br><span class="line">如果条件表达式为true，运算表达式1，如果条件表达式为false，运算表达式2.</span><br><span class="line">注意:赋值给变量时,表达式1和表达式2的类型必须相同.</span><br></pre></td></tr></table></figure><h2 id="四、自动拆装箱"><a href="#四、自动拆装箱" class="headerlink" title="四、自动拆装箱"></a>四、自动拆装箱</h2><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">装箱:将基本数据类型转换成包装类型的过程</span><br><span class="line">拆箱:将包装类型装换成基本数据类型的过程</span><br></pre></td></tr></table></figure><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自动装箱都是通过包装类的valueOf()方法来实现,自动拆箱通过包装类对象的xxxValue()来实现.</span><br></pre></td></tr></table></figure><h2 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h2><h3 id="场景一-、将基本数据类型放入集合类"><a href="#场景一-、将基本数据类型放入集合类" class="headerlink" title="场景一 、将基本数据类型放入集合类"></a>场景一 、将基本数据类型放入集合类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">li.add(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反编译:</span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">li.add(Integer.valueOf(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="场景二、包装类和基本类型的大小比较"><a href="#场景二、包装类和基本类型的大小比较" class="headerlink" title="场景二、包装类和基本类型的大小比较"></a>场景二、包装类和基本类型的大小比较</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a=<span class="number">1</span>;</span><br><span class="line">System.out.println(a==<span class="number">1</span>?<span class="string">&quot;等于&quot;</span>:<span class="string">&quot;不等于&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> bool=<span class="literal">false</span>;</span><br><span class="line">System.out.println(bool?<span class="string">&quot;真&quot;</span>:<span class="string">&quot;假&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反编译:</span><br><span class="line">Integer a=<span class="number">1</span>;</span><br><span class="line">System.out.println(a.IntValue==<span class="number">1</span>?<span class="string">&quot;等于&quot;</span>:<span class="string">&quot;不等于&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> bool=<span class="literal">false</span>;</span><br><span class="line">System.out.println(bool.booleanValue?<span class="string">&quot;真&quot;</span>:<span class="string">&quot;假&quot;</span>);</span><br></pre></td></tr></table></figure><p>包装类与基本数据类型进行比较运算,先将包装类拆箱成基本数据类型,然后比较.</p><h3 id="场景三、包装类型的运算"><a href="#场景三、包装类型的运算" class="headerlink" title="场景三、包装类型的运算"></a>场景三、包装类型的运算</h3><p>对Integer对象进行四则运算</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">System.out.println(i+j);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反编译:</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> Integer.valueOf(<span class="number">20</span>);</span><br><span class="line">    System.out.println(i.intValue() + j.intValue());</span><br></pre></td></tr></table></figure><p>两个包装类型之间的运算,会被自动拆箱成基本类型.</p><h3 id="场景四、三目运算符的使用"><a href="#场景四、三目运算符的使用" class="headerlink" title="场景四、三目运算符的使用"></a>场景四、三目运算符的使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean flag = true;</span><br><span class="line">Integer i = 0;</span><br><span class="line">int j = 1;</span><br><span class="line">int k = flag ? i : j;</span><br><span class="line"></span><br><span class="line">在使用三目运算符时,会发生自动拆箱</span><br><span class="line">1.表达式1和表达式2的值只要有一个时基本数据类型</span><br><span class="line">2.表达式1和表达式2的值类型不一致,会强制拆箱升级成表示范围更大的那个类型</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反编译    </span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> flag ? i.intValue() : j;</span><br><span class="line">    System.out.println(k);</span><br></pre></td></tr></table></figure><p>如果三目运算符的表达式在自动拆箱的过程中为null.会发生自动拆箱导致的空指针异常.</p><h3 id="场景五、函数参数与返回值"><a href="#场景五、函数参数与返回值" class="headerlink" title="场景五、函数参数与返回值"></a>场景五、函数参数与返回值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(Integer num)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getNum</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、语句的分类"><a href="#五、语句的分类" class="headerlink" title="五、语句的分类"></a>五、语句的分类</h2><p>顺序语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码自上而下执行</span><br></pre></td></tr></table></figure><p>分支语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在多个分支选择执行其中一个</span><br></pre></td></tr></table></figure><p>循环语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">重复执行一段代码</span><br></pre></td></tr></table></figure><h2 id="六、分支语句"><a href="#六、分支语句" class="headerlink" title="六、分支语句"></a>六、分支语句</h2><h3 id="1-if-判断语句"><a href="#1-if-判断语句" class="headerlink" title="1.if 判断语句"></a>1.if 判断语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基础的if结构</span><br><span class="line">语法:</span><br><span class="line">if(条件表达式)&#123;</span><br><span class="line">当条件表达式值为true时,执行此处代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if else结构</span><br><span class="line">语法:</span><br><span class="line">if(条件表达式)&#123;</span><br><span class="line">当条件表达式值为true时,执行此处代码</span><br><span class="line">&#125;else&#123;</span><br><span class="line">当条件表达式值为false时,执行此处代码</span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">1,else可有可无</span><br><span class="line">2,else只能有一个</span><br><span class="line">3,else不能单独存在</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">else if结构</span><br><span class="line">语法:</span><br><span class="line">if(条件表达式1)&#123;</span><br><span class="line">当条件表达式1为true,执行此处代码</span><br><span class="line">&#125;else if(条件表达式2)&#123;</span><br><span class="line">当条件表达式2为true,执行此处代码</span><br><span class="line">&#125;else if(条件表达式3)&#123;</span><br><span class="line">当条件表达式3为true,执行此处代码</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">else if(条件表达式n)&#123;</span><br><span class="line">当条件表达式n为true,执行此处代码</span><br><span class="line">&#125;else&#123;</span><br><span class="line">当以上条件全为false,执行此处代码</span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">else if可以有多个</span><br><span class="line">当上面的条件,将不会判断下面的条件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">if的语法:</span><br><span class="line">if(条件表达式1)&#123;</span><br><span class="line">当条件表达式1为true,执行此处代码</span><br><span class="line">&#125;else if(条件表达式2)&#123;</span><br><span class="line">当条件表达式2为true,执行此处代码</span><br><span class="line">&#125;else if(条件表达式3)&#123;</span><br><span class="line">当条件表达式3为true,执行此处代码</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">else if(条件表达式n)&#123;</span><br><span class="line">当条件表达式n为true,执行此处代码</span><br><span class="line">&#125;else&#123;</span><br><span class="line">当以上条件全为false,执行此处代码</span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">1,else if可以有多个</span><br><span class="line">2,else if可以一个都没有</span><br><span class="line">3,else if不能独立存在</span><br><span class="line">4,else 可有可无,最多只能有一个</span><br><span class="line">5,当多个条件同时满足时,只会执行最上面的那个</span><br></pre></td></tr></table></figure><h3 id="2-switch"><a href="#2-switch" class="headerlink" title="2.switch"></a>2.switch</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">switch(变量名)&#123;</span><br><span class="line">case 常量1:</span><br><span class="line">当变量值等于常量1时,执行此处代码</span><br><span class="line">int a;</span><br><span class="line">break;</span><br><span class="line">case 常量2:</span><br><span class="line">当变量值等于常量2时,执行此处代码</span><br><span class="line">break;</span><br><span class="line">...</span><br><span class="line">case 常量n:</span><br><span class="line">当变量值等于常量n时,执行此处代码</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">当变量值不等于以上常量时,执行的代码</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">常量:代码在编译后无法修改的值或变量称为常量</span><br><span class="line">break:跳出当前代码块,case中可以没有break,但是如果没有会导致贯穿</span><br><span class="line">swicth中case后的常量不能相同</span><br><span class="line">JDK1.5以后switch可以判断字符串内容是否相同</span><br><span class="line">switch只能判断值相等,if可以判断区间,也可以判断值是否相同</span><br></pre></td></tr></table></figure><p>变量的作用域</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念:变量声明的代码块,为这个变量的作用域(就是这个变量可以使用的范围)</span><br></pre></td></tr></table></figure><h3 id="3-输入：Scanner"><a href="#3-输入：Scanner" class="headerlink" title="3.输入：Scanner"></a>3.输入：Scanner</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简介:由JDK提供的一个类</span><br><span class="line">作用:键盘录入</span><br><span class="line">使用:</span><br><span class="line">1,导包</span><br><span class="line">语法:import java.util.Scanner;</span><br><span class="line">书写位置:类上</span><br><span class="line">2,创建Scanner对象</span><br><span class="line">语法:</span><br><span class="line">Scanner 变量名 = new Scanner(System.in);</span><br><span class="line">3,等待用户输入</span><br><span class="line">输入字符串</span><br><span class="line">String 变量名2 = 变量名.next();</span><br><span class="line">变量名2:就是用户输入的内容</span><br><span class="line">输入整数</span><br><span class="line">int 变量名2 = 变量名.nextInt();</span><br><span class="line">变量名2:就是用户输入的内容</span><br><span class="line">练习:</span><br><span class="line">键盘录入成绩判断其得分的区间</span><br></pre></td></tr></table></figure><h2 id="七、循环语句"><a href="#七、循环语句" class="headerlink" title="七、循环语句"></a>七、循环语句</h2><h3 id="1-while"><a href="#1-while" class="headerlink" title="1.while"></a>1.while</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">while(条件表达式)&#123;</span><br><span class="line">当条件表达式为true，执行此处代码i</span><br><span class="line">此处代码执行完毕后，判断条件表达式是否为true，为true，执行此处代码</span><br><span class="line">为false，结束循环</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-do-while"><a href="#2-do-while" class="headerlink" title="2.do-while"></a>2.do-while</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">do&#123;</span><br><span class="line">先执行此处代码,在判断条件表达式是否为true</span><br><span class="line">如果为true,在此执行此处代码</span><br><span class="line">如果为false结束循环</span><br><span class="line">&#125;while(条件表达式);</span><br></pre></td></tr></table></figure><h3 id="3-for"><a href="#3-for" class="headerlink" title="3.for"></a>3.for</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">for(表达式1;表达式2;表达式3)&#123;</span><br><span class="line">循环体4</span><br><span class="line">&#125;</span><br><span class="line">表达式1:初始化变量</span><br><span class="line">表达式2:循环条件</span><br><span class="line">表达式3:修改变量</span><br><span class="line">循环体4:重复执行的代码</span><br><span class="line">执行流程:</span><br><span class="line">1,2,4,3,2,4,3,2,4,3....2</span><br><span class="line">注意:表达式1只执行一次</span><br></pre></td></tr></table></figure><p>名词解释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">死循环；无法结束的循环</span><br><span class="line">循环嵌套：在循环语句中使用循环语句</span><br></pre></td></tr></table></figure><h3 id="4-转义字符"><a href="#4-转义字符" class="headerlink" title="4.转义字符"></a>4.转义字符</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念:有特殊含义的字符</span><br><span class="line"></span><br><span class="line">\t:制表</span><br><span class="line">\&quot;:双引号字符</span><br><span class="line">\&#x27;:单引号字符</span><br><span class="line">\n:换行</span><br><span class="line">\r\n:标准换行</span><br></pre></td></tr></table></figure><h3 id="5-流程控制语句"><a href="#5-流程控制语句" class="headerlink" title="5.流程控制语句"></a>5.流程控制语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break:跳出当前循环</span><br><span class="line"></span><br><span class="line">continue:跳过本次循环</span><br></pre></td></tr></table></figure><h2 id="八、方法（函数）"><a href="#八、方法（函数）" class="headerlink" title="八、方法（函数）"></a>八、方法（函数）</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">封装一段代码，使其便于使用</span><br></pre></td></tr></table></figure><h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2.优点"></a>2.优点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提高代码复用率</span><br><span class="line">降低代码耦合度</span><br><span class="line">提高代码编写效率</span><br><span class="line">方便使用</span><br></pre></td></tr></table></figure><h3 id="3-步骤"><a href="#3-步骤" class="headerlink" title="3.步骤"></a>3.步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.定义</span><br><span class="line">2.调用</span><br></pre></td></tr></table></figure><h3 id="4-定义"><a href="#4-定义" class="headerlink" title="4.定义"></a>4.定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">位置：</span><br><span class="line">类中，方法外</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">语法:</span><br><span class="line">访问权限修饰符 修饰符 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">访问权限修饰符:暂时使用public</span><br><span class="line">修饰符:暂时使用static</span><br><span class="line">返回值类型:就是返回值的数据类型.如果没有返回值,返回值类型为void.null表示为空</span><br><span class="line">方法名:自定义,见名知意,小驼峰.一个类中不能出现方法名相同,形参列表也相同的方法</span><br><span class="line">形参列表:可有可无</span><br><span class="line">本质:声明的多个变量,使用逗号隔开</span><br><span class="line">方法体:</span><br><span class="line">return:结束当前方法</span><br><span class="line">return xxx:结束当前方法,并返回xxx.注意此时返回值类型要与xxx的数据类型一致.只能返回一个</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-调用"><a href="#5-调用" class="headerlink" title="5.调用"></a>5.调用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">1,方法名(实参列表);</span><br><span class="line">2,数据类型 变量名 = 方法名(实参列表);</span><br><span class="line">注意:</span><br><span class="line">1,实参列表要与形参列表一致(长度一致,顺序一致,数据类型一致)</span><br><span class="line">2,调用无返回值的方法只能使用语法1</span><br><span class="line">3,调用有返回值的方法可以选择使用语法1也可以选择使用语法2</span><br></pre></td></tr></table></figure><h3 id="6-多重调用"><a href="#6-多重调用" class="headerlink" title="6.多重调用"></a>6.多重调用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法调用方法</span><br><span class="line">A,B,C三个方法</span><br><span class="line">A中调用B,在B中调用C</span><br></pre></td></tr></table></figure><h3 id="7-重载"><a href="#7-重载" class="headerlink" title="7.重载"></a>7.重载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要求:</span><br><span class="line">1,同一个类中</span><br><span class="line">2,方法名相同</span><br><span class="line">3,形参列表不同</span><br></pre></td></tr></table></figure><h3 id="8-递归"><a href="#8-递归" class="headerlink" title="8.递归"></a>8.递归</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法本身调用本身</span><br></pre></td></tr></table></figure><h2 id="九、数组"><a href="#九、数组" class="headerlink" title="九、数组"></a>九、数组</h2><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1.作用"></a>1.作用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存储一组数据类型相同的数据</span><br></pre></td></tr></table></figure><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.长度不可变</span><br><span class="line">2.存储的数据类型一致</span><br></pre></td></tr></table></figure><h3 id="3-步骤-1"><a href="#3-步骤-1" class="headerlink" title="3.步骤"></a>3.步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">声明/创建/使用</span><br></pre></td></tr></table></figure><h3 id="4-声明"><a href="#4-声明" class="headerlink" title="4.声明:"></a>4.声明:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">数据类型[] 数组名;</span><br><span class="line">数据类型 数组名[];</span><br></pre></td></tr></table></figure><h3 id="5-创建"><a href="#5-创建" class="headerlink" title="5.创建"></a>5.创建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">静态创建:</span><br><span class="line">语法:</span><br><span class="line">数据类型[] 数组名 = &#123;值1,值2,值3,值4,...值n&#125;;</span><br><span class="line">注意事项:</span><br><span class="line">1,必须在声明时创建</span><br><span class="line">2,其长度就是创建时值的个数</span><br><span class="line">动态创建:</span><br><span class="line">语法:</span><br><span class="line">带值</span><br><span class="line">数组名 = new 数据类型[]&#123;值1,值2,值3,...&#125;;</span><br><span class="line">注意:</span><br><span class="line">其长度就是创建时值的个数</span><br><span class="line">不带值</span><br><span class="line">数组名 = new 数据类型[长度];</span><br><span class="line"></span><br><span class="line">动态创建与静态创建的区别:</span><br><span class="line">1,静态创建必须在声明时创建,动态创建可以将声明与创建分开,也可以同时进行</span><br><span class="line">2,内存上来说</span><br><span class="line">静态创建的内存在常量区</span><br><span class="line">动态创建的内容在堆内存</span><br><span class="line">3,静态创建是在代码加载时分配的内存空间,动态创建是在代码运行时分配的空间</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">堆内存中的数据有默认值</span><br><span class="line">基本数据类型默认为0</span><br><span class="line">引用数据类型默认为null</span><br></pre></td></tr></table></figure><h3 id="6-使用"><a href="#6-使用" class="headerlink" title="6.使用"></a>6.使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本使用</span><br><span class="line">改</span><br><span class="line">修改指定位置的数据</span><br><span class="line">语法:</span><br><span class="line">数组名[下标] = 值;</span><br><span class="line">查</span><br><span class="line">查询数组长度</span><br><span class="line">语法:</span><br><span class="line">数组名.length</span><br><span class="line">查询数组指定位置的数据</span><br><span class="line">语法:</span><br><span class="line">数组名[下标]</span><br><span class="line">注意:</span><br><span class="line">下标要在取值范围内,否则会产生数组下标越界异常</span><br><span class="line"></span><br><span class="line">扩展</span><br><span class="line">遍历:将数组或集合中的数据逐个取出</span><br><span class="line">方式1:普通for循环</span><br><span class="line">方式2:foreach(只能做遍历)</span><br><span class="line">foreach语法:</span><br><span class="line">for(数据类型 变量名:要遍历的数组或集合)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">数据类型:遍历出的数据的数据类型</span><br><span class="line">变量名:就是遍历出的数据</span><br><span class="line">注意:foreach(增强for循环)在遍历时的速度是普通for的3倍</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制:</span><br><span class="line">将数组A中的数据,逐个复制到数组中</span><br><span class="line">思路:</span><br><span class="line">1,创建新数组</span><br><span class="line">注意:</span><br><span class="line">1,新数组长度等于老数组长度</span><br><span class="line">2,新数组的数据类型与老数组一致</span><br><span class="line">2,遍历老数组</span><br><span class="line">使用普通for循环</span><br><span class="line">3,将老数组的值取出,赋值给新数组对应的位置</span><br><span class="line"></span><br><span class="line">扩容:</span><br><span class="line">将数组变大</span><br><span class="line">思路:</span><br><span class="line">1,创建一个新数组</span><br><span class="line">注意:</span><br><span class="line">1,新数组长度大于老数组长度</span><br><span class="line">2,新数组的数据类型与老数组一致</span><br><span class="line">2,遍历老数组</span><br><span class="line">3,将老数组的值取出,赋值给新数组对应的位置</span><br><span class="line">4,将新数组赋值给老数组</span><br></pre></td></tr></table></figure><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念:将数组作为数据存储在数组中</span><br><span class="line">步骤:</span><br><span class="line">1,声明</span><br><span class="line">2,创建</span><br><span class="line">3,使用</span><br><span class="line">声明</span><br><span class="line">数据类型[][] 数组名;</span><br><span class="line">创建</span><br><span class="line">静态创建</span><br><span class="line">注意:声明与创建同时进行</span><br><span class="line">语法:</span><br><span class="line">数据类型[][] 数组名 = &#123;</span><br><span class="line">&#123;值1,值2,值3,...&#125;,</span><br><span class="line">&#123;值4,值5,..&#125;,</span><br><span class="line">&#123;值6,值7,值8,值9,...&#125;,</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">动态创建</span><br><span class="line">带值</span><br><span class="line">语法:</span><br><span class="line">数组名 = new 数据类型[][]&#123;</span><br><span class="line">&#123;值1,值2,值3,...&#125;,</span><br><span class="line">&#123;值4,值5,..&#125;,</span><br><span class="line">&#123;值6,值7,值8,值9,...&#125;,</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">不带值</span><br><span class="line">语法:</span><br><span class="line">数组名 = new 数据类型[x][y];</span><br><span class="line">x:二维数组中可容纳的一维数组的个数,必须在创建时说明</span><br><span class="line">y:一维数组中可容纳的元素的个数,可以不写</span><br><span class="line">注意:</span><br><span class="line">二维数组的长度指的是其中存储的一维数组的个数</span><br><span class="line"></span><br><span class="line">使用:</span><br><span class="line">改</span><br><span class="line">修改二维数组中指定的一维数组</span><br><span class="line">数组名[下标] = 新数组;</span><br><span class="line">注意:不能使用静态创建</span><br><span class="line">修改二维数组中指定的位置的元素</span><br><span class="line">数组名[x][y] = 新值;</span><br><span class="line">x:元素所在的一维数组在二维数组中的位置</span><br><span class="line">y:元素在一维数组中的位置</span><br><span class="line">查</span><br><span class="line">查询数组长度</span><br><span class="line">数组名.length</span><br><span class="line">查询二维数组中指定位置的一维数组</span><br><span class="line">数组名[下标];</span><br><span class="line">查询二维数组中指定位置的元素</span><br><span class="line">数组名[x][y]</span><br><span class="line">x:元素所在的一维数组在二维数组中的位置</span><br><span class="line">y:元素在一维数组中的位置</span><br><span class="line">遍历:</span><br><span class="line">思路:</span><br><span class="line">1,遍历二维数组,获取一维数组</span><br><span class="line">2,遍历一维数组</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:解决实参的长度必须与形参一致的问题</span><br><span class="line"></span><br><span class="line">语法:数据类型... 变量名</span><br><span class="line"></span><br><span class="line">使用位置:形参末尾使用</span><br><span class="line"></span><br><span class="line">注意:一个方法只能使用一个可变参数</span><br></pre></td></tr></table></figure><h1 id="十、面向对象"><a href="#十、面向对象" class="headerlink" title="十、面向对象"></a>十、面向对象</h1><h2 id="1-面向过程"><a href="#1-面向过程" class="headerlink" title="1.面向过程"></a>1.面向过程</h2><blockquote><p>面向过程(Procedure Oriented)是一种以过程为中心的编程思想，是一种自顶而下的编程模式。最典型的面向过程的编程语言就是C语言。</p><p>简单来说，面向过程的开发范式中，程序员需要把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。</p><p>就是说，在进行面向过程编程的时候，不需要考虑那么多，上来先定义一个函数，然后使用各种诸如if-else、for-each等方式进行代码执行。最典型的用法就是实现一个简单的算法，比如实现冒泡排序。</p><p>面向过程进行的软件开发，其代码都是流程化的，很明确的可以看出第一步做什么、第二步做什么。这种方式的代码执行起来效率很高。</p><p>但是，面向过程同时存在着代码重用性低，扩展能力差，后期维护难度比较大等问题。</p></blockquote><h2 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2.面向对象"></a>2.面向对象</h2><blockquote><p>面向对象（Object Oriented）的雏形，最早在出现在1960年的Simula语言中，当时的程序设计领域正面临着一种危机：在软硬件环境逐渐复杂的情况下，软件如何得到良好的维护？</p><p>面向对象程序设计在某种程度上通过强调可重复性解决了这一问题。目前较为流行的面向对象语言主要有Java、C#、C++、Python、Ruby、PHP等。</p><p>简单来说，面向对象的开发范式中，程序员将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。</p><p>就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。比如:想要造一辆车，上来要先把车的各种属性定义出来，然后抽象成一个Car类。</p><p>面向对象的编程方法之所以更加受欢迎，是因为他更加符合人类的思维方式。这种方式编写出来的代码扩展性、可维护性都很高。</p><p>与其实面向对象是一种开发范式，倒不如说面向对象是一种对现实世界的理解和抽象的方法。通过对现实世界的理解和抽象，在运用封装、继承、多态等方法，通过抽象出对象的方式进行软件开发。</p></blockquote><h2 id="3-对象"><a href="#3-对象" class="headerlink" title="3.对象"></a>3.对象</h2><blockquote><p>对象就是类的具体实例<br>概念：万事万物皆对象<br>生活中：客观存在的事物皆为对象<br>代码中：在代码中存在的事物</p></blockquote><h2 id="4-类"><a href="#4-类" class="headerlink" title="4.类"></a>4.类</h2><blockquote><p>概念：多个对象抽象其共同点形成的概念</p><p>代码中：创建对象的模板</p></blockquote><h2 id="5-类和对象的关系"><a href="#5-类和对象的关系" class="headerlink" title="5.类和对象的关系"></a>5.类和对象的关系</h2><blockquote><p>类是抽象的，概念的，代表一类事物</p><p>对象时具体的，实际的，代表一个具体事物</p><p>类是对象的模板，对象是类的一个个体，对应一个实例</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">生活中:先有对象,后有类</span><br><span class="line">代码中:先有类,后有对象</span><br><span class="line">一个类可以有多个对象.多个对象可以属于同一个类</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-类的定义与组成"><a href="#6-类的定义与组成" class="headerlink" title="6.类的定义与组成"></a>6.类的定义与组成</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1).定义"></a>1).定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">访问权限修饰符 class 类名&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">访问权限修饰符:</span><br><span class="line">暂时使用public或不写</span><br><span class="line">类名:</span><br><span class="line">1,同一个文件夹下类名不能相同</span><br><span class="line">2,大驼峰</span><br></pre></td></tr></table></figure><h3 id="2-组成"><a href="#2-组成" class="headerlink" title="2).组成"></a>2).组成</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.属性（全局变量，成员变量）</span><br><span class="line">作用：描述事物的静态特征</span><br><span class="line">位置：方法外，类内</span><br><span class="line">格式：权限修饰符 数据类型 属性名；</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法：</span><br><span class="line">作用：描述事物的行为（静态特征）</span><br><span class="line">位置：类中，方法外</span><br><span class="line">格式：</span><br><span class="line">权限修饰符  返回值类型  方法名（新参列表）&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">本质：特殊的方法</span><br><span class="line">作用：创建该类的对象</span><br><span class="line">定义位置：类中。方法外</span><br><span class="line">语法：</span><br><span class="line">访问权限修饰符  构造函数名（形参列表）&#123;</span><br><span class="line">            方法体</span><br><span class="line">&#125;  </span><br><span class="line">注意：</span><br><span class="line">1.构造函数没有返回值类型</span><br><span class="line">2.构造函数没有返回值</span><br><span class="line">3.构造函数名和类名一致</span><br><span class="line">4.使用new关键字调用</span><br><span class="line">5.如果一个类中有多个构造函数，那么这些构造函数为重载关系</span><br><span class="line">6.一个类一定会有一个构造函数，如果没有定义构造函数，系统将会提供无参构造器</span><br><span class="line">7.构造函数不能形成递归</span><br></pre></td></tr></table></figure><h4 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">成员变量：</span><br><span class="line">声明在类中，方法外</span><br><span class="line">有默认值，基本数据类型默认为0，引用数据类型默认为null</span><br><span class="line">作用域：当前类中</span><br><span class="line">生命周期：随着对象的创建而创建，随着所属对象的销毁而销毁</span><br><span class="line">局部变量：</span><br><span class="line">方法中</span><br><span class="line">没有默认值</span><br><span class="line">作用域:当前代码块中</span><br><span class="line">生命周期:随着方法调用而生成随着方法执行完毕而销毁</span><br></pre></td></tr></table></figure><h2 id="7-对象的创建与使用"><a href="#7-对象的创建与使用" class="headerlink" title="7.对象的创建与使用"></a>7.对象的创建与使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建</span><br><span class="line">语法：</span><br><span class="line">数据类型 对象名 = new 构造函数（实参列表）；</span><br><span class="line">构造函数：即为该对象所属的类名</span><br></pre></td></tr></table></figure><p>面试题：</p><blockquote><p>Cat cat &#x3D; new Cat();</p><p>1.使用new关键字在堆内存中开辟一片空间</p><p>2.给属性赋初值</p><p>3.执行构造函数中的代码</p><p>4.将堆地址赋值给栈中的引用</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用：</span><br><span class="line">获取属性值：</span><br><span class="line">对象名.属性名</span><br><span class="line">修改属性值</span><br><span class="line">    对象名.属性名 = 值；</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用：</span><br><span class="line">对象名.方法名（实参列表）</span><br></pre></td></tr></table></figure><h2 id="8-this"><a href="#8-this" class="headerlink" title="8.this"></a>8.this</h2><blockquote><p>含义：谁调用this所在的方法this就表示谁</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">场景一：局部变量与成员变量名称相同时，使用this区分</span><br><span class="line">成员变量(属性)</span><br><span class="line">this.属性名</span><br><span class="line">局部变量</span><br><span class="line">变量名</span><br><span class="line"></span><br><span class="line">就近使用原则</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">场景二：在本类方法中使用本类的属性或方法，默认用this调用。此时this可以忽略</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">场景三：本类构造函数中，调用本类其他构造函数</span><br><span class="line">语法:</span><br><span class="line">this(实参列表);</span><br><span class="line">注意:</span><br><span class="line">必须在构造函数第一行使用</span><br></pre></td></tr></table></figure><h1 id="十一-三大特征"><a href="#十一-三大特征" class="headerlink" title="十一.三大特征"></a>十一.三大特征</h1><h2 id="1-访问权限修饰符"><a href="#1-访问权限修饰符" class="headerlink" title="1.访问权限修饰符"></a>1.访问权限修饰符</h2><blockquote><p>作用:限制其修饰的内容使用范围</p><p>关键字:</p><p>public    公共的    当前项目可访问</p><p>protected    受保护的   当前包下或继承关系下可用</p><p>默认的   当前包下</p><p>private  私有的     当前类中可用</p></blockquote><h2 id="2-封装"><a href="#2-封装" class="headerlink" title="2.封装"></a>2.封装</h2><p>​<strong>定义</strong>:包装;封装就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，</p><p><strong>优点:</strong></p><pre><code>&gt;1.方便使用&gt;&gt;2.保护内部&gt;&gt;3.降低耦合度&gt;&gt;4.提高复用率</code></pre><p><strong>体现</strong></p><blockquote><p>变量:封装值或内存地址</p><p>方法:封装一段代码</p><p>类:封装多个属性,方法与构造函数</p><p>java中封装无处不在</p></blockquote><p><strong>包:</strong></p><blockquote><p>**本质:**src下的文件夹</p><p>**作用:**对java文件进行分类存储,使其便于寻找</p><p><strong>创建</strong>:  选择src—鼠标右键—new —package—填写包名</p><p><strong>包名:</strong>   规则:全小写</p><p>​潜规则:com.公司名或项目名.分类名</p><p><strong>注意:</strong></p><p>​.下一级文件夹</p><p>关键字:package,说明当前java文件所在的包</p></blockquote><p><strong>导包</strong></p><blockquote><p>作用:在当前java文件中使用其他文件夹下的类,此时需要导包<br>语法:<br>import 包名.类名;</p><p>位置:类上</p><p>关键字:import</p><p>*:所有</p></blockquote><p><strong>步骤</strong></p><blockquote><p>1.属性私有化</p><p>2.提供公共的set方法,用于对属性的判断并赋值</p><p>3.提供一个公共的get方法,用于获取属性值</p></blockquote><h2 id="3-继承"><a href="#3-继承" class="headerlink" title="3.继承"></a>3.继承</h2><p><strong>概念</strong></p><blockquote><p>生活中:晚辈继承长辈遗留下的精神或物质遗产</p><p>代码中:多个类抽取其共同点形成的类,此时该类与这几个类形成继承关系</p></blockquote><p><strong>优点</strong></p><blockquote><p>子类将拥有父类的所有属性和方法,构造函数除外</p><p>提高代码复用率</p></blockquote><p><strong>语法</strong></p><blockquote><p>访问权限修饰符   class  子类名  extends 父类名{</p><p>​属性</p><p>​方法</p><p>​构造函数</p><p>}</p><p>注意:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1.一个父类可以有多个子类</span><br><span class="line">&gt;2.一个子类只能有一个父类,单继承</span><br><span class="line">&gt;3.子类构造函数中默认调用父类无参构造函数</span><br><span class="line">&gt;4.子类构造函数中必须调用父类的构造函数,默认先调用父类的构造函数</span><br><span class="line">&gt;5.Object是所有类的父类,如果一个没有明确的父类,默认继承Object</span><br><span class="line">&gt;6.开闭原则:</span><br><span class="line">对修改关闭</span><br><span class="line">对扩展打开</span><br></pre></td></tr></table></figure></blockquote><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a><strong>重写</strong></h4><blockquote><p>在继承关系中,子类中的方法与父类的方法,方法名相同,形参列表相同.</p><p>子类的方法访问权限修饰符不能小于父类的子类</p><p>该方法返回值类型与父类一致.</p></blockquote><h4 id="super"><a href="#super" class="headerlink" title="super"></a><strong>super</strong></h4><p>​含义:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">谁调用super所在的方法,super就表示谁的父类对象</span><br><span class="line">代表父类的引用，用于访问父类的属性，方法，构造器</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">1.访问父类的属性,但不能访问父类的private属性,super.属性名,在子类方法中访问</span><br><span class="line">2.访问父类的方法,但不能访问父类的private方法,super.方法名(参数列表),在子类方法中访问</span><br><span class="line">3.访问父类的构造器,super(参数列表)只能放在子类构造器的第一句</span><br></pre></td></tr></table></figure><p><strong>使用场景:</strong></p><blockquote><p><strong>场景1</strong>:当子类重写了父类的方法后,在子类中使用super区分,在子类重写的方法还是父类的方法</p><p>​super.方法名(实参列表)     ——-父类提供</p><p>​方法名(实参列表) ——–子类重写的方法</p></blockquote><blockquote><p><strong>场景2</strong>:当子类属性名与父类属性名重名时,使用super区分</p><p>​super.属性名      父类属性</p><p>​属性名               子类属性</p></blockquote><blockquote><p>**场景3:**调用构造函数</p><p>​super(实参列表);—–只能在子类构造器第一行调用</p></blockquote><p><strong>细节:</strong></p><blockquote><ol><li><p>调用父类构造器的好处，（分工明确，父类属性由父类初始化，子类属性由子类初始化）</p></li><li><p>当子类中又有和 父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super，如果没有重名，使用super，this，直接访问效果一样</p></li></ol><p> super.方法名：直接查找父类，跳过本类查找</p><ol start="3"><li>super的访问不限于直接父类，如果爷爷类和本类中有同名成员，也可以使用super去访问爷爷类的成员，如果多个基类中有同名的成员，使用super遵循就近原则，也需要遵守权限规则。</li></ol></blockquote><p><strong>this与super</strong></p><blockquote><p>this:调用该方法的对象</p><p>super:调用该方法的父类对象</p></blockquote><h2 id="4-多态"><a href="#4-多态" class="headerlink" title="4.多态"></a>4.多态</h2><p><strong>概念:</strong>  </p><blockquote><p>一个事物的多种形态(方法或对象具有多种形态，多态建立在封装和继承的基础之上)</p></blockquote><h4 id="对象的多态"><a href="#对象的多态" class="headerlink" title="对象的多态"></a><strong>对象的多态</strong></h4><blockquote><p>子类对象转换为父类对象</p><p>​自动转换</p><p>​语法:               父类名    对象名  &#x3D;  子类对象;</p><p>父类对象转换为子类对象</p><p>​强制转换</p><p>​语法:         子类名    对象名   &#x3D;   (子类名)父类对象;</p><p>​注意:有风险</p></blockquote><h4 id="方法的多态"><a href="#方法的多态" class="headerlink" title="方法的多态:"></a><strong>方法的多态:</strong></h4><blockquote><p>重载:在同一个类中,方法名相同,形参列表不同</p><p>重写:在继承关系中,子类方法与父类方法,方法名相同,形参列表相同,返回值类型相同,访问权限修饰符不能减小</p><p>注意:当子类对象转换为父类对象后,调查重写的方法,依据执行的是子类重写后的方法.</p></blockquote><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><strong>instanceof</strong></h4><blockquote><p>作用:判断该对象是否属于该类</p><p>注意:判断的对象与类之间要存在关系</p><p>语法:</p><p>​boolean   变量名  &#x3D;  对象名  instanceof   类名;</p><p>如果为true,表示该对象属于该类</p><p>如果为false,表示该对象不属于该类</p></blockquote><h1 id="十二-、三大修饰符"><a href="#十二-、三大修饰符" class="headerlink" title="十二 、三大修饰符"></a>十二 、三大修饰符</h1><h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><blockquote><p>含义:抽象的,不可描述的</p><p>可以修饰类和方法</p><h4 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类:"></a><strong>修饰类:</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点:不能直接创建对象</span><br><span class="line">语法:</span><br><span class="line">访问权限修饰符  abstract class 类名&#123;</span><br><span class="line">属性</span><br><span class="line">方法</span><br><span class="line">构造函数</span><br><span class="line">&#125;</span><br><span class="line">名称:抽象类</span><br><span class="line">注意:</span><br><span class="line">1.抽象类中不一定有抽象方法</span><br><span class="line">2.子类继承抽象类,要么重写父类所有抽象方法,要么自己也是抽象类</span><br><span class="line">3.抽象类不能被实例化</span><br><span class="line">4.一旦包含抽象方法,则这个类必须声明为抽象类</span><br><span class="line">5.抽象类可以有任意成员,如非抽象方法,构造器,静态属性</span><br></pre></td></tr></table></figure><h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点:没有方法体</span><br><span class="line">语法:</span><br><span class="line">访问权限修饰符  abstract 返回值类型 方法名(形参列表);</span><br><span class="line">注意:</span><br><span class="line">1.有抽象方法的类一定是抽象类</span><br><span class="line">2.抽象类中可以有多个抽象方法</span><br><span class="line">3.抽象方法不能有主体,即不能实现</span><br><span class="line">4.抽象方法不能使用private，final，static来修饰，因为这些关键字都是和重写相违背的，final是不能继承的，static关键字和方法重写无关，private不能重写</span><br></pre></td></tr></table></figure></blockquote><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><blockquote><p>含义:最终的,不可修改的</p><p>可以修饰:变量,方法,类</p><h4 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a><strong>修饰变量</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰局部变量</span><br><span class="line">语法:</span><br><span class="line">final 数据类型 变量名 = 值;</span><br><span class="line">注意:只能赋值一次</span><br><span class="line"> final修饰的变量就是常量</span><br><span class="line">修饰成员变量</span><br><span class="line">语法:</span><br><span class="line">访问权限修饰符 final 数据类型 属性名 = 值;</span><br><span class="line">注意:</span><br><span class="line">1.final 修饰的属性必须是声明赋值时</span><br><span class="line">2.final 修饰的属性值不能被修改</span><br></pre></td></tr></table></figure><h4 id="修饰方法-1"><a href="#修饰方法-1" class="headerlink" title="修饰方法"></a>修饰方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:不能被重写</span><br><span class="line">语法:</span><br><span class="line">访问修饰符 final 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修饰类-1"><a href="#修饰类-1" class="headerlink" title="修饰类"></a>修饰类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:不能被继承,这种类被称为最终类</span><br><span class="line">语法: </span><br><span class="line">访问权限修饰符 final class 类名&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.不希望类被继承时,使用final修饰</span><br><span class="line">2.不希望父类的某个方法被子类覆盖/重写时可以使用final关键字</span><br><span class="line">3.当不希望类的某个属性的值被修改,就可以使用final修饰</span><br><span class="line">4.当不希望某个局部变量被修改,可以使用final修饰</span><br></pre></td></tr></table></figure><h4 id="细节"><a href="#细节" class="headerlink" title="细节:"></a>细节:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.final修饰的属性在定义时,必须赋初值,并且以后不能改变</span><br><span class="line">2.如果final修饰的属性是静态的,则初始化的位置只能是:在定义时,在静态代码块,不能在构造器中赋值</span><br><span class="line">3.final类不能继承,但可以实例化</span><br><span class="line">4.如果类不是final类,但是含有fianal方法,则该方法不能被重写,但可以被继承</span><br><span class="line">5.一般来说,一个类已经是final类了.则没必要讲方法修饰成final方法</span><br><span class="line">6.final不能修饰构造方法</span><br><span class="line">7.final 往往与static搭配使用,效率更高,底层编译做了优化处理,静态属性增加final后,调用静态属性,静态方法不再被调用.</span><br><span class="line">8.包装类,String也是final类</span><br></pre></td></tr></table></figure></blockquote><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><blockquote><p>含义:静态的,公共的</p><p>可以修饰:属性,方法,代码块,内部类</p><h4 id="修饰属性"><a href="#修饰属性" class="headerlink" title="修饰属性"></a>修饰属性</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点:该属性属于该类的所有对象,该类的一个对象对其进行修改,该类的所有对象的属性都会被修改</span><br><span class="line"></span><br><span class="line">可以使用类名直接调用.</span><br><span class="line">语法:</span><br><span class="line">访问权限修饰符  static 数据类型 属性名;</span><br></pre></td></tr></table></figure><h4 id="修饰方法-2"><a href="#修饰方法-2" class="headerlink" title="修饰方法"></a>修饰方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点:可以使用类名直接调用,也可以使用对象名调用</span><br><span class="line">语法:</span><br><span class="line">访问权限修饰符  static 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">1.不能使用this或super关键字</span><br><span class="line">2.不能直接使用本类中其他非静态属性或非静态方法</span><br><span class="line">3.可以直接使用本类的静态属性或静态方法</span><br><span class="line">4.非静态方法中可以直接使用静态属性或静态方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点:在类加载时被执行</span><br><span class="line">注意:一个类在程序运行时,只会被加载一次</span><br><span class="line">语法:</span><br><span class="line">static&#123;</span><br><span class="line">代码块</span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">1.静态代码快中可以使用静态属性与静态方法,不能直接使用非静态属性和非静态方法</span><br><span class="line">2.静态代码快与静态属性,谁在前,谁先执行,为了可以再静态代码快中使用静态属性,必须将静态属性声明在静态代码块之前</span><br><span class="line"></span><br><span class="line">类加载时机:该类第一次被执行使用时</span><br><span class="line">1.第一次创建该类对象时</span><br><span class="line">2.第一次使用该类调用属性时</span><br><span class="line">3.第一次使用该类调用方法时</span><br><span class="line">4.第一次使用反射机制加载该类时</span><br></pre></td></tr></table></figure><h4 id="继承关系中的执行流程"><a href="#继承关系中的执行流程" class="headerlink" title="继承关系中的执行流程"></a>继承关系中的执行流程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 父类的静态代码块和静态属性</span><br><span class="line">- 子类的静态代码快和静态属性</span><br><span class="line">- 父类的普通代码块和普通属性初始化</span><br><span class="line">- 父类的构造方法</span><br><span class="line">- 子类的普通代码块和普通属性初始化</span><br><span class="line">- 子类的构造方法</span><br></pre></td></tr></table></figure><h4 id="创建对象时-在一个类调用的顺序是"><a href="#创建对象时-在一个类调用的顺序是" class="headerlink" title="创建对象时,在一个类调用的顺序是:"></a>创建对象时,在一个类调用的顺序是:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）调用静态代码块和静态属性初始化（静态代码块和静态属性初始化的调用优先级一样，如果有多个静态代码块和多个静态变量初始化，则按照他们的顺序调用）</span><br><span class="line"></span><br><span class="line">2）调用普通代码块和普通属性的初始化（普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）</span><br><span class="line"></span><br><span class="line">3）调用构造方法</span><br></pre></td></tr></table></figure></blockquote><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><blockquote><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用:封装一段代码</p><p>使用位置:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类中方法外.每次创建该类对象时被调用</span><br><span class="line">注意:在构造函数之前执行</span><br><span class="line">普通属性与代码块按顺序执行</span><br></pre></td></tr></table></figure></blockquote><h1 id="十三-接口"><a href="#十三-接口" class="headerlink" title="十三.接口"></a>十三.接口</h1><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体的情况把这些方法写出来</p><h2 id="含义"><a href="#含义" class="headerlink" title="含义:"></a>含义:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">宏观:规则</span><br><span class="line">微观:功能</span><br></pre></td></tr></table></figure><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1.定义</span><br><span class="line">&gt;2.使用</span><br></pre></td></tr></table></figure></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;语法:</span><br><span class="line">访问权限修饰符  interface 接口名&#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&gt;组成:</span><br><span class="line">公共静态常量</span><br><span class="line">公共静态方法</span><br><span class="line">公共抽象方法</span><br><span class="line">default修饰的普通方法</span><br><span class="line">&gt;注意:公共静态方法和常量默认有public static final</span><br><span class="line">公共抽象方法包含:public abstract</span><br></pre></td></tr></table></figure></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1.接口使用接口</span><br><span class="line">通过多继承实现接口使用接口</span><br><span class="line">语法:</span><br><span class="line">public interface 子接口名 extends  父接口名1,父接口名2....&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">注意:不能继承父接口的静态方法,其他的均可继承</span><br><span class="line"></span><br><span class="line">&gt;2.类使用接口</span><br><span class="line">&gt;多实现:一个类可以实现多个接口</span><br><span class="line">&gt;语法:</span><br><span class="line">访问权限修饰符 class 子类名 extends 父类名 implements 父接口名1,父接口名2...&#123;&#125;</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">1.一个类可以实现多个接口</span><br><span class="line">2.子类要么重写所有接口提供的抽象方法,要么子类也是抽象类</span><br><span class="line">3.子类对象可以转换为多个实现的接口对象</span><br><span class="line">4.一个接口可以被多个类实现,所以多个类的对象可以转换为同一个接口的对象</span><br></pre></td></tr></table></figure></blockquote><h2 id="接口的特殊使用"><a href="#接口的特殊使用" class="headerlink" title="接口的特殊使用"></a>接口的特殊使用</h2><blockquote><p><strong>常量接口</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念:只有常量的接口</span><br><span class="line">public interface 接口名&#123;</span><br><span class="line">数据类型 常量名1 = 值;</span><br><span class="line">数据类型 常量名2 = 值;</span><br><span class="line">数据类型 常量名3 = 值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口回调</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念:接口对象回来调用接口方法</span><br><span class="line"></span><br><span class="line">实例:点击按钮</span><br><span class="line">按钮类</span><br><span class="line">点击事件接口</span><br><span class="line">环境类</span><br><span class="line">创建点击事件接口对象</span><br><span class="line">创建按钮对象,传入接口对象</span><br><span class="line">按钮对象,点击方法</span><br></pre></td></tr></table></figure></blockquote><h2 id="细节-1"><a href="#细节-1" class="headerlink" title="细节:"></a>细节:</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1.接口使用implements实现</span><br><span class="line">&gt;2.接口不能继承其他类,但可以继承其他接口(多继承)</span><br><span class="line">&gt;3.接口不能实例化</span><br><span class="line">&gt;4.接口的所有方法是public方法,接口中的抽象方法可以不用abstract修饰</span><br><span class="line">&gt;5.一个普通类实现接口,必须将该接口的方法都实现,或将自己定义为抽象类</span><br><span class="line">&gt;6.一个类可以同时实现多个接口</span><br><span class="line">&gt;7.接口中的属性,只能是final的,而且是public static final修饰符</span><br><span class="line">&gt;8.接口中属性的访问形式:接口名.属性名</span><br><span class="line">&gt;9接口的修饰符只能是public和默认的</span><br></pre></td></tr></table></figure></blockquote><h2 id="接口的多态"><a href="#接口的多态" class="headerlink" title="接口的多态"></a>接口的多态</h2><blockquote><p>接口存在多态传递,如果接口1继承了接口2,为类1实现了接口1,就相当于类1实现了接口2</p></blockquote><h1 id="十四-内部类"><a href="#十四-内部类" class="headerlink" title="十四.内部类"></a>十四.内部类</h1><p>作用:补全外部类功能</p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><blockquote><p>在类中定义的类称为内部类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class A&#123;</span><br><span class="line">public class B&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">A为外部类</span><br><span class="line">B为内部类</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.成员内部类</span><br><span class="line">位置:类中.方法外</span><br><span class="line">未使用static修饰</span><br><span class="line">2.静态内部类</span><br><span class="line">定义位置:类中.方法外</span><br><span class="line">使用static修饰</span><br><span class="line">3.局部内部类</span><br><span class="line">定义位置:类中,方法中</span><br><span class="line">4.匿名内部类</span><br><span class="line">定义位置:定义在外部类的成员位置上,或实参中</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-成员内部类"><a href="#3-成员内部类" class="headerlink" title="3.成员内部类"></a>3.成员内部类</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;可以加访问任何的访问权限修饰符,因为他也是成员</span><br><span class="line"></span><br><span class="line">&gt;成员内部类内部可定义:除去静态成员以外的成员都可以定义</span><br><span class="line">&gt;创建对象:</span><br><span class="line">情况1:在所在的外部类中创建该内部类对象</span><br><span class="line">内部类类名 对象名 = new 内部类类名(实参列表);</span><br><span class="line">注意:只是省略this关键字,所以这种创建方式不能再静态方法中使用.</span><br><span class="line">情况2:在其他类中创建该内部类对象</span><br><span class="line">外部类类名.内部类类名 对象名 = 外部类对象.new 内部类名(实参列表);</span><br></pre></td></tr></table></figure></blockquote><h3 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4.静态内部类"></a>4.静态内部类</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;使用static修饰</span><br><span class="line">&gt;静态内部类所有的成员都可以定义</span><br><span class="line">&gt;创建对象:</span><br><span class="line">外部类类名.内部类类名 对象名 = new 外部类类名.内部类类名(实参列表);</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-局部内部类"><a href="#5-局部内部类" class="headerlink" title="5.局部内部类"></a>5.局部内部类</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;注意:</span><br><span class="line">此时不能使用访问权限修饰符</span><br><span class="line">只能在当前方法中使用</span><br><span class="line">&gt;可以定义什么:</span><br><span class="line">除去静态成员,其他成员都可以</span><br><span class="line">&gt;创建对象:</span><br><span class="line">内部类类名 对象名 = new 内部类类名(实参列表);</span><br></pre></td></tr></table></figure></blockquote><h3 id="6-匿名内部类"><a href="#6-匿名内部类" class="headerlink" title="6.匿名内部类"></a>6.匿名内部类</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;概念:没有类名的内部类称为匿名内部类</span><br><span class="line">&gt;定义位置:定义在外部类的成员位置上,或实参中</span><br><span class="line">&gt;语法:</span><br><span class="line">new 父类名或父接口名()&#123;</span><br><span class="line">属性</span><br><span class="line">方法</span><br><span class="line">&#125;;</span><br><span class="line">&gt;注意:</span><br><span class="line">1.一个类只能创建一个对象时,可以使用匿名内部类</span><br><span class="line">2.不能定义静态成员与抽象方法,没有构造函数</span><br><span class="line">&gt;优点:</span><br><span class="line">1.编写方便</span><br><span class="line">&gt;缺点:</span><br><span class="line">2.代码混乱,降低代码可读性</span><br></pre></td></tr></table></figure><p>细节:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1.可以直接访问外部类的所有成员,包含私有</span><br><span class="line">&gt;2.不能添加访问修饰符,他是一个局部变量</span><br><span class="line">&gt;3.作用域:定义他的方法或代码快</span><br><span class="line">&gt;4.如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类成员，则可以使用（外部类.this.成员）</span><br></pre></td></tr></table></figure></blockquote><h1 id="十五-包装类"><a href="#十五-包装类" class="headerlink" title="十五.包装类"></a>十五.包装类</h1><p>八个基本数据类型所对应的引用数据类型</p><p>包装类:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte ----Byte</span><br><span class="line">short----Short</span><br><span class="line">int------Integer</span><br><span class="line">long-----Long</span><br><span class="line">float----Float</span><br><span class="line">double---Double</span><br><span class="line">boolean--Booleab</span><br><span class="line">char-----Character</span><br></pre></td></tr></table></figure><p>提供的方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parsexxx();</span><br><span class="line">将相应的包装类转换成基本数据类型</span><br></pre></td></tr></table></figure><p>整数缓冲区</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-128~127</span><br><span class="line">原因:</span><br><span class="line">因为系统中已经创建了-128~127之间有数的对象,在使用自动装箱时,如果值是在该范围内,直接使用已经创建好的对象,如果超过这个返回需要重新创建对象</span><br></pre></td></tr></table></figure><h1 id="十六-System"><a href="#十六-System" class="headerlink" title="十六.System"></a>十六.System</h1><p>由JDK提供的类</p><p>提供属性或方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static native void arraycopy(Object src,int  srcPos,</span><br><span class="line">                          Object dest, int destPos,</span><br><span class="line">                          int length)</span><br><span class="line">作用:将原数组中的一段数据复制到新数组</span><br><span class="line">1参:原数组</span><br><span class="line">2参:复制开始的位置</span><br><span class="line">3参:新数组</span><br><span class="line"> 4参:新数组开始的位置</span><br><span class="line"> 5参:复制的长度</span><br><span class="line"> </span><br><span class="line">static native long currentTimeMillis()</span><br><span class="line">作用:获取当前时间与1970年1月1日00:00:00:000的时间差(格林威治时间)</span><br><span class="line"></span><br><span class="line">static void exit(int status)</span><br><span class="line">作用:结束当前程序</span><br><span class="line">1参:终止状态码</span><br><span class="line">0:正常退出</span><br><span class="line">1:异常退出</span><br><span class="line"></span><br><span class="line">static void gc()</span><br><span class="line">作用:手动调用垃圾回收机制</span><br></pre></td></tr></table></figure><h1 id="十七-Object"><a href="#十七-Object" class="headerlink" title="十七.Object"></a>十七.Object</h1><p>概念：所有类的父类</p><p>意味：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">该类提供的属性与方法是所有类的对象都可以使用</span><br></pre></td></tr></table></figure><p>提供的方法</p><h2 id="1-equals"><a href="#1-equals" class="headerlink" title="1.equals"></a>1.equals</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object obj)</span><br><span class="line">作用:判断调用该方法的对象与传入的对象的内存地址是否相同</span><br><span class="line">如果子类重写该方法,使用子类对象调用该方法执行的是重写的代码</span><br><span class="line">如果要比较子类的对象属性值是否相同,要重写equals方法</span><br><span class="line">重写步骤:</span><br><span class="line">1.判断内存地址是否相同</span><br><span class="line">2.判断传入的对象是否属于该类对象</span><br><span class="line">3.将传入的对象转换为该类对象(父类转子类对象)</span><br><span class="line">4.使用调用该方法的对象的属性与传入的对象属性一一比较</span><br></pre></td></tr></table></figure><h2 id="2-toString"><a href="#2-toString" class="headerlink" title="2.toString"></a>2.toString</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String toString()</span><br><span class="line">作用:获取对象的包名.类拼接@字符串,再拼接对象的内存地址的16进制</span><br><span class="line">注意:</span><br><span class="line">1.Object提供的toString方法返回的是对象的包名.类@对象内存地址的16进制,可以理解为是对象的信息,但是我们在观察对象时,想看到的是对象的属性值,所以我们可以在子类中重写toString方法,重写后对象在调用toString方法,执行的是重写后的toString方法.</span><br><span class="line">2.重写toString方法,打印对象或拼接对象时,都会自动调用该对象的toString方法</span><br><span class="line">3.直接输出一个对象时,toString方法会被默认调用</span><br></pre></td></tr></table></figure><h2 id="3-hashCode"><a href="#3-hashCode" class="headerlink" title="3.hashCode"></a>3.hashCode</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:获取对象的哈希码值,近似可以理解为对象的内存地址</span><br><span class="line">注意:</span><br><span class="line">1.提高具有哈希结构的容器的效率</span><br><span class="line">2.两个引用,如果指定的是同一个对象,则哈希值肯定是一样的</span><br><span class="line">3.两个引用,如果指向的是不同的对象,则哈希值是不一样的</span><br><span class="line">4.哈希值主要根据地址号来的,不能完全等价于地址</span><br></pre></td></tr></table></figure><h2 id="4-finalize"><a href="#4-finalize" class="headerlink" title="4.finalize"></a>4.finalize</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:系统回收该对象的内存时,才会被调用</span><br><span class="line">注意:</span><br><span class="line">1.当对象被回收时,系统自动调用该对象的finalize方法,子类可以重写该方法做一些释放资源的操作</span><br><span class="line">2.当某个对象没有任何引用时,则jvm就认为这个对象是一个垃圾对象,就会使用垃圾回收机制来销毁对象,在销毁前,就先调用finalize</span><br><span class="line">3.垃圾回收机制的调用,是由系统来决定的,也可以通过System.gc主动触发垃圾回收机制</span><br></pre></td></tr></table></figure><h2 id="5-Math"><a href="#5-Math" class="headerlink" title="5.Math"></a>5.Math</h2><p>作用:数学运算与随机数</p><p>提供的方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static double random();</span><br><span class="line">作用:随机获取0-1之间的数</span><br><span class="line">使用:要想获得特定区间的随机数,random*区间最大值+1;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int abs(int a);</span><br><span class="line">作用:获取其指定数据的绝对值</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static double floor(double a);</span><br><span class="line">作用:向下取整</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static double ceil(double a);</span><br><span class="line">作用:向上取整</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int max(int a , int b)</span><br><span class="line">作用:获取两数之间的最大值</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int min(int a , int b);</span><br><span class="line">作用:获取两束之间的最小值</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static double pow(double a,double b)</span><br><span class="line">作用:计算a的b次幂</span><br></pre></td></tr></table></figure><h2 id="6-字符串"><a href="#6-字符串" class="headerlink" title="6.字符串"></a>6.字符串</h2><h3 id="6-1String"><a href="#6-1String" class="headerlink" title="6.1String"></a>6.1String</h3><blockquote><p><strong>细节:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.String用于保存字符串,也是一组字符序列</span><br><span class="line">2.字符串常量对象是用双引号括起来的字符序列</span><br><span class="line">3.字符串的字符使用Unicode字符编码,一个字符占两个字节</span><br><span class="line">4.String 实现了很多构造器,构造器重载</span><br><span class="line">5.String是fianl类不能被继承</span><br><span class="line">6.Stirng保存字符串时保存在private final char value[];</span><br><span class="line">7.value是final类型,赋值后不能修改(地址不能修改,值可以修改),一个字符串对象一旦分配,其内容是不可变的,指向改变</span><br><span class="line">8.String 这个类实现了Serializable,说明String可以串行化,可以网络传播</span><br><span class="line">9.String这个类实现了Comparable,说明String对象可以比较</span><br></pre></td></tr></table></figure><p><strong>创建方式:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.直接赋值</span><br><span class="line">String s = &quot;hhhh&quot;;</span><br><span class="line">先从常量池查看是否有&quot;hhhhhh&quot;数据空间,如果有,直接指向:如果没有,则重新创建,然后指向,s最终指向的是常量池的地址空间</span><br><span class="line">2.调用构造器</span><br><span class="line">String s = new String(&quot;xxxx&quot;);</span><br><span class="line">先从堆中创建空间,里面维护了value属性,指向常量池的&quot;xxxx&quot;的空间,如果常量池没有&quot;xxxx&quot;重新创建,如果有,直接通过value指向,最终指向的是堆中的空间</span><br></pre></td></tr></table></figure><p><strong>常见方法:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replace</span><span class="params">(String old,String newStr)</span></span><br><span class="line">作用:替换</span><br><span class="line"><span class="number">1</span>参:要被替换的字符串</span><br><span class="line"><span class="number">2</span>参:替换后的字符串</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span></span><br><span class="line">作用:获取字符串长度</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">作用:获取字符串中指定位置的字符</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">char</span>[] toCharArray()</span><br><span class="line">作用:将字符串转换为字符数组</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span></span><br><span class="line">作用:比较字符串内容是否相同</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String anotherString)</span></span><br><span class="line">作用:忽略大小写比较字符串内容是否相同</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">trim</span><span class="params">()</span></span><br><span class="line">作用:忽略前后空白</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">(String suffix)</span></span><br><span class="line">作用:判断字符串是否以指定的字符串结束</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span></span><br><span class="line">作用:判断字符串以什么开始</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toUpperCase</span><span class="params">()</span></span><br><span class="line">作用:将字符串中的小写字母转换为大写字母</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toLowerCase</span><span class="params">()</span></span><br><span class="line">作用:将字符串中的大写字母转换为小写字母</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String s)</span></span><br><span class="line">作用:判断s是否在调用该方法的字符串中存在</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str)</span></span><br><span class="line">作用:获取指定的子字符串在字符串中最后一次出现的位置</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span></span><br><span class="line">作用:获取指定的子字符串在字符串中第一次出现的位置</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span></span><br><span class="line">作用:截取指定位置的字符串,从开始位置到字符串末尾</span><br><span class="line">beginIndex:开始位置</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex , <span class="type">int</span> endIndex)</span></span><br><span class="line">作用:截取指定位置的字符串</span><br><span class="line"><span class="number">1</span>参:开始位置</span><br><span class="line"><span class="number">2</span>参:结束位置</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex)</span><br><span class="line">作用:切割</span><br><span class="line"><span class="number">1</span>参:按什么字符串切割</span><br></pre></td></tr></table></figure><p>构造函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[])</span></span><br><span class="line">将传入的字符数组转换为字符串</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[],<span class="type">int</span> offset,<span class="type">int</span> count)</span></span><br><span class="line">在<span class="type">char</span>数组中,从offset开始截取count位字符</span><br></pre></td></tr></table></figure></blockquote><h3 id="6-2StringBuffer和StringBuilder"><a href="#6-2StringBuffer和StringBuilder" class="headerlink" title="6.2StringBuffer和StringBuilder"></a>6.2StringBuffer和StringBuilder</h3><p><strong>长度可变</strong></p><h4 id="1-StringBuffer"><a href="#1-StringBuffer" class="headerlink" title="1.StringBuffer"></a>1.StringBuffer</h4><p>​特点:jdk1.0出现,线程安全的,效率低</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuffer是一个容器</span><br><span class="line">1.StringBuffer的直接父类是AbstractStringBuilder</span><br><span class="line">2.StringBuffer实现了Serializable,即StringBuffer的对象可以串行化</span><br><span class="line">3.在父类中有一个属性char[] value,不是final</span><br><span class="line">4.该value数组中存放字符串内容,引出存放在堆中的StringBuffer是一个public final class,所以StringBuffer不能被继承</span><br><span class="line">5.因为StringBuffer字符内容是存在char[]value,所以增加和删除不用每次都更换地址,即每次都创建新的对象,故效率高于String</span><br></pre></td></tr></table></figure><h4 id="2-StringBuilder"><a href="#2-StringBuilder" class="headerlink" title="2.StringBuilder"></a>2.StringBuilder</h4><p>特性:JDK1.5出现,线程不安全,效率高</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.一个可变字符序列,此类提供了一个与StringBuffer兼容的API,但不保证同步(StringBuilder不是线程安全的),该类被设计用做StringBuffer的一个简易替换,用在字符串缓存区被单个线程使用的时候,如果可能,简易有先采用StringBuilder,在大多数实现中,他比StringBuffer要快</span><br><span class="line">2.在StringBuilder上主要操作的是append和insert方法,可重载这些方法,以便于接受任意类型的数据</span><br><span class="line">3.单线程的情况下使用StringBuilder</span><br></pre></td></tr></table></figure><h4 id="3-提供的方法"><a href="#3-提供的方法" class="headerlink" title="3.提供的方法"></a>3.提供的方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.StringBuilder append(Object obj)</span><br><span class="line">作用:给字符串尾部拼接字符串</span><br><span class="line">2.StringBuilder insert(int offset , String str)</span><br><span class="line">作用:插入</span><br><span class="line">1参:插入开始的位置</span><br><span class="line">2参.插入的数据</span><br><span class="line">3.StringBuilder delete(int start,int end)</span><br><span class="line">作用:删除指定区间的数据</span><br><span class="line">1参:开始位置,包含</span><br><span class="line">2餐:结束位置,不包含</span><br><span class="line">4.StringBuilder deleteCharAt(int index)</span><br><span class="line">作用:删除指定位置的字符</span><br><span class="line">1参:指定位置</span><br><span class="line">5.StringBuilder replace(int start ,int end,String str)</span><br><span class="line">作用:替换</span><br><span class="line">1.参:要替换的数据的开始位置,包含</span><br><span class="line">2.参:要替换的数据的结束位置,不包含</span><br><span class="line">3.替换后的字符串</span><br><span class="line">6.toString()</span><br><span class="line">作用:将可变字符转换为不可变字符</span><br><span class="line">StringBuffer str = new StringBuffer();</span><br><span class="line">String s = str.toString();</span><br><span class="line"></span><br><span class="line">不可变字符转可变字符</span><br><span class="line">String str = &quot;hello&quot;;</span><br><span class="line">StringBuffer s = new StringBuffer(str);</span><br></pre></td></tr></table></figure><h1 id="十八-BigDecimal和BigInteger"><a href="#十八-BigDecimal和BigInteger" class="headerlink" title="十八.BigDecimal和BigInteger"></a>十八.BigDecimal和BigInteger</h1><h2 id="1-BigDeciamal"><a href="#1-BigDeciamal" class="headerlink" title="1.BigDeciamal"></a>1.BigDeciamal</h2><p>适合保存精度更高的浮点型</p><p>构造函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BigDeciaml(Object obj);</span><br></pre></td></tr></table></figure><p>提供方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BigDecimal subtract(BigDecimal subtrahend)</span><br><span class="line">作用:减法,使用调用该方法的对象的值减去传入的对象的值,返回计算结果</span><br><span class="line">BigDecimal add(BigDecimal augend)</span><br><span class="line">作用:加法</span><br><span class="line">BigDeciamal multiply(BigDecimal multiplicand)</span><br><span class="line">作用:乘法</span><br><span class="line">BigDeciaml divide(BigDecimal divisor)</span><br><span class="line">作用:除法</span><br><span class="line">xxx xxxValue();</span><br><span class="line">作用:获取BigDeciaml的值</span><br></pre></td></tr></table></figure><h2 id="2-BigInterger"><a href="#2-BigInterger" class="headerlink" title="2.BigInterger"></a>2.BigInterger</h2><p>BigInteger适合保存比较大的整型</p><p>方法同上</p><h1 id="十九-时间相关类"><a href="#十九-时间相关类" class="headerlink" title="十九.时间相关类"></a>十九.时间相关类</h1><h2 id="1-Date"><a href="#1-Date" class="headerlink" title="1.Date"></a>1.Date</h2><p>概念:日期</p><p>创建</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public Date();获取当前系统时间</span></span><br><span class="line"><span class="comment">//public Date(long date);</span></span><br><span class="line"><span class="comment">//获取距离1970年1月1日00.00.00的时间,单位毫秒</span></span><br><span class="line"></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(date1);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>()默认输出的格式为国外</span><br><span class="line">就需要格式转换,通过创建SimpleDateFormat对象可以指定格式: yyyy年MM月dd日  hh:mm:ss E</span><br><span class="line">E代表星期中的天数</span><br><span class="line"></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);</span><br></pre></td></tr></table></figure><p>​format:将时间对象转换为指定格式的字符串<br>​parse:将指定格式的字符串转换为时间</p><p>before,after</p><h2 id="2-Calendar"><a href="#2-Calendar" class="headerlink" title="2.Calendar"></a>2.Calendar</h2><p>概念:日历</p><p>创建</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static Calender getInstance()</span><br></pre></td></tr></table></figure><p>方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get</span><br><span class="line">System.out.println(&quot;年&quot;+instance.get(Calendar.YEAR));</span><br><span class="line">System.out.println(&quot;月&quot;+(instance.get(Calendar.MONTH)+1));//Calender&#x27;是按照0开始编号</span><br><span class="line">System.out.println(&quot;日&quot;+instance.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">System.out.println(&quot;小时&quot;+instance.get(Calendar.HOUR));</span><br><span class="line">System.out.println(&quot;分钟&quot;+instance.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(&quot;秒&quot;+instance.get(Calendar.SECOND));</span><br><span class="line">set</span><br><span class="line">add</span><br><span class="line">getTime</span><br></pre></td></tr></table></figure><h2 id="3-第三代时间"><a href="#3-第三代时间" class="headerlink" title="3.第三代时间"></a>3.第三代时间</h2><p>在JDK8中加入了LocalDate(日期)，LocalTime(时间)，LocalDateTime（日期时间）</p><ul><li><p>LocalDate只包含日期，可以获取日期字段</p></li><li><p>LocalTime只包含时间，可以获取时间字段</p></li><li><p>LocalDateTime包含日期+时间，可以获取日期和时间字段</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用now返回表示当前时间的对象</span></span><br><span class="line">   <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">   System.out.println(now);</span><br><span class="line">   System.out.println(<span class="string">&quot;年:&quot;</span>+now.getYear());</span><br><span class="line">   System.out.println(<span class="string">&quot;月:&quot;</span>+now.getMonth());</span><br><span class="line">   System.out.println(<span class="string">&quot;月:&quot;</span>+now.getMonthValue());</span><br><span class="line">   System.out.println(<span class="string">&quot;日:&quot;</span>+now.getDayOfMonth());</span><br><span class="line">   System.out.println(<span class="string">&quot;时:&quot;</span>+now.getHour());</span><br><span class="line">   System.out.println(<span class="string">&quot;分:&quot;</span>+now.getMinute());</span><br><span class="line">   System.out.println(<span class="string">&quot;秒:&quot;</span>+now.getSecond());</span><br><span class="line"></span><br><span class="line"> <span class="comment">//可以获取年月日</span></span><br><span class="line">   <span class="type">LocalDate</span> <span class="variable">now1</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">   System.out.println(now1.getYear());</span><br><span class="line">   <span class="comment">//可以获取时分秒</span></span><br><span class="line">   <span class="type">LocalTime</span> <span class="variable">now2</span> <span class="operator">=</span> LocalTime.now();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//使用DateTimeFormatter  格式日期类</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now3</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日  HH时mm分ss秒&quot;</span>);</span><br><span class="line">String str=dateTimeFormatter.format(now3);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><h1 id="二十-泛型"><a href="#二十-泛型" class="headerlink" title="二十.泛型"></a>二十.泛型</h1><p>作用:将数据类型作为参数传递</p><p>语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义:</span><br><span class="line">&lt;泛型1,泛型2...&gt;</span><br><span class="line">情况1:在方法上</span><br><span class="line">访问权限修饰符 修饰符 &lt;泛型1,泛型2...&gt; 返回值类型 方法名(形参列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">情况2:在类上定义</span><br><span class="line">    访问权限修饰符 class 类名&lt;泛型1,泛型2...&gt;&#123;&#125;</span><br><span class="line"> </span><br><span class="line"> 使用:</span><br><span class="line"> 泛型名</span><br><span class="line"> 情况1:在方法中使用</span><br><span class="line"> 在方法中任意使用数据类型的地方都可以使用该泛型作为数据类型</span><br><span class="line"> 情况2:在类中使用</span><br><span class="line">        在类中任意使用数据类型的地方都可以使用该泛型作为数据类型</span><br></pre></td></tr></table></figure><p>注意:<strong>泛型中只能使用引用数据类型</strong></p><h1 id="二十一-集合"><a href="#二十一-集合" class="headerlink" title="二十一.集合"></a>二十一.集合</h1><h3 id="1-作用-2"><a href="#1-作用-2" class="headerlink" title="1.作用"></a>1.作用</h3><blockquote><p>动态的存储一组数据类型相同的数据</p></blockquote><h3 id="2-特点-1"><a href="#2-特点-1" class="headerlink" title="2.特点"></a>2.特点</h3><blockquote><p>长度可变</p></blockquote><h3 id="3-名称"><a href="#3-名称" class="headerlink" title="3.名称"></a>3.名称</h3><blockquote><p>长度:集合中存在的元素个数</p><p>下标:元素在集合中的位置</p><p>元素:集合中存储的数据</p></blockquote><h3 id="4-体系结构"><a href="#4-体系结构" class="headerlink" title="4.体系结构"></a>4.体系结构</h3><blockquote><h2 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1.Collection"></a>1.Collection</h2><p>分类:List,Set</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;List</span><br><span class="line">特点:有序(存入和取出顺序一致),由下标,可以重复</span><br><span class="line">子类:</span><br><span class="line">ArrayList:</span><br><span class="line">特点:JDK1.2出现,线程不安全的</span><br><span class="line">数据结构:数组</span><br><span class="line">特点:查询效率高,增删效率低</span><br><span class="line">LinkedList</span><br><span class="line">      特点:查询效率低,增删效率高</span><br><span class="line">      数据结构:链表</span><br><span class="line">   Vector:</span><br><span class="line">      特点:JDK1.0出现,线程安全</span><br><span class="line">      数据结构:数组</span><br><span class="line">      </span><br><span class="line">&gt;Set</span><br><span class="line">特点:无序,无下标,元素不允许重复</span><br><span class="line">子类:</span><br><span class="line">HashSet</span><br><span class="line">底层:HashMap</span><br><span class="line">数据结构:</span><br><span class="line">JDK1.8以前数组+链表</span><br><span class="line">JDK1.8之后数组+链表+红黑树</span><br><span class="line">TreeSet</span><br><span class="line">      数据结构:红黑树</span><br><span class="line">      注意:指定比较规则</span><br><span class="line">  LinkedHashSet</span><br><span class="line">      特点:有序</span><br><span class="line">      数据结构:数组+双向链表</span><br></pre></td></tr></table></figure></blockquote><h2 id="Collection提供的方法"><a href="#Collection提供的方法" class="headerlink" title="Collection提供的方法"></a>Collection提供的方法</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;增:</span><br><span class="line">boolean add(E e)</span><br><span class="line">作用:一次添加一个数据</span><br><span class="line">参数:要添加的数据</span><br><span class="line">返回值:是否添加成功</span><br><span class="line">boolean addAll(Collection&lt;? extends E&gt; c);</span><br><span class="line">作用:一次添加一组数据</span><br><span class="line">参数:要添加的数据集合</span><br><span class="line">返回值:</span><br><span class="line">是否添加成功,哪怕只添加一个也算成功,全部失败才是失败</span><br><span class="line"></span><br><span class="line">&gt;删:</span><br><span class="line">boolean remove(Object o)</span><br><span class="line">作用:一次删除一个数据</span><br><span class="line">参数:要删除的数据</span><br><span class="line">返回值:是否删除成功</span><br><span class="line">注意:如果集合中有多个要删除的数据,智能删除第一个</span><br><span class="line">boolean removeAll(Collection&lt;?&gt; c)</span><br><span class="line">作用:一次删除一组数据</span><br><span class="line">参数:要删除的数据集合</span><br><span class="line">返回值:是否删除成功</span><br><span class="line">注意:如果原集合中多次出现删除集合中的数据,那么元集合中的该数据会全部被删除</span><br><span class="line">&gt;void clear()</span><br><span class="line">作用:清空集合中的数据</span><br><span class="line">&gt;查:</span><br><span class="line">int size()</span><br><span class="line">作用:查询集合长度</span><br><span class="line">boolean contains(Object o);</span><br><span class="line">作用:判断集合中是否包含指定元素</span><br><span class="line">&gt;boolean containsAll(Collection&lt;?&gt; C)</span><br><span class="line">作用:判断集合中是否全部包含指定的集合中的元素</span><br><span class="line">注意:判断的是是否全部包含</span><br><span class="line">&gt;boolean isEmpty();</span><br><span class="line">作用:判断集合是否为空集合</span><br><span class="line">注意:空集合表示集合中没有元素,而不是集合为null</span><br><span class="line">&gt;Iterator&lt;E&gt; Iterator()</span><br><span class="line">作用:获取当前集合的迭代器</span><br><span class="line">迭代器方法:</span><br><span class="line">boolean hasNext();判断下一个是否有值</span><br><span class="line">E next(); 移动游标,并返回指向的数据</span><br></pre></td></tr></table></figure><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;遍历:</span><br><span class="line">迭代器</span><br><span class="line">foreach</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-List提供的方法"><a href="#5-List提供的方法" class="headerlink" title="5.List提供的方法"></a>5.List提供的方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增:</span><br><span class="line">void add(int index, E element)</span><br><span class="line">作用:给指定位置插入一个数据</span><br><span class="line">    void addAll(int index,Collection&lt;E&gt; C)</span><br><span class="line">    作用:给指定位置插入一组数据</span><br><span class="line">    </span><br><span class="line">删:</span><br><span class="line">E remove(int index)</span><br><span class="line">作用:删除指定位置的数据</span><br><span class="line"></span><br><span class="line">改:</span><br><span class="line">E set(int index,E element)</span><br><span class="line">作用:修改指定位置的元素</span><br><span class="line">参数:1参,指定的位置;2参,修改后的元素</span><br><span class="line"></span><br><span class="line">查:</span><br><span class="line">E get(int index)</span><br><span class="line">作用:获取指定位置的元素</span><br></pre></td></tr></table></figure><h3 id="6-HashSet的剔重原理"><a href="#6-HashSet的剔重原理" class="headerlink" title="6.HashSet的剔重原理"></a>6.HashSet的剔重原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.存入对象先判断对象的hashCode值是否与已经存储的数据hashcode值是否相同</span><br><span class="line">2.如果相等,在使用本次存入的对象与集合中的对象使用equals方法一一比较</span><br><span class="line">3.如果equals也相同,认为对象已经存储,将不再存入该对象</span><br></pre></td></tr></table></figure><h3 id="7-TreeSet存储"><a href="#7-TreeSet存储" class="headerlink" title="7.TreeSet存储"></a>7.TreeSet存储</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeSet存储的数据</span><br><span class="line">要么拥有比较性(让存储的对象的类实现Comparable)</span><br><span class="line">要么指定比较器(创建TreeSet传入Comparator对象)</span><br></pre></td></tr></table></figure><h1 id="二十二-Map"><a href="#二十二-Map" class="headerlink" title="二十二.Map"></a>二十二.Map</h1><h3 id="1-作用-3"><a href="#1-作用-3" class="headerlink" title="1.作用:"></a>1.作用:</h3><p>​存储一组键值对应的数据类型的数据</p><h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h3><blockquote><p>名称</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">键:key</span><br><span class="line">值:value</span><br></pre></td></tr></table></figure><p>体系结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map</span><br><span class="line">HashMap</span><br><span class="line">特点:使用键值对的中键的hashcode值进行排序,允许空键空值,JDK1.2,线程不安全的</span><br><span class="line">Hashtable</span><br><span class="line">特点:使用键值对的中键的hashcode值进行排序,不允许空键空值,JDK1.0,线程安全的</span><br><span class="line">TreeMap</span><br><span class="line">特点:要求键要么拥有比较性,要么指定key的比较器</span><br><span class="line">Properties</span><br><span class="line">特点:HashMap的子类,可以加载读取文件中的内容,也可以向文件中写入内容</span><br><span class="line">注意:</span><br><span class="line">key值不能重复</span><br></pre></td></tr></table></figure><p>Map提供的方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增</span><br><span class="line">V put(K key, V value);</span><br><span class="line">作用:添加</span><br><span class="line">注意:</span><br><span class="line">如果map中不存在该key,返回值为null</span><br><span class="line">如果map中存在该key那么此时就是替换,返回被替换的值</span><br><span class="line">void putAll(Map&lt;? extends K, ? extends V&gt; m);</span><br><span class="line">作用:添加一组键值对</span><br><span class="line">删</span><br><span class="line">V remove(Object key);</span><br><span class="line">作用:通过key删除指定的键值对</span><br><span class="line">返回值:被删除的值</span><br><span class="line">void clear();</span><br><span class="line">作用:清空</span><br><span class="line">查</span><br><span class="line">int size();</span><br><span class="line">作用:查询map中键值对的个数</span><br><span class="line">boolean isEmpty();</span><br><span class="line">作用:判断是否为空map</span><br><span class="line">boolean containsKey(Object key);</span><br><span class="line">作用:判断是否包含指定的key</span><br><span class="line">boolean containsValue(Object value);</span><br><span class="line">作用:判断是否包含指定的value</span><br><span class="line">V get(Object key);</span><br><span class="line">作用:获取key指定的值</span><br><span class="line">Set&lt;K&gt; keySet();</span><br><span class="line">作用:获取所有key的集合</span><br><span class="line">Collection&lt;V&gt; values();</span><br><span class="line">作用:获取所有值的集合</span><br><span class="line">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="line">作用:获取所有键值对的集合</span><br><span class="line">改</span><br><span class="line">V put(K key, V value);</span><br><span class="line">注意:如果存储数据时,key已经存在,此时就是修改**Map接口的遍历方式**</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-特点"><a href="#3-特点" class="headerlink" title="3.特点:"></a>3.特点:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Map和collection并列存在,用于保存具有映射关系的数据Key-Value</span><br><span class="line">2.Map中的Key和Value可以是任何引用数据类型,会封装到HashMap&amp;$Node对象中</span><br><span class="line">3.Map中的Key不允许重复,有相同的key时,采用替换机制,新出现的替换已有的,原因和HashSet一样</span><br><span class="line">4.Map中value可重复</span><br><span class="line">5.Map的key可以为null,value也可以为null,key只能有一个null,value为null可以有多个</span><br><span class="line">6.常用的String类可作为Map的key</span><br><span class="line">7.key和value之间存在一对一关系，及通过指定可以总能找到对应的value。</span><br></pre></td></tr></table></figure><h3 id="4-Map接口的遍历方式"><a href="#4-Map接口的遍历方式" class="headerlink" title="4.Map接口的遍历方式"></a><strong>4.Map接口的遍历方式</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">     map.put(<span class="string">&quot;舒克&quot;</span>,<span class="string">&quot;贝塔&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;李大头&quot;</span>,<span class="string">&quot;李大脑袋&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;郭德纲&quot;</span>,<span class="string">&quot;于谦&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;岳云鹏&quot;</span>,<span class="string">&quot;孙越&quot;</span>);</span><br><span class="line">     map.put(<span class="literal">null</span>,<span class="string">&quot;kk&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;king&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;===========第一种遍历===========&quot;</span>);</span><br><span class="line">     <span class="comment">//第一种遍历，先取出所有的Key，再通过Key取出对应的value</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">keyset</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">    <span class="comment">//(1)增强for</span></span><br><span class="line"><span class="keyword">for</span> (Object key :keyset) &#123;</span><br><span class="line">    System.out.println(key+<span class="string">&quot;-&quot;</span>+map.get(key));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//（2）迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keyset.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;===========第二种遍历===========&quot;</span>);</span><br><span class="line"><span class="comment">//第二种，把所有的value取出</span></span><br><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="comment">//可以使用collection使用的所有遍历方式</span></span><br><span class="line"><span class="comment">//(1)迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> values.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator1.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span>  iterator1.next();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(2)for增强</span></span><br><span class="line"><span class="keyword">for</span> (Object o :values) &#123;</span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;============第三种遍历============&quot;</span>);</span><br><span class="line"><span class="comment">//第三种遍历方式，通过EntrySet获取</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">entryset</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line"><span class="comment">//（1）增强for</span></span><br><span class="line"><span class="keyword">for</span> (Object entryset1 :entryset) &#123;</span><br><span class="line">    <span class="comment">//将entryset1转成Map.entry</span></span><br><span class="line">    Map.Entry m=(Map.Entry) entryset1;</span><br><span class="line">    System.out.println(m.getKey()+<span class="string">&quot;-&quot;</span>+m.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//（2）迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> entryset.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator2.next();</span><br><span class="line">     <span class="comment">//将iterator2转成Map.entry</span></span><br><span class="line">    Map.Entry m1=(Map.Entry) next;</span><br><span class="line">    System.out.println(m1.getKey()+<span class="string">&quot;-&quot;</span>+m1.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-开发中如何选择集合实现类"><a href="#5-开发中如何选择集合实现类" class="headerlink" title="5.开发中如何选择集合实现类*"></a>5.<em>开发中如何选择集合实现类</em>*</h3><ol start="3"><li><pre><code>/*开发中如何选择集合实现类**  1. **先判断存储的类型（一组对象或一组键值对）**2. **一组对象（单列）：collection接口**   **允许重复：List**            **增删多：LinkedList   底层维护了一个双向链表**            **改查多：ArrayList    底层维护Object类型的可变数组**   **不允许重复  Set**            **无序:HashSet 底层是HashMap  维护了一个哈希表即数组+链表+红黑树**            **排序：TreeSet**            **插入和取出顺序一致：LinkedHashSet，维护数组+双向链表**3. **一对键值对（双列）：Map**   **键无序：HashMap  底层是：哈希表  jdk7：数组+链表   jdk8：数组+链表+红黑树**   **键排序：TreeMap   **键插入和取出顺序一致：LinkedHashMap      **读取文件：Properties   */<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 6.扩容机制</span><br><span class="line"></span><br></pre></td></tr></table></figure>**扩容机制：**1. HashMap底层维护了Node类型的数组table，默认为nll2. 当创建对象时，将加载因子（loadfactor）初始化为0.753. 当添加key-value时，通过key的哈希值得到table的索引，然后判断该索引处是否有元素，如果没有元素直接添加，如果该索引处有元素，判断钙元素的key是否和准备加入的key相等，如果相等，则直接替换val：如果不相等需要判断是树结构还是链表结构，做出相应的处理，如果添加时发现容量不够，则需要扩容4. 第一次添加，则需要扩容table容量为16，临界值为125. 以后再扩容，则需要扩容table容量为原来的2倍32，临界值为原来的2倍，即24，以此类推6. 在java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD(默认为8)，并且table的大小&gt;=MIN_TREEIFY_CAPACITY(默认64)就会进行树化<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 7.HashTable</span><br><span class="line"></span><br></pre></td></tr></table></figure>1. 存放的元素时键值对 k-v2. hashtable的键和值都不能为空3. hashtable使用方法和HashMap基本一样4. hashtable是线程安全的5. hashtable底层有数组hashtable$Entry[]初始值为11，threshold=86. 扩容按照自己的扩容机制进行7. 扩容时执行addEntry（hash，key，value，index）；添加一个k-v封装在Entry8. 当count&gt;=threshold时就进行扩容9. 新的扩容时  （旧容量&lt;&lt;1）+1<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   ### 8.Properties</span><br><span class="line"></span><br><span class="line">4. properties类继承自hashtable类并且实现了Map接口，也是使用一种键值对的形式保存数据</span><br><span class="line"></span><br><span class="line">5. 使用特点和hashtable类似，不能有空的键和空的值</span><br><span class="line"></span><br><span class="line">6. properties可以用于从  xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改</span><br><span class="line"></span><br><span class="line">7. 说明xxx.properties文件通常作为配置文件</span><br><span class="line"></span><br><span class="line">### 9.collection工具类</span><br><span class="line"></span><br><span class="line">1.  Collections是一个操作Set、List、Map等集合的工具类</span><br><span class="line">2.  Collections中提供了一系列静态的方法对集合元素进行排序、查询、修改等操作</span><br><span class="line">3.  排序操作：（均为static方法）</span><br><span class="line">    - resverse（List）：反转List中元素的顺序</span><br><span class="line">    - shuffle（List）：对List集合元素进行随机排序</span><br><span class="line">    - sort（List）：根据元素的自然顺序对指定的lisdt集合元素按升序排序</span><br><span class="line">    - sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序</span><br><span class="line">    - swap（List，int，int）：将指定list集合中i处元素和j处元素进行交换</span><br><span class="line"></span><br><span class="line">4.查找，替换</span><br><span class="line"></span><br><span class="line">- Object max（Collection）:根据元素的自然顺序，返回给的集合中最大的元素</span><br><span class="line">- Object  max（Collection，Comparator）根据Comparator指定的顺序，返回给定集合中最大的元素4</span><br><span class="line">- Object min（Collection）</span><br><span class="line">- Object  min（Collection，Comparator）</span><br><span class="line">- int  frequency（Collection，Object）将返回指定集合中指定元素出现的次数</span><br><span class="line">- void copy（List dest，List dest）将src中的内容复制到dest中</span><br><span class="line">- boolean  replaceAll（List list，Object oldVal，Object newVal）使用新值替换List对象的所有旧值</span><br><span class="line"></span><br><span class="line"># 二十三.异常</span><br><span class="line"></span><br><span class="line">### 1.概念:</span><br><span class="line"></span><br><span class="line">在java语言中,将程序执行中发生的不正常情况称为异常</span><br><span class="line"></span><br><span class="line">### 2.分类:</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ol><p>1.Error:java虚拟机无法解决的严重问题,如jvm系统内部错误,资源耗尽等</p><p>2.Exception:因编程错误,或偶然的外部因素导致的一般性问题,可以使用正对性的代码处理,例如空指针访问,网络中断等.</p><p>Exception分为两大类,运行时异常和编译时异常</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">检查时异常</span><br><span class="line">概念:因语法问题导致的错误</span><br><span class="line">解决:修改语法</span><br><span class="line">运行时异常</span><br><span class="line">概念:但是因为编写时思路问题,或传入的数据导致程序无法正常运行</span><br><span class="line">解决:更换思路,修改传入的数据,加入容错判断</span><br><span class="line"></span><br><span class="line">体系结构:</span><br><span class="line"></span><br><span class="line">​Throwable:</span><br><span class="line"></span><br><span class="line">​Error(错误)</span><br><span class="line"></span><br><span class="line">​Exception(异常):CheckedException(检查时异常),RuntimeException(运行时异常)</span><br><span class="line"></span><br><span class="line">### 3.五大运行异常</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>NullPointerException 空指针异常</p><p>当应用程序试图在需要对象的地方使用null时，抛出该异常</p></li><li><p>ArithmeticException  数学运算异常</p><p>当出现异常的运算条件时，抛出此异常</p></li><li><p>ArrayIndexOutOfBoundsException数组下标越界异常</p><p>用非法索引访问数组时抛出异常，如果索引为负或大于等于数组，则为非法索引</p></li><li><p>ClassCastException类型转换异常</p><p>当时图将对象强制转换为不是实例的子类时，抛出该异常</p></li><li><p>NumberFormatException数字格式不正确异常</p><p>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常&#x3D;&gt;使用异常我们可以确保输入是满足条件数字</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 4.编译异常</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SQLException    操作数据库时查询表可能发生异常</p><p>IOException   操作文件时发生异常</p><p>FileNotFoundException     当操作一个不存在的文件时，发生异常</p><p>ClassNotFoundException    加载类，而类不存在时，发生异常</p><p>EOFException    操作文件，到文件末尾，发生异常</p><p>IllegalArguementException    参数异常</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 5.异常处理方式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>try-catch<br>    语法:<br>    try{<br>        异常代码<br>    }catch(异常类型 变量名){<br>        处理方式<br>    }catch(异常类型 变量名){<br>        处理方式<br>    }…..<br>    catch(异常类型 变量名){<br>        处理方式<br>    }finally{<br>        必须执行的代码<br>    }<br>注意:<br>    1.如果发生异常,则异常后面的代码不再执行,直接进入catch<br>    2.如果没有异常发生,则顺序执行try的代码块,不会进入catch<br>    3.如果希望不管是否发生异常,都执行某段代码(关闭连接,释放资源)则使用finally<br>    4.可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求父类异常在后，子类异常在前，比如（Exception在后，NULLpointerException在前）如果发生异常，只会匹配一个catch<br>    5.也可以使用try-finally配合使用，<strong>这种用法相当于没有捕获异常</strong>，因此程序会崩。应用场景，就是执行一段代码，不管是否发生异常，都必须执行某个业务逻辑<br>    6.捕获异常后，有return时，执行return但不会返回return的后缀，  执行finally</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>throws:<br>    将发生的异常抛出,交给调用者自行处理,最顶尖的处理者是JVM<br>    语法:<br>        throws 异常类型1,异常类型2….<br>        使用位置方法的形参之后</p><p>基本介绍:<br>    1.如果一个方法中的语句执行时,可能生成某种异常,但是并不能确定如何处理这种异常,则此方法应显示声明抛出异常,表明该方法将不对异常进行处理,而是由方法的调用者处理<br>    2.在方法声明时,可以使用throws抛出异常,throws后面的异常类型可以是方法中产生的异常类型,也可以是它的父类.<br>    3.throws可以抛出多个异常</p><p>细节:<br>    1. 对于编译异常，程序中必须处理，比如：try-catch或者throws<br>    2. 对于运行时异常，程序中如果没有处理，默认就是throws的处理方式<br>    3. 子类重写父类方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出异常类型的子类<br>    4. 在throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必thows</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>throw<br>    声明异常<br>    语法:<br>        throw 异常对象;<br>    位置:方法中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 6.自定义异常</span><br><span class="line"></span><br><span class="line">当程序中出现某些错误时,但是该错误信息并没有在Throwable子类中描述处理,这个时候可以自己设计异常类,用于描述错误信息.</span><br><span class="line"></span><br><span class="line">1.步骤:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.定义类:自定义异常类,<br>2.异常类类名继承Exception或者RuntimeException<br>3.编写其构造函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 二十四.数据结构</span><br><span class="line"></span><br><span class="line">### 1.栈</span><br><span class="line"></span><br><span class="line">​先进后出</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Stack &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        stack01();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void  stack01()&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt;5; i++) &#123;</span><br><span class="line">            integers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        while (integers.size()&gt;0)&#123;</span><br><span class="line">            Integer remove = integers.remove(integers.size() - 1);</span><br><span class="line">            System.out.print(remove+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">            System.out.println(integers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2.队列"></a>2.队列</h3><p>​先进先出</p><p>代码示例:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        queue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">queue</span><span class="params">()</span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (list.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">remove</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">            System.out.print(remove+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-单链表"><a href="#3-单链表" class="headerlink" title="3.单链表"></a>3.单链表</h3><p>​<img src="/2023/05/01/JAVA%E5%9F%BA%E7%A1%80/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230417193112848.png" alt="image-20230417193112848"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;4&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;3&quot;</span>,node4);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;2&quot;</span>,node3);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;1&quot;</span>,node2);</span><br><span class="line"></span><br><span class="line">        System.out.print(node1.getData()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        System.out.print(node1.next().getData()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        System.out.print(node1.next().next().getData()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        System.out.print(node1.next().next().next().getData()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object data, Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">next</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="二十五-线程"><a href="#二十五-线程" class="headerlink" title="二十五.线程"></a>二十五.线程</h1><h3 id="1-作用-4"><a href="#1-作用-4" class="headerlink" title="1.作用:"></a>1.作用:</h3><p>​使代码可以同时执行多个事物</p><h3 id="2-名词"><a href="#2-名词" class="headerlink" title="2.名词"></a>2.名词</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进程:一个正在执行的程序</span><br><span class="line">进程是程序的一次执行过程,或是正在运行的一个程序.是动态过程:有他自身的产生,存在,消亡</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程: 一个执行路径</span><br><span class="line">线程是由进程创建的,是进程的一个实体,一个进程可以有多个线程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单线程:同一时刻,只允许执行一个线程</span><br><span class="line">多线程:同一时刻,可以执行多个线程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主线程:一个线程创建时自带的一条线程,称为主线程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子线程:除主线程外都是子线程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">守护线程(后台线程):</span><br><span class="line">特点:如果一个进程的前台线程全部被销毁,此时不管是否有守护线程正在执行,此时进程都将被回收</span><br><span class="line">前台线程:</span><br><span class="line">特点:如果一个进程中有前台线程存活,此时系统将不会回收进程</span><br></pre></td></tr></table></figure><h3 id="3-组成"><a href="#3-组成" class="headerlink" title="3.组成:"></a>3.组成:</h3><h3 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程抢夺CPU执行权后可执行的时间</span><br></pre></td></tr></table></figure><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个线程一个栈内存,多个线程共享一个堆内存</span><br></pre></td></tr></table></figure><h3 id="4-线程的创建"><a href="#4-线程的创建" class="headerlink" title="4.线程的创建"></a>4.线程的创建</h3><h3 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一:</span><br><span class="line">创建Thread的子类对象</span><br><span class="line">步骤:</span><br><span class="line">1.创建一个类</span><br><span class="line">2.使其继承Thread</span><br><span class="line">3.重写run方法</span><br><span class="line">注意:当前线程启动后,将执行如方法中的代码</span><br><span class="line">    4.创建该类对象</span><br><span class="line">    优点:可以创建无数个该类对象</span><br><span class="line">    </span><br><span class="line">  方式二:</span><br><span class="line">  使用匿名内部类的形式创建Thread的子类对象</span><br><span class="line">  步骤:</span><br><span class="line">  Thread 对象名 = new Thread()&#123;</span><br><span class="line">  重写run方法</span><br><span class="line">  &#125;</span><br><span class="line">  优点:便于书写</span><br><span class="line">        缺点:只能创建一个该线程对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一:普通方式创建Runnable的子类对象</span><br><span class="line">步骤:</span><br><span class="line">1.创建一个类</span><br><span class="line">2.使其实现Runnable接口</span><br><span class="line">3.重写run方法</span><br><span class="line">4.创建该类对象</span><br><span class="line">5.在创建线程对象时传入该类对象(线程任务对象)</span><br><span class="line"></span><br><span class="line">方式二:</span><br><span class="line">使用匿名内部类创建Runnable的子类对象</span><br><span class="line">步骤:</span><br><span class="line">1.Runnable 对象名 = new Runnable()&#123;</span><br><span class="line">重写run方法</span><br><span class="line">&#125;;</span><br><span class="line">2.创建线程对象时传入该类对象(线程任务对象)</span><br></pre></td></tr></table></figure><h3 id="5-线程使用"><a href="#5-线程使用" class="headerlink" title="5.线程使用"></a>5.线程使用</h3><h5 id="5-线程的启动"><a href="#5-线程的启动" class="headerlink" title="5.线程的启动"></a>5.线程的启动</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程对象.start();</span><br><span class="line">注意:</span><br><span class="line">1.当线程启动后会开启新的执行路径,执行run方法中的代码</span><br><span class="line">2.如果直接使用线程对象调用run方法,不会开启新的执行路径</span><br></pre></td></tr></table></figure><h5 id="6-线程的销毁"><a href="#6-线程的销毁" class="headerlink" title="6.线程的销毁"></a>6.线程的销毁</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程已经启动,无法控制,需要等待执行完run方法中的代码</span><br></pre></td></tr></table></figure><h5 id="7-获取当前线程对象"><a href="#7-获取当前线程对象" class="headerlink" title="7.获取当前线程对象"></a>7.获取当前线程对象</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread.currentThread();</span><br></pre></td></tr></table></figure><h5 id="8-线程名城"><a href="#8-线程名城" class="headerlink" title="8.线程名城"></a>8.线程名城</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取线程名称:</span><br><span class="line">线程对象.getName();</span><br><span class="line">修改线程名称</span><br><span class="line">线程对象.setName(name);</span><br><span class="line">注意:在启动前修改</span><br></pre></td></tr></table></figure><h5 id="9-线程优先级"><a href="#9-线程优先级" class="headerlink" title="9.线程优先级"></a>9.线程优先级</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:提高线程抢夺到CPU执行权的概率</span><br><span class="line"></span><br><span class="line">语法:</span><br><span class="line">线程对象.setPriority(int);</span><br><span class="line">注意:</span><br><span class="line">1.取值范围1-10;</span><br><span class="line">2.必须在线程启动前</span><br></pre></td></tr></table></figure><h5 id="10-线程休眠"><a href="#10-线程休眠" class="headerlink" title="10.线程休眠"></a>10.线程休眠</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:让线程暂时停止运行</span><br><span class="line">方法:</span><br><span class="line">static void sleep(休眠时间);</span><br><span class="line">注意:</span><br><span class="line">1.单位毫秒</span><br><span class="line">2.使用类调用,使当前线程休眠</span><br><span class="line">3.线程休眠期间不会抢夺CPU执行权</span><br></pre></td></tr></table></figure><h5 id="11-线程礼让"><a href="#11-线程礼让" class="headerlink" title="11.线程礼让"></a>11.线程礼让</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:将获取道德cpu执行权让出,重新参与抢夺</span><br><span class="line">方法:</span><br><span class="line">static native void yield();</span><br></pre></td></tr></table></figure><h5 id="12-线程合并"><a href="#12-线程合并" class="headerlink" title="12.线程合并"></a>12.线程合并</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:合并线程</span><br><span class="line">方法:</span><br><span class="line">public final void join();</span><br></pre></td></tr></table></figure><h5 id="13-守护线程"><a href="#13-守护线程" class="headerlink" title="13.守护线程"></a>13.守护线程</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有名:后台线程</span><br><span class="line">特点:当一个进程中有前台线程存活,此时该进程就不会被系统回收</span><br><span class="line">如果一个进程中只剩余后台线程,此时不管后台线程中的代码是否运行完毕,系统都将回收该进程</span><br><span class="line">方法:</span><br><span class="line">public final void setDaemon(boolean on);</span><br><span class="line">true:表示守护线程,默认为false,表示前台线程</span><br><span class="line">注意:</span><br><span class="line">1.创建线程对象与主线程默认为前台线程</span><br><span class="line">2.必须在线程启动前</span><br></pre></td></tr></table></figure><h3 id="6-线程的生命周期"><a href="#6-线程的生命周期" class="headerlink" title="6.线程的生命周期"></a>6.线程的生命周期</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程可以处于以下状态之一</span><br><span class="line"></span><br><span class="line">1. NEW: 尚未启动的线程处于此状态</span><br><span class="line">2. RUNNABLE:在java虚拟机中执行的线程处于此状态；内部会分为ready和running两部分，执行哪一个由调度器决定</span><br><span class="line">3. BLOCKED: 被阻塞等待监视器锁定的线程处于此状态</span><br><span class="line">4. WAITING ：正在等待另一个线程执行特定动作的线程处于此状态</span><br><span class="line">5. TIMED_WAITING :正在等待另一个线程执行动作达到指定等待时间的线程处于此状态（超时等待）</span><br><span class="line">6. TERMINATED:一退出的线程出于此状态</span><br></pre></td></tr></table></figure><p><img src="/2023/05/01/JAVA%E5%9F%BA%E7%A1%80/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230418171549456.png" alt="image-20230418171549456"></p><h3 id="7-Thread和Runnable的区别"><a href="#7-Thread和Runnable的区别" class="headerlink" title="7.Thread和Runnable的区别"></a>7.Thread和Runnable的区别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 从java设计来看，通过继承Thread或者实现Runnable接口来创建线程本质上没有区别，从jdk帮助文档我们可以见到Tread类本身就实现了Runnable接口</span><br><span class="line">2. 实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制</span><br></pre></td></tr></table></figure><h3 id="8-线程安全问题"><a href="#8-线程安全问题" class="headerlink" title="8.线程安全问题"></a>8.线程安全问题</h3><h5 id="原因"><a href="#原因" class="headerlink" title="原因:"></a>原因:</h5><p>多个线程操作同一数据,会导致线程安全问题</p><h5 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h5><p>保证同时只能有一个线程操作该数据</p><h5 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方案一:同步代码块</span><br><span class="line">语法:</span><br><span class="line">synchronized(锁对象)&#123;</span><br><span class="line">要同步的代码</span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">1.所有对象都可以作为锁对象</span><br><span class="line">    2.多个线程的锁对象要是同一个对象</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方案二:同步方法</span><br><span class="line">语法:</span><br><span class="line">访问权限修饰符 synchronized 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">    1.同步方法法人锁对象是this</span><br><span class="line">    2.多个线程的锁对象要是同一个对象</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方案三:同步静态方法</span><br><span class="line">语法:</span><br><span class="line">访问权限修饰符 synchronized static 返回值类型 方法名(形参列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">    1.同步静态方法的锁对象是该类的对象</span><br><span class="line">    类对象:当JVM加载类时.会产生一个对象,该对象就是该类的类对象,一个类只有一个类对象</span><br><span class="line">    2.多个线程的锁对象要是同一个对象</span><br></pre></td></tr></table></figure><h3 id="9-死锁"><a href="#9-死锁" class="headerlink" title="9.死锁"></a>9.死锁</h3><h5 id="原因-1"><a href="#原因-1" class="headerlink" title="原因:"></a>原因:</h5><p>多个线程互相持有对方所需的锁资源</p><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">线程<span class="number">1</span>:</span><br><span class="line">xxx</span><br><span class="line"><span class="title function_">synchronized</span> <span class="params">(A)</span>&#123;</span><br><span class="line">xxx</span><br><span class="line"><span class="title function_">synchronized</span> <span class="params">(B)</span>&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">线程<span class="number">2</span>:</span><br><span class="line">xxx</span><br><span class="line"><span class="title function_">synchronized</span> <span class="params">(B)</span>&#123;</span><br><span class="line">xxx</span><br><span class="line"><span class="title function_">synchronized</span> <span class="params">(A)</span>&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>避免思路</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不要在同步中使用</span><br></pre></td></tr></table></figure><h3 id="10-线程间通讯"><a href="#10-线程间通讯" class="headerlink" title="10.线程间通讯"></a>10.线程间通讯</h3><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.线程间通讯的方法是由Object提供的</span><br><span class="line">2.只能在同步中使用</span><br><span class="line">3.只能使用所在的同步的锁对象调用</span><br></pre></td></tr></table></figure><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">唤醒线程</span><br><span class="line">notify():随机唤醒一个</span><br><span class="line">notifyAll():唤醒所有</span><br><span class="line">注意:只能唤醒以同一个对象调用wait方法的线程</span><br><span class="line"></span><br><span class="line">线程休眠:</span><br><span class="line">wait() 无限休眠</span><br><span class="line">wait(int ms) 有限期休眠(休眠ms毫秒)</span><br><span class="line">wait(int ms,int ns)有限期休眠</span><br><span class="line">注意:</span><br><span class="line">ms为毫秒,ns为纳秒</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-wait和sleep的区别"><a href="#11-wait和sleep的区别" class="headerlink" title="11.wait和sleep的区别"></a>11.wait和sleep的区别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.wait在休眠期会释放所持有的锁资源,sleep不会</span><br><span class="line">2.wait必须在同步使用,sleep没有限制</span><br><span class="line">3.wait必须使用所在的同步锁对象调用,sleep使用Thread类或者Thread类的对象调用</span><br><span class="line">4.wait由Object提供,sleep由Thread类提供</span><br></pre></td></tr></table></figure><h3 id="13-线程池"><a href="#13-线程池" class="headerlink" title="13.线程池"></a>13.线程池</h3><h5 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h5><p>​优化线程</p><h5 id="原因-2"><a href="#原因-2" class="headerlink" title="原因:"></a>原因:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个线程大约占1MB的运行内存</span><br><span class="line">大量创建线程时可能会导致内存溢出</span><br><span class="line">大量的创建线程也导致需要对象线程频繁的创建与回收</span><br></pre></td></tr></table></figure><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.使用空闲的线程执行新的任务(线程复用)</span><br><span class="line">2.使用一个容器来管理线程的创建,回收,复用等</span><br><span class="line">注意:java中提出线程池来完成以上操作</span><br></pre></td></tr></table></figure><h5 id="线程池的体系结构"><a href="#线程池的体系结构" class="headerlink" title="线程池的体系结构"></a>线程池的体系结构</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Executor(接口)</span><br><span class="line">提供的方法:</span><br><span class="line">void execute(Runnable command);</span><br><span class="line">作用:执行线程任务,子接口提供了submit优于该方法</span><br><span class="line">子类或子接口</span><br><span class="line">    ExecutorService(接口)</span><br><span class="line">    提供的方法:</span><br><span class="line">    void shutdown();</span><br><span class="line">    作用:关闭线程池</span><br><span class="line">    boolean isShutdown();</span><br><span class="line">    作用:判断线程池是否关闭</span><br><span class="line">    Future&lt;T&gt; submit(线程任务)</span><br><span class="line">    作用:提交线程任务</span><br><span class="line">    子类或子接口:</span><br><span class="line">            ScheduledExecutorService(接口)</span><br><span class="line">            ThreadPoolExecutor(类)</span><br><span class="line">            构造函数:</span><br><span class="line">            public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">            int maxmumPoolSize,</span><br><span class="line">            long keepAliveTime,</span><br><span class="line">            TimeUnit unit,</span><br><span class="line">            BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">            ThreadFactory threadFactory,</span><br><span class="line">            RejectedExecutionHandler handler)</span><br><span class="line">            </span><br><span class="line">            corePoolSize:h核心线程数,线程池中最少有几个线程</span><br><span class="line">                    maximumPoolSize:最大线程数,线程中最多可以容纳的线程数</span><br><span class="line">                    keepAliveTime:销毁时间,当线程执行完任务后,多久销毁</span><br><span class="line">                    until:时间单位</span><br><span class="line">                    workQueue:存储执行的线程任务的集合(队列形式)</span><br><span class="line">                    threadFactory:创建线程</span><br><span class="line">                    handler:优化线程,使其线程复用的算法</span><br></pre></td></tr></table></figure><h5 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:创建线程池</span><br><span class="line">原因:应为ThreadPoolExecutor过于麻烦,所以JDK提供该类帮助我们创建线程池提供的方法</span><br><span class="line"></span><br><span class="line">1.固定线程池</span><br><span class="line">特点:线程池中的线程数量恒定,当线程任务小于线程数量时,随机在线程池中挑选线程执行任务,当线程任务大于线程数量,会先执行前面的任务,后等前面任务执行完毕后,使用执行完毕的线程,执行剩余任务.</span><br><span class="line">    static ExecutorService newFixedThreadPool(int nThreads)</span><br><span class="line">    nThreads:线程池中线程的数量</span><br><span class="line">    </span><br><span class="line">    2.可变线程池</span><br><span class="line">    特点:线程池中的线程数量可变</span><br><span class="line">    static ExecutorService newCachedThreadPool()</span><br><span class="line">    </span><br><span class="line">    3.单例线程池</span><br><span class="line">    特点:一个线程池只有一个线程</span><br><span class="line">    static ExecutorService newSingleThreadExecutor()</span><br><span class="line">    </span><br><span class="line">    4.抢占线程池</span><br><span class="line">    static ExecutorService newWorkStealingPool()</span><br><span class="line">    </span><br><span class="line">    5.调度线程池</span><br><span class="line">    特点:该线程池执行任务可以延迟,也可以延迟重复执行</span><br><span class="line">    static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</span><br><span class="line">    corePoolSize:线程池中线程的数量</span><br><span class="line">    </span><br><span class="line">    6.单例调度线程池</span><br><span class="line">    特点:调度线程池中只有一个线程</span><br><span class="line">    static ScheduledExecutorService newSingleThreadScheduledExecutor();</span><br></pre></td></tr></table></figure><h5 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">步骤:</span><br><span class="line">1.创建线程池</span><br><span class="line">2.提交任务</span><br><span class="line">3.关闭线程池</span><br></pre></td></tr></table></figure><h5 id="调度线程池-ScheduledExecutorService"><a href="#调度线程池-ScheduledExecutorService" class="headerlink" title="调度线程池:ScheduledExecutorService"></a>调度线程池:ScheduledExecutorService</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提供的方法:</span><br><span class="line">public ScheduledFuture&lt;?&gt; schedule(线程任务,long delay,TimeUnit unit)</span><br><span class="line">作用:延迟执行   </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command</span><br><span class="line">long initialDelay</span><br><span class="line">long period</span><br><span class="line">TimeUnit unit);</span><br><span class="line">作用:延迟重复执行</span><br><span class="line">    1参,执行的任务</span><br><span class="line">    2参,延迟时间</span><br><span class="line">    3参,间隔时间 = 本次任务开始时间 - 上次任务开始时间</span><br><span class="line">    注意:如果上次任务执行时间&gt;间隔时间,那么当上次任务执行完毕后,本次任务直接开始</span><br><span class="line">   4参,时间单位</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ScheduledFuture&lt;?&gt; scheduleWithFixedDaley(Runnable command,</span><br><span class="line">long initialDelay</span><br><span class="line">long delay</span><br><span class="line">TimeUnit unit);</span><br><span class="line">作用:延迟重复执行</span><br><span class="line">    1参,执行任务</span><br><span class="line">    2参,延迟时间</span><br><span class="line">    3参,间隔时间= 本次任务开始时间-上次任务结束时间</span><br><span class="line">    4时间单位</span><br></pre></td></tr></table></figure><h3 id="14-Callable"><a href="#14-Callable" class="headerlink" title="14.Callable"></a>14.Callable</h3><p>作用:有返回值的线程任务对象</p><p>注意:无法在创建Thread对象时传入,必须配合线程池使用</p><h3 id="15-Lock"><a href="#15-Lock" class="headerlink" title="15.Lock"></a>15.Lock</h3><p>作用:简化同步</p><h5 id="同步"><a href="#同步" class="headerlink" title="同步:"></a>同步:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同步代码块</span><br><span class="line">synchronize(锁对象)&#123;</span><br><span class="line">//关锁</span><br><span class="line">代码</span><br><span class="line">//开锁</span><br><span class="line">&#125;</span><br><span class="line">同步方法</span><br><span class="line">访问权限修饰符 synchronize 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">//关锁</span><br><span class="line">方法</span><br><span class="line">//开锁</span><br><span class="line">&#125;</span><br><span class="line">同步静态方法</span><br><span class="line">访问权限修饰符 synchronize static 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">//关锁</span><br><span class="line">方法</span><br><span class="line">//开锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="lock体系"><a href="#lock体系" class="headerlink" title="lock体系"></a>lock体系</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lock</span><br><span class="line">提供的方法:</span><br><span class="line">void lock():关锁</span><br><span class="line">void unLock():开锁</span><br><span class="line"></span><br><span class="line">Condition newCondition():获取锁对象</span><br><span class="line">void await():无限期休眠</span><br><span class="line">void signal():随机唤醒一个</span><br><span class="line">void signalAll():唤醒所有</span><br><span class="line">子类:</span><br><span class="line">ReentrantLock</span><br><span class="line"></span><br><span class="line">ReadWriteLock</span><br><span class="line">提供的方法:</span><br><span class="line">Lock readLock():获取读锁</span><br><span class="line">Lock writeLock():获取写锁</span><br><span class="line">注意:</span><br><span class="line">读-写互斥</span><br><span class="line">读-读 不互斥</span><br><span class="line">写-写互斥</span><br><span class="line">子类</span><br><span class="line">ReentrantReadWriteLock</span><br></pre></td></tr></table></figure><h1 id="二十六-x2F-设计模式"><a href="#二十六-x2F-设计模式" class="headerlink" title="二十六&#x2F;设计模式"></a>二十六&#x2F;设计模式</h1><p>作用:解决特定问题的思路</p><h3 id="1-生成者与消费者"><a href="#1-生成者与消费者" class="headerlink" title="1.生成者与消费者"></a>1.生成者与消费者</h3><p>1.生产者消费者模式解决进销存业务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">生产</span><br><span class="line">无限生产</span><br><span class="line">销售</span><br><span class="line">无限销售</span><br><span class="line">工厂</span><br><span class="line">生产的方法</span><br><span class="line">出货的方法</span><br><span class="line">库存数量</span><br><span class="line">商品数量上限:100</span><br><span class="line">商品数量下限:0</span><br></pre></td></tr></table></figure><h3 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2.单例模式"></a>2.单例模式</h3><p>解决的问题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个类只能有一个对象</span><br></pre></td></tr></table></figure><p>分类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">懒汉式</span><br><span class="line">步骤:</span><br><span class="line">1,私有化构造函数</span><br><span class="line">2,提供一个公共的属性,记录该类的唯一对象</span><br><span class="line">3,提供一个公共的静态方法返回该类创建好的对象</span><br><span class="line">优点:</span><br><span class="line">节省内存</span><br><span class="line">缺点:</span><br><span class="line">有线程安全问题</span><br><span class="line">饿汉式</span><br><span class="line">步骤:</span><br><span class="line">1,私有化构造函数</span><br><span class="line">2,提供一个公共的属性,记录该类的唯一对象,并创建该对象</span><br><span class="line">3,提供一个公共的静态方法返回该类创建好的对象</span><br><span class="line">优点:</span><br><span class="line">不存在线程安全问题</span><br><span class="line">缺点:</span><br><span class="line">浪费内存</span><br><span class="line"></span><br><span class="line">线程安全的懒汉式</span><br><span class="line">代码:</span><br><span class="line">public class C &#123;</span><br><span class="line">       private static C c;</span><br><span class="line">       private C()&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       public synchronized C getInstance()&#123;</span><br><span class="line">           if (c == null)&#123;</span><br><span class="line">               c = new C();</span><br><span class="line">           &#125;</span><br><span class="line">           return c;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">优点:</span><br><span class="line">线程安全</span><br><span class="line">缺点:</span><br><span class="line">效率慢</span><br><span class="line"></span><br><span class="line">内部类饿汉式</span><br><span class="line">代码:</span><br><span class="line">   public class D &#123;</span><br><span class="line">       private D()&#123;</span><br><span class="line">       &#125;</span><br><span class="line">       public static D getInstance()&#123;</span><br><span class="line">           return InClass.getD();</span><br><span class="line">       &#125;</span><br><span class="line">       static class InClass&#123;</span><br><span class="line">           private static D d = new D();</span><br><span class="line">           public static D getD()&#123;</span><br><span class="line">               return d;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3-工程模式"><a href="#3-工程模式" class="headerlink" title="3.工程模式"></a>3.工程模式</h3><p><strong>解决问题</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特定编号生产特定商品</span><br></pre></td></tr></table></figure><pre><code>家具厂    沙发    椅子    床    衣柜    茶几    ...分析:    类        家具厂类            家具接口对象 生产的方法(编号)&#123;                switch(编号)&#123;                    case 1:            &#125;        &#125;    家具接口    沙发类 实现 家具接口    椅子类 实现 家具接口    床类 实现 家具接口    衣柜类 实现 家具接口    茶几类 实现 家具接口</code></pre><h1 id="二十七-IO流"><a href="#二十七-IO流" class="headerlink" title="二十七.IO流"></a>二十七.IO流</h1><h3 id="1-作用-5"><a href="#1-作用-5" class="headerlink" title="1.作用"></a>1.作用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传输数据</span><br></pre></td></tr></table></figure><h3 id="2-分类-1"><a href="#2-分类-1" class="headerlink" title="2.分类"></a>2.分类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按照流向分类</span><br><span class="line">输入流</span><br><span class="line">输出流</span><br><span class="line"></span><br><span class="line">按照传输的最小数据单位分类</span><br><span class="line">字节流</span><br><span class="line">最小单位:byte</span><br><span class="line">字符流</span><br><span class="line">    最小单位char</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   按照功能分类</span><br><span class="line">   节点流:</span><br><span class="line">   从数据源到程序,或从程序直接到数据源</span><br><span class="line">   包装流(过滤流)</span><br><span class="line">        在节点流的基础上增强功能</span><br><span class="line">        注意:所有的包装流都使用了装饰者模式</span><br></pre></td></tr></table></figure><h3 id="3-字节流"><a href="#3-字节流" class="headerlink" title="3.字节流"></a>3.字节流</h3><p>体系结构:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InputStream(字节输入流顶级接口)</span><br><span class="line">方法:</span><br><span class="line">int read();一次读取一个字节,返回值为读取到的字节</span><br><span class="line">int read(byte b[]):一次读取一组字节数据到数组B中,返回值为读取到的字节长度,当返回值为-1时表示读取结束</span><br><span class="line">int read(byte[],int off,int len);一次读取一组字节数据到数组b中,从off位置开始存储,存储len个字节</span><br><span class="line">返回值为读取到的字节长度,当返回值为-1时表示读取结束</span><br><span class="line"></span><br><span class="line">void close(); 关闭流对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-1-OutputStream-字节输出流顶级接口"><a href="#3-1-OutputStream-字节输出流顶级接口" class="headerlink" title="3.1.OutputStream(字节输出流顶级接口)"></a>3.1.OutputStream(字节输出流顶级接口)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法:</span><br><span class="line">void write(int b);一次写入一个字节</span><br><span class="line">void write(byte b[]);一次写入一组字节</span><br><span class="line">void write(byte b[],int off,int len);一次写入一组字节,从off位置开始,写入len</span><br><span class="line">void flush():冲刷</span><br><span class="line">void close();关流</span><br></pre></td></tr></table></figure><h4 id="3-2文件字节流"><a href="#3-2文件字节流" class="headerlink" title="3.2文件字节流"></a>3.2文件字节流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FileInputStream</span><br><span class="line">分类:</span><br><span class="line">输入流:文件到程序</span><br><span class="line">节点流</span><br><span class="line">FileOutputStream</span><br><span class="line">分类:</span><br><span class="line">输出流:程序到文件</span><br><span class="line">节点流</span><br></pre></td></tr></table></figure><h4 id="3-3内存流"><a href="#3-3内存流" class="headerlink" title="3.3内存流"></a>3.3内存流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:在读取数据过程中,因数据不全导致的乱码问题</span><br><span class="line">ByteArrayInputStream</span><br><span class="line">ByteArrayOutputStream</span><br><span class="line">特有方法:</span><br><span class="line">byte toByteArray();将内存流中的数据获取出来</span><br></pre></td></tr></table></figure><h4 id="3-4缓冲流"><a href="#3-4缓冲流" class="headerlink" title="3.4缓冲流"></a>3.4缓冲流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:提高读写效率</span><br><span class="line">注意:</span><br><span class="line">包装流</span><br><span class="line">BufferedInputStream</span><br><span class="line">BufferedOutputStream</span><br><span class="line"></span><br><span class="line">注意:默认缓冲区大小为8kb</span><br></pre></td></tr></table></figure><h4 id="3-5对象流"><a href="#3-5对象流" class="headerlink" title="3.5对象流"></a>3.5对象流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:将对象写入到文件中,或从文件中读取对象</span><br><span class="line">注意:</span><br><span class="line">1.读写的对象所属的类要实现序列化接口</span><br><span class="line">2.一个对象流只能读写一个对象</span><br><span class="line">3.存储的所有数据都必须进行序列化</span><br><span class="line">4.static修饰的属性,transient修饰的属性不参与序列化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ObjectInputStream</span><br><span class="line">readObject():读取对象,只读第一个</span><br><span class="line">ObjectOutputStream</span><br><span class="line">wirteObject();写入对象</span><br></pre></td></tr></table></figure><h3 id="4-字符流"><a href="#4-字符流" class="headerlink" title="4.字符流"></a>4.字符流</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传输的数据单位最小为字符(char)</span><br></pre></td></tr></table></figure><h4 id="字符流体系"><a href="#字符流体系" class="headerlink" title="字符流体系"></a>字符流体系</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reader</span><br><span class="line">概念:所有字符输入流的父类</span><br><span class="line">提供方法:</span><br><span class="line">int read(),一次获取一个字符,返回值为读取到的字符.</span><br><span class="line">int read(char c[]):一次去取一组字符到数组c中,返回值为读取到的字符长度,当为-1时表示读取结束</span><br><span class="line">int read(char c[],int off,int len)</span><br><span class="line">一次去取一组字符到数组c中,从off位置开始存储,存储len个,返回值为读取到的字符长度,当为-1时别是读取结束</span><br><span class="line">void close() 关闭</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wirter</span><br><span class="line">概念:所有字符输出流的父类</span><br><span class="line">提供的方法:</span><br><span class="line">void write(int c)</span><br><span class="line">void write(char cbuf[])</span><br><span class="line">void write(char cbuf[],int off,int len)</span><br><span class="line">void write(String str)</span><br><span class="line">void flush()</span><br><span class="line">void close()</span><br></pre></td></tr></table></figure><h4 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FileReader</span><br><span class="line">FileWriter</span><br></pre></td></tr></table></figure><h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BufferedReader</span><br><span class="line">readLine();读取一行</span><br><span class="line">BufferedWriter</span><br><span class="line">nextLine():写入下一行</span><br></pre></td></tr></table></figure><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InputStreamReader</span><br><span class="line">OutputStreamWriter</span><br></pre></td></tr></table></figure><h4 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PrintStream</span><br><span class="line">注意:字节流</span><br></pre></td></tr></table></figure><h3 id="5-File"><a href="#5-File" class="headerlink" title="5.File"></a>5.File</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念:文件或文件夹对应的类</span><br></pre></td></tr></table></figure><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建File类的对象</span><br><span class="line">2.调用属性或方法</span><br></pre></td></tr></table></figure><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">公共构造函数</span><br><span class="line">File(String pathname)</span><br><span class="line">pathname:文件或文件夹的路径</span><br><span class="line">File(String parent,String child)</span><br><span class="line">    parent:上级文件夹的路径</span><br><span class="line">    child:当前文件的名称.后缀名</span><br><span class="line">    File(File parent,String child)</span><br><span class="line">    parent:上级文件夹的file对象</span><br><span class="line">    child:当前文件的名称.后缀名</span><br><span class="line">    </span><br><span class="line">    File(URI uri)</span><br><span class="line">    uri:资源所在位置</span><br><span class="line">    如:</span><br><span class="line">    URI uri = URI.create(&quot;D:\\a.txt&quot;);</span><br><span class="line">    File file = new File(uri);</span><br><span class="line">  </span><br><span class="line">  注意:</span><br><span class="line">  路径分为绝对路径和相对路径</span><br><span class="line">  绝对路径:从盘符开始</span><br><span class="line">  相对路径:相对于项目路径下</span><br><span class="line">  注意:</span><br><span class="line">  . 当前路径</span><br><span class="line">  ..上级文件夹</span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性:"></a>属性:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static separator:获取当前系统的路径分隔符</span><br></pre></td></tr></table></figure><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir():创建一级文件夹</span><br><span class="line">mkdirs():创建多级文件夹</span><br><span class="line">createNewFile():创建一级文件</span><br><span class="line"></span><br><span class="line">delete():删除一级文件或一级文件夹</span><br><span class="line"></span><br><span class="line">getParent():获取上级文件夹路径</span><br><span class="line">getParentFile():获取上级文件夹的file对象</span><br><span class="line"></span><br><span class="line">getPath():获取当前路径</span><br><span class="line">getAbsolutePath():获取当前文件的绝对路径</span><br><span class="line">getAbsoluteFile():获取绝对路径文件</span><br><span class="line">isDirectory():判断是否为文件夹</span><br><span class="line">isFile()判断是否为文件</span><br><span class="line">exists():判断文件或文件夹是否存在</span><br><span class="line">length():获取文件大小,单位字节</span><br><span class="line">renameTo():修改文件名称</span><br><span class="line"></span><br><span class="line">File[] listFiles();</span><br><span class="line">File[] listFiles(FileFilter ff);</span><br><span class="line">File[] listFiles(FilenameFilter ff);</span><br><span class="line">获取当前文件夹下的文件或文件夹</span><br><span class="line">注意:</span><br><span class="line">FileFilter是文件过滤器</span><br><span class="line">重写的是boolean accept(File pathname)</span><br><span class="line">当返回值为true表示可以通过,反之false不通过</span><br><span class="line"></span><br><span class="line">FilenameFilter文件名称过滤器</span><br><span class="line">重写的是boolean accept(File f , String name)</span><br><span class="line">当返回值为true表示可以通过,反之false不通过</span><br><span class="line">f:父级文件对象</span><br><span class="line">name:当前文件名称</span><br></pre></td></tr></table></figure><h1 id="二十八-网络编程"><a href="#二十八-网络编程" class="headerlink" title="二十八.网络编程"></a>二十八.网络编程</h1><h3 id="1-网络相关概念"><a href="#1-网络相关概念" class="headerlink" title="1.网络相关概念"></a>1.网络相关概念</h3><p><strong>概念</strong>:两台设备之间通过网络实现数据通信</p><p><strong>网络通信</strong>:将数据通过网络从一台设备传输到另一台设备</p><p>java.net包提供了一系列的类或接口,供程序员使用,完成网络通信</p><h4 id="常用名词"><a href="#常用名词" class="headerlink" title="常用名词"></a>常用名词</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">互联网(Internet):点与点相连</span><br><span class="line">万维网(www):端与端相连</span><br><span class="line">物联网:物物互联</span><br><span class="line">网络编程:让计算机与计算机之间建立连接.</span><br></pre></td></tr></table></figure><h3 id="2-OSI网络架构"><a href="#2-OSI网络架构" class="headerlink" title="2.OSI网络架构"></a>2.OSI网络架构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简介</span><br><span class="line">open System Interconnect开放式系统互联</span><br><span class="line">存在于概念和理论上的一种模型,他的缺点是分层太多,增加了网络工作的复杂性,所以没有大规模应用</span><br></pre></td></tr></table></figure><p><img src="/2023/05/01/JAVA%E5%9F%BA%E7%A1%80/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230424171347594.png" alt="image-20230424171347594"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一层:物理层为设备之间的数据通信提供传输信号和物理介质(双绞线,光导纤维)</span><br><span class="line">作用:建立/维护/断开物理连接.</span><br><span class="line"></span><br><span class="line">第二层:链路层在物理层上,通过规程或协议(差错控制)来控制传输数据的正确性(MAC)</span><br><span class="line">作用:接受来自物理层的位流形式的数据,并封装成帧,传送到上一层,同样,也将来自上层的数据帧,拆装为位流形式的数据转发到物理层,并且还负责处理接收端发回的确认帧的信息,以便提供可靠的数据传输</span><br><span class="line"></span><br><span class="line">第三层:网络层负责定义了能够标识所有网络节点的逻辑地址(IP地址)</span><br><span class="line">作用:逻辑寻址,Ip地址,在下两层的基础上向资源子网提供服务</span><br><span class="line"></span><br><span class="line">第四层:传输层负责是否选择差错回复协议,数据流重用,错误顺序排序(tcp,udp)</span><br><span class="line">作用:提供可靠的和不可靠的传输机制TCP/UDP</span><br><span class="line"></span><br><span class="line">第五层:会话层负责使应用建立和维持会话,使通信在失败时继续恢复通信(断电续传)</span><br><span class="line">作用:建立/终止/管理实体间会话连接</span><br><span class="line"></span><br><span class="line">第六层:表示层负责定义转换数据格式及加密,允许选择以二进制或ASCII格式传输</span><br><span class="line">作用:分装数据格式(加密解密,压缩解压缩)</span><br><span class="line"></span><br><span class="line">第七层:应用层负责文件访问和管理/可靠运输服务,远程操作服务(HTTP/FTP/SMTP)</span><br><span class="line">作用:人与机器电脑交互的窗口</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-IP地址"><a href="#3-IP地址" class="headerlink" title="3.IP地址"></a>3.IP地址</h3><h4 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址:"></a>ip地址:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.概念:用于标识网络中的每台计算机/主机</span><br><span class="line">2.查看ip地址:ipconfig</span><br><span class="line">3.ip地址的表现形式:点分十进制  xx.xx.xx.xx</span><br><span class="line">4.每一个十进制的范围是0-255</span><br><span class="line">5.IP地址的组成= 网络地址+主机地址</span><br><span class="line">6.ipv6是互联网工程任务组设计的用于代替ipv4的下一代ip协议，其地址数量号称可以为全世界每一粒沙子编上一个地址</span><br><span class="line">7.由于ipv4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。ipv6的使用，不仅解决了网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍</span><br></pre></td></tr></table></figure><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.www.baidu.com</span><br><span class="line">2.好处:方便记忆,解决记忆ip的困难</span><br><span class="line">3.概念:将ip地址映射成域名</span><br></pre></td></tr></table></figure><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.概念:用于标识计算机上某个特定的网络程序</span><br><span class="line">2.表现形式:以整数形式,范围0-65535</span><br><span class="line">3.0-1024已经被占用,比如:ssh 22, ftp 21,smtp 25,http 80</span><br><span class="line">4.常见的网络端口号</span><br><span class="line">tomcat:8080</span><br><span class="line">musql:3306</span><br><span class="line">oracle:1521</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-通信协议"><a href="#4-通信协议" class="headerlink" title="4.通信协议"></a>4.通信协议</h3><h4 id="TCP-x2F-IP网络框架"><a href="#TCP-x2F-IP网络框架" class="headerlink" title="TCP&#x2F;IP网络框架"></a>TCP&#x2F;IP网络框架</h4><p><img src="/2023/05/01/JAVA%E5%9F%BA%E7%A1%80/Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230424174928746.png" alt="image-20230424174928746"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP协议:传输控制协议</span><br><span class="line">是一种面向连接的/可靠的/基于字节流的传输层通信协议.数据大小无限制.建立连接的过程需要三次握手,断开连接的过程需要四次挥手,  在连接中可进行大数据量的传输；传输完毕，需释放已建立的连接，效率低。</span><br><span class="line"></span><br><span class="line">UDP协议:用户数据报协议</span><br><span class="line">是一种无连接的传输层协议,提供面向事物的简单不可靠信息传送服务,每个包的大小64kb,因无需连接，故是不可靠的；发送数据结束时无需释放资源（因为不是面向连接的），速度快；</span><br></pre></td></tr></table></figure><h3 id="5-InetAddress"><a href="#5-InetAddress" class="headerlink" title="5.InetAddress"></a>5.InetAddress</h3><p><strong>功能:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.获取本机InetAddress对象,getLocalHost</span><br><span class="line">2.根据指定主机名/域名获取IP地址对象,getByName</span><br><span class="line">3.获取InetAddress对象的主机名getHostNmae</span><br><span class="line">4.获取InetAddress对象的地址getHostAddress</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取主机名+ip地址</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">System.out.println(localHost);</span><br><span class="line"><span class="comment">//获取主机名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">hostName</span> <span class="operator">=</span> localHost.getHostName();</span><br><span class="line">System.out.println(hostName);</span><br><span class="line"></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">byName</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;DESKTOP-HT1OC9N&quot;</span>);</span><br><span class="line">System.out.println(byName);</span><br></pre></td></tr></table></figure><h3 id="6-Socket编程"><a href="#6-Socket编程" class="headerlink" title="6.Socket编程"></a>6.Socket编程</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socket:套接字,网络中的一个节点</span><br><span class="line">通讯要求:地址+端口号</span><br></pre></td></tr></table></figure><h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP:面向有连接,安全可靠的,速度慢</span><br><span class="line">特点:三次握手,四次挥手</span><br><span class="line"></span><br><span class="line">UDP:面向无连接,不安全,速度快</span><br></pre></td></tr></table></figure><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简介:是一种面向连接的/可靠的/基于字节流的传输层通信协议,数据大小无限制,建立连接过程需要三次握手,断开连接的过程需要四次挥手</span><br><span class="line">注意:分为客户端Socket与服务器ServerSocket</span><br></pre></td></tr></table></figure><h4 id="服务端开发步骤"><a href="#服务端开发步骤" class="headerlink" title="服务端开发步骤"></a>服务端开发步骤</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建ServerSocket,指定端口</span><br><span class="line">2.调用accept等待客户端接入</span><br><span class="line">3.使用输入流,接收客户端请求中的数据</span><br><span class="line">4.使用输出流,给客户端回馈数据(可选)</span><br><span class="line">5.关闭释放资源</span><br></pre></td></tr></table></figure><h4 id="客户端开发步骤"><a href="#客户端开发步骤" class="headerlink" title="客户端开发步骤"></a>客户端开发步骤</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建Socket对象,指定服务器IP+端口</span><br><span class="line">2.使用输出流,发起请求,给服务器发送数据</span><br><span class="line">3.使用输入流,界海服务器返回的数据(可选)</span><br><span class="line">4.关闭释放资源</span><br></pre></td></tr></table></figure><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简介:UDP协议是一种不可靠的网络协议,提供面向事务的简单不可靠信息传送服务,每个包的大小64kb</span><br><span class="line">分为:接收端与发送端</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="发送端开发步骤"><a href="#发送端开发步骤" class="headerlink" title="发送端开发步骤"></a>发送端开发步骤</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建发送端的Socket对象(DatagramSocket)</span><br><span class="line">2.创建数据,并打包</span><br><span class="line">3.调用DatagramSocket对象的方法发送数据</span><br><span class="line">4.关闭发送端</span><br></pre></td></tr></table></figure><h4 id="接收端开发步骤"><a href="#接收端开发步骤" class="headerlink" title="接收端开发步骤"></a>接收端开发步骤</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建发送端Socket(DatagramSocket)</span><br><span class="line">2.创建一个数据包,用于接收数据</span><br><span class="line">3.调用DatagramSocket对象的方法接受数据</span><br><span class="line">4.解析数据包,在控制台显示</span><br><span class="line">5.关闭接收端</span><br></pre></td></tr></table></figure><h1 id="二十九-反射"><a href="#二十九-反射" class="headerlink" title="二十九.反射"></a>二十九.反射</h1><h3 id="1-反射机制"><a href="#1-反射机制" class="headerlink" title="1.反射机制"></a>1.反射机制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息(如成员变量,成员方法,构造器)并能操作对象的属性及方法,反射在设计模式和框架底层都会用到</span><br><span class="line">2.加载完类之后,在堆中就产生了一个class对象(一个类只有一个class对象)这个对象包含了类的完整结构信息,通过这个对象得到类的结构,这个对象就像一面镜子,透过这个镜子看到类的结构,所以称为反射</span><br></pre></td></tr></table></figure><h3 id="2-类对象"><a href="#2-类对象" class="headerlink" title="2.类对象"></a>2.类对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个类被加载时会产生一个对象,该对象称为该类的类对象,该对象属于Class类的对象</span><br><span class="line"></span><br><span class="line">类对象中包含该类的所有信息,如包,实现的接口,类名,属性,方法,构造函数,注解等内容</span><br><span class="line"></span><br><span class="line">注意:一个类只有一个类对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-java反射机制可完成的任务"><a href="#3-java反射机制可完成的任务" class="headerlink" title="3.java反射机制可完成的任务:"></a>3.java反射机制可完成的任务:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.在运算时判断任意一个对象所属的类</span><br><span class="line">2.在运行时构造任意一个类的对象</span><br><span class="line">3.在运行时得到任意一个类所具有的成员变量和方法</span><br><span class="line">4.在运行时调用任意一个对象的成员变量和方法&#x27;</span><br><span class="line">5.生成动态代理</span><br></pre></td></tr></table></figure><h3 id="4-反射相关的主要类"><a href="#4-反射相关的主要类" class="headerlink" title="4.反射相关的主要类"></a>4.反射相关的主要类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. java.lang.Class代表一个类,Class对象表示某个类加载后在堆中的对象</span><br><span class="line">2.java.lang.reflect.Field 代表类的成员变量,Filed对象表示某个类的成员变量//getFiled不能得到私有属性</span><br><span class="line">3.java.lang.reflect.Method 代表类方法,Method对象表示某个类的方法</span><br><span class="line">4.java.lang.reflect.Constructor 代表类的构造方法Constructor对象表示构造器(),括号内可以指定参数类型,String.class</span><br></pre></td></tr></table></figure><h3 id="5-反射的优缺点"><a href="#5-反射的优缺点" class="headerlink" title="5.反射的优缺点"></a>5.反射的优缺点</h3><p>​<strong>优点</strong></p><p>​可以动态的创建和使用对象,使用灵活,没有反射机制,框架技术就失去了底层支撑</p><p>​<strong>缺点</strong></p><p>​使用反射机制基本都是解释执行,对执行速度有影响</p><h3 id="6-如何获取类对象"><a href="#6-如何获取类对象" class="headerlink" title="6.如何获取类对象"></a>6.如何获取类对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式1:类名.class</span><br><span class="line">方式2.对象名.getClass()</span><br><span class="line">方式3:Class.forName(&quot;类的全路径&quot;)</span><br><span class="line">类的全路径:类所属的包名+类名</span><br></pre></td></tr></table></figure><h3 id="7-类对象-Class类"><a href="#7-类对象-Class类" class="headerlink" title="7.类对象(Class类)"></a>7.类对象(Class类)</h3><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Class也是类,因此也继承Object类</span><br><span class="line">2.Class类对象不是new出来的,而是系统创建的</span><br><span class="line">3.对于某个类的Class对象,在内存中只有一份,因为类只加载一次</span><br><span class="line">4.每个类的实例都会记得自己由那个Class实例所生成</span><br><span class="line">5.通过Class可以完整的得到一个类的完整结构,通过一系列API</span><br><span class="line">6.Class对象存放在堆中</span><br><span class="line">7.类的字节码二进制数据,是在方法区的,有的地方称为类的元数据(包括方法代码,变量名,方法名,访问权限)</span><br></pre></td></tr></table></figure><h5 id="提供的方法"><a href="#提供的方法" class="headerlink" title="提供的方法"></a>提供的方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类相关:</span><br><span class="line">包</span><br><span class="line">Pckage getPackage()</span><br><span class="line">类名</span><br><span class="line">    String getSimpleName()</span><br><span class="line">    类的全路径名</span><br><span class="line">    String getName()</span><br><span class="line">    父类的类对象</span><br><span class="line">    Class&lt;? super T&gt; getSuperclass()</span><br><span class="line">    接口的类对象</span><br><span class="line">    Class&lt;?&gt;[] getInterface()</span><br><span class="line">    调用缺省构造函数,返回该Class对象的一个实例</span><br><span class="line">     Object newInstance()</span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">属性相关</span><br><span class="line">获取所有的公共属性,包含父类提供的公共属性</span><br><span class="line">Field[] getFields();</span><br><span class="line">获取所有的属性,不包含父类提供的</span><br><span class="line">    Field[] getDeclaredField()</span><br><span class="line">    获取指定的公共属性</span><br><span class="line">    Field getField(String name)</span><br><span class="line">    获取指定的属性</span><br><span class="line">    Field getDeclaredField(String name)</span><br><span class="line">    Field提供的方法</span><br><span class="line">    Object get(Object obj);</span><br><span class="line">    作用:获取指定对象的该属性值</span><br><span class="line">    1参:指定对象</span><br><span class="line">    void set(Object obj,Object v)</span><br><span class="line">    作用:修改指定对象的改属性值</span><br><span class="line">    1参:指定的对象</span><br><span class="line">    2参:修改后的值</span><br><span class="line">    setAccessible(boolean flag) 是否略过访问权限修饰符</span><br><span class="line">        默认为false,表示不略过</span><br><span class="line">        当值为true表示略过</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法相关</span><br><span class="line">获取所有的公共方法,包含父类提供的</span><br><span class="line">Method[] getMethods()</span><br><span class="line"></span><br><span class="line">获取所有的方法,不包含父类</span><br><span class="line">Method[] getDeclaredMethods()</span><br><span class="line"></span><br><span class="line">获取单独一个公共的方法</span><br><span class="line">    Method getMethod(String name,Class&lt;?&gt;...parameterTypes)</span><br><span class="line">    1参:要获取的方法名</span><br><span class="line">    2参:该方法的形参列表对应的数据类型的对象</span><br><span class="line">    注意:按顺序书写,基本数据类型的类对象是数据类型.class,其包装类的类对象是类名.class</span><br><span class="line">    </span><br><span class="line">    获取单独一个方法</span><br><span class="line">    Method getDeclaredMethod(Stirng name,Class&lt;?&gt;...parameterTypes)</span><br><span class="line">    1参:要获取的方法名</span><br><span class="line">    2参:该方法的形参列表对应的数据类型的类对象</span><br><span class="line">    注意:按顺序书写,基本数据类型的类对象是数据类型.class,其包装类的类对象是类名.class</span><br><span class="line">    </span><br><span class="line">    Method提供的方法</span><br><span class="line">    Object invoke(Object obj,Object...args)</span><br><span class="line">    作用:执行该方法</span><br><span class="line">    1.执行该方法的对象</span><br><span class="line">    2参:执行该方法所需要的实参列表</span><br><span class="line">    返回值:执行该方法的返回值</span><br><span class="line">    </span><br><span class="line">    setAccessible(boolean flag) 是否略过访问权限修饰符</span><br><span class="line">        默认为false,表示不略过</span><br><span class="line">        当值为true表示略过</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造函数相关</span><br><span class="line">Constructor&lt;?&gt;[] getConstructors()</span><br><span class="line">作用:获取该类中所有的公共构造函数</span><br><span class="line"></span><br><span class="line">Constructor&lt;?&gt;[] getDeclaredConstructors()</span><br><span class="line">    作用:获取所有的构造函数</span><br><span class="line">    </span><br><span class="line">    Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;...parameterTypes)</span><br><span class="line">    作用:获取指定的一个构造函数</span><br><span class="line">    参数:构造函数对比的形参列表的数据类型的类对象</span><br><span class="line">    </span><br><span class="line">    Constructor提供的方法</span><br><span class="line">        Class&lt;?&gt;[] getInterface()</span><br><span class="line">    调用缺省构造函数,返回该Class对象的一个实例</span><br><span class="line">     Object newInstance()</span><br></pre></td></tr></table></figure><h1 id="三十-枚举"><a href="#三十-枚举" class="headerlink" title="三十.枚举"></a>三十.枚举</h1><h3 id="1-使用步骤"><a href="#1-使用步骤" class="headerlink" title="1.使用步骤"></a>1.使用步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.定义</span><br><span class="line">2.使用</span><br></pre></td></tr></table></figure><h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2.定义:"></a>2.定义:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">访问权限修饰符 enum 枚举名(</span><br><span class="line">属性名1,属性名2,属性名2,....属性名n</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">情况1:</span><br><span class="line">使用枚举的属性</span><br><span class="line">语法:枚举名.属性名</span><br><span class="line"></span><br><span class="line">情况2:</span><br><span class="line">枚举作为形参</span><br><span class="line">传递实参时必须传入枚举的属性</span><br></pre></td></tr></table></figure><h3 id="4-自定义枚举"><a href="#4-自定义枚举" class="headerlink" title="4.自定义枚举"></a>4.自定义枚举</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1不需要提供set方法,枚举对象值通常为只读</span><br><span class="line">2.对枚举对象/属性使用final static共同修饰,实现底层优化</span><br><span class="line">3.枚举对象名通常全部大写,常量的命名规范</span><br><span class="line">4.枚举对象根据需要,也可以有多个属性]</span><br></pre></td></tr></table></figure><h4 id="5-特点"><a href="#5-特点" class="headerlink" title="5.特点"></a>5.特点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.构造器私有化</span><br><span class="line">2.本类内创建一组对象 public static final 类型名</span><br><span class="line">3.对外暴露对象(通过为对象添加public static final修饰符)</span><br><span class="line">4.可以提供get方法,不提供set方法</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ol><li>当我们使用enum关键字开发一个枚举时，默认会继承Enum类，而且是一个final类</li><li>传统的public final static  Season01 SPRING&#x3D;new Season01(“春天”,”温暖”);简化成 SPRING(“春天”,”温暖”);，这里必须知道它调用的那个构造器</li><li>如果使用无参构造器  创建枚举对象，则实参列表和小括号可以省略</li><li>当有多个枚举对象时，使用逗号间隔，最后用分号结尾</li><li>枚举对象必须放在枚举类的首行</li></ol><p><strong>常用方法：</strong></p><p><strong>说明；</strong>使用关键字enum时，会隐式继承enum，这样我们就可以使用Enum类相关的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Enum</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt;</span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;E&gt;, Serializable&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>toString :Enum类已经重写过，返回当前对象名，子类可以重写该方法，用于返回对象的属性信息</li><li>name：返回当前对象名，子类中不能重写</li><li>ordinal：返回当前对象的位置号，默认从0开始</li><li>values：返回当前枚举类中所有常量</li><li>valueOf：将字符串装换成枚举对象，要求字符串必须为已有的常量名，否则报异常</li><li>compareTo：比较两个枚举常量，比较的就是位置号</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Week[] values = Week.values();</span><br><span class="line">    <span class="keyword">for</span> (Week week:values) &#123;<span class="comment">//增强for循环</span></span><br><span class="line">        System.out.println(week);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>细节：</strong></p><ul><li>使用enum关键字后，就不能继承其他类，因为enum会隐式继承Enum，而java是单继承机制</li><li>枚举和普通类一样，可以实现接口：enum  类名   implements  接口1，接口2{}</li></ul><h1 id="三十一-注解"><a href="#三十一-注解" class="headerlink" title="三十一.注解"></a>三十一.注解</h1><blockquote><p>作用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解释代码的代码,称为注解,又名元代码</span><br></pre></td></tr></table></figure><p>注释与注解的区别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注释:不会影响代码</span><br><span class="line">注解:对代码有一定的约束作用</span><br></pre></td></tr></table></figure><p>常见的注解</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">作用:说明当前方法为重写的方法</span><br><span class="line">@SuppressWarnings(&quot;all&quot;)</span><br><span class="line">作用:忽略警告</span><br><span class="line"></span><br><span class="line">元注解</span><br><span class="line">概念:解释注解的注解</span><br><span class="line">@Target</span><br><span class="line">  作用:注解使用位置</span><br><span class="line">  值:</span><br><span class="line">  TYPE:类,接口,枚举上使用</span><br><span class="line">FIELD:属性上使用</span><br><span class="line">METHOD:方法使用</span><br><span class="line">PARAMETER:参数上使用</span><br><span class="line">CONSTRUCTOR:构造函数</span><br><span class="line">LOCAL_VARIABLE:局部变量使用</span><br><span class="line">ANNOTATION_TYPE:注解使用</span><br><span class="line">PACKAGE:包使用</span><br><span class="line">注意:没有写可以在任何地方使用</span><br><span class="line"></span><br><span class="line">@Retention</span><br><span class="line">  作用:注解作用时机</span><br><span class="line">  值:</span><br><span class="line">  SOURCE:java源程序中存在</span><br><span class="line">CLASS:字节码文件中存在</span><br><span class="line">RUNTIME:运行时存在</span><br><span class="line"></span><br><span class="line">@Documented</span><br><span class="line">  作用:可以生成API文档</span><br><span class="line">  </span><br><span class="line">@Inherited</span><br><span class="line">  作用:说明当前注解是否可以被子类继承,默认不能被子类继承</span><br></pre></td></tr></table></figure><p>自定义注解</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">访问权限修饰符 @interface 注解名&#123;</span><br><span class="line">数据类型 属性名1() [default 默认值];</span><br><span class="line">数据类型 属性名2() [default 默认值];</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@注解名(属性名 = 属性值,属性名 = 属性值,...);</span><br><span class="line">注意:</span><br><span class="line">1,当注解中的属性有默认值,可以在使用注解时不用赋值</span><br><span class="line">2,当注解中所有属性都有默认值或没有属性时,可以省略小括号不写</span><br><span class="line">@注解名</span><br><span class="line">3,当注解中只有一个属性,并且该属性的属性名为value,此时在使用注解时可以省略属性名不写</span><br><span class="line">@注解名(属性值)</span><br></pre></td></tr></table></figure></blockquote><h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JAVA基础&quot;&gt;&lt;a href=&quot;#JAVA基础&quot; class=&quot;headerlink&quot; title=&quot;JAVA基础&quot;&gt;&lt;/a&gt;JAVA基础&lt;/h1&gt;&lt;h2 id=&quot;一、准备阶段W&quot;&gt;&lt;a href=&quot;#一、准备阶段W&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java基础知识" scheme="http://example.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="http://example.com/2023/05/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2023/05/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-05-01T08:09:13.000Z</published>
    <updated>2023-05-03T06:10:09.455Z</updated>
    
    <content type="html"><![CDATA[<p>hexo new “”</p><p>hexo g </p><p>hexo d</p><p>hexo s</p><h1 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h1><ol><li>删除<code>.deploy_git</code>文件夹;</li><li>输入<code>git config --global core.autocrlf false</code></li><li>然后，依次执行：<br><code>hexo clean</code><br><code>hexo g</code><br><code>hexo d</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hexo new “”&lt;/p&gt;
&lt;p&gt;hexo g &lt;/p&gt;
&lt;p&gt;hexo d&lt;/p&gt;
&lt;p&gt;hexo s&lt;/p&gt;
&lt;h1 id=&quot;解决办法：&quot;&gt;&lt;a href=&quot;#解决办法：&quot; class=&quot;headerlink&quot; title=&quot;解决办法：&quot;&gt;&lt;/a&gt;解决办法：&lt;/h1</summary>
      
    
    
    
    <category term="默认" scheme="http://example.com/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
  </entry>
  
</feed>
