<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>半糖</title>
  
  <subtitle>耐得住寂寞,才能享受繁华</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-03T06:06:55.367Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>冯家鹏</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java基础练习--学生管理系统</title>
    <link href="http://example.com/2023/05/03/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2023/05/03/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</id>
    <published>2023-05-03T05:57:55.000Z</published>
    <updated>2023-05-03T06:06:55.367Z</updated>
    
    <content type="html"><![CDATA[<p>java基础学习结束,写一个学生信息管理系统,包括增加学生信息,删除学生信息,查找学生信息,更改学生信息.</p><blockquote><p>增加学生信息</p><pre><code>从键盘录入学生的基本信息,存入txt文件,达到持久化存储</code></pre><p>删除学生信息</p><pre><code>遍历集合中存储的信息,根据学生的学号删除学生xinx</code></pre><p>查找学生信息</p><pre><code>查找学生信息    查找全部    根据学号查找</code></pre><p>修改学生信息</p><pre><code>根据学号进行更改</code></pre></blockquote><p>代码:</p><p>​学生类(Student)</p><pre><code class="java">package studentmassagesystem;import java.io.Serializable;/** * Description: * date: 2023/5/3 8:54 * @author fjp * @version 1.0 */public class Student implements Serializable &#123;    /**     * 学号     */    private String id;    /**     * 姓名      */    private String name;    /**     * 性别     */    private String sex;    /**     * 电话     */    private String phone;    /**     * 班级     */    private String grade;    /**     * 学院     */    private String collage;    public Student() &#123;    &#125;    public Student(String id ,String name, String sex, String phone, String grade, String collage) &#123;        this.id = id;        this.name = name;        this.sex = sex;        this.phone = phone;        this.grade = grade;        this.collage = collage;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getSex() &#123;        return sex;    &#125;    public void setSex(String sex) &#123;        this.sex = sex;    &#125;    public String getPhone() &#123;        return phone;    &#125;    public void setPhone(String phone) &#123;        this.phone = phone;    &#125;    public String getGrade() &#123;        return grade;    &#125;    public void setGrade(String grade) &#123;        this.grade = grade;    &#125;    public String getCollage() &#123;        return collage;    &#125;    public void setCollage(String collage) &#123;        this.collage = collage;    &#125;    public String getId() &#123;        return id;    &#125;    public void setId(String id) &#123;        this.id = id;    &#125;    @Override    public String toString() &#123;        return id +&quot;\t    &quot;+name+&quot;\t&quot;+sex+&quot;\t    &quot;+phone+&quot;\t    &quot;+grade+&quot;\t    &quot;+collage+&quot;\t&quot;;    &#125;&#125;</code></pre><p>工具类(实现具体的增删查改,创建输入输出流)</p><pre><code class="java">package studentmassagesystem;import java.io.*;import java.util.ArrayList;import java.util.Scanner;/** * Description: * date: 2023/5/3 9:01 * @author fjp * @version 1.0 * 学生管理系统的工具类 */public class StudentUtil &#123;    private static ArrayList&lt;Student&gt; list;    /**     * 创建一个输入流读取文件中的学生信息,完成持久化存储     * 添加学生信息,存储到文件中     * 静态代码块只执行一次     */    static &#123;        try &#123;            //创建一个文件字节输入流,将student.txt的内容读取到程序,进行操作            FileInputStream fileInputStream = new FileInputStream(&quot;student.txt&quot;);            //将创建的输入流,转为对象输入流,这里要对Student进行操作            ObjectInputStream objectInputStream = new ObjectInputStream(fileInputStream);                //读取对象                Object object = objectInputStream.readObject();                //将读取到的对象赋值给Arraylist,这里是将内存地址给了list                list = (ArrayList&lt;Student&gt;) object;        &#125; catch (Exception e) &#123;            //list指向新的引用            list = new ArrayList&lt;&gt;();        &#125;    &#125;    public static void addMessage() &#123;       keyBoard();        try &#123;            writeFile();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;添加成功!&quot;);    &#125;    /**     * 根据学号删除学生信息     */    public static void deleteMessage()&#123;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;请输入要删除的学生学号:&quot;);        String id = scanner.next();        for (Student student : list) &#123;            if (student.getId().equals(id))&#123;                list.remove(student);                System.out.println(&quot;删除成功&quot;);                try &#123;                    writeFile();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;                return;            &#125;            System.out.println(&quot;未找到学号为&quot;+id+&quot;的学生&quot;);        &#125;    &#125;    /**     * 查找所有学生信息     */    public static void showMessage()&#123;        System.out.println(&quot;学号\t&quot;+&quot;姓名\t&quot; +&quot;性别\t&quot;+&quot;电话\t&quot;+&quot;班级\t&quot;+&quot;学院\t&quot;);        for (Student student : list) &#123;            System.out.println(student);        &#125;    &#125;    public static void showIdMessage()&#123;        System.out.println(&quot;请输入要查找的学生学号:&quot;);        Scanner scanner = new Scanner(System.in);        String id = scanner.next();        for (Student student : list) &#123;            if (student.getId().equals(id))&#123;                System.out.println(&quot;学号\t&quot;+&quot;姓名\t&quot; +&quot;性别\t&quot;+&quot;电话\t&quot;+&quot;班级\t&quot;+&quot;学院\t&quot;);                System.out.println(student);                break;            &#125;            System.out.println(&quot;未找到学号为&quot;+id+&quot;的学生&quot;);        &#125;    &#125;    /**     * 根据学号修改学信息     */    public  static void modifyMessage()&#123;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;请输入要修改的学生学号:&quot;);        String id = scanner.next();        for (Student student : list) &#123;            if (student.getId().equals(id))&#123;                System.out.println(&quot;输入修改后的内容:&quot;);                System.out.println(&quot;姓名:&quot;);                String newName = scanner.next();                System.out.println(&quot;性别:&quot;);                String newSex = scanner.next();                System.out.println(&quot;电话:&quot;);                String newPhone = scanner.next();                System.out.println(&quot;班级:&quot;);                String newGrade = scanner.next();                System.out.println(&quot;学院:&quot;);                String newCollage = scanner.next();                student.setName(newName);                student.setSex(newSex);                student.setPhone(newPhone);                student.setGrade(newGrade);                student.setCollage(newCollage);                try &#123;                    writeFile();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;                System.out.println(&quot;修改成功&quot;);                return;            &#125;            System.out.println(&quot;未找到学号为&quot;+id+&quot;的学生&quot;);        &#125;    &#125;    /**     * 键盘输入的方法,从键盘录入学生信息     */    public static void keyBoard()&#123;        Scanner scanner = new Scanner(System.in);        System.out.println(&quot;请输入学生学号:&quot;);        String id = scanner.next();        //判断是否存在        for (Student student : list) &#123;            if (student.getId().equals(id))&#123;                System.out.println(&quot;该学生已存在,请重新输入&quot;);                keyBoard();            &#125;        &#125;        System.out.println(&quot;请输入学生姓名:&quot;);        String name = scanner.next();        System.out.println(&quot;请输入性别:&quot;);        String sex = scanner.next();        System.out.println(&quot;请输入联系方式:&quot;);        String phone = scanner.next();        System.out.println(&quot;请输入班级:&quot;);        String grade = scanner.next();        System.out.println(&quot;请输入学院:&quot;);        String collage = scanner.next();        Student student1 = new Student();        student1.setId(id);        student1.setName(name);        student1.setSex(sex);        student1.setPhone(phone);        student1.setGrade(grade);        student1.setCollage(collage);        list.add(student1);    &#125;    /**     * 将list写入文本文件中     * @throws IOException     */    private synchronized static void writeFile() throws IOException &#123;        //创建文件输出流,对象输出流        FileOutputStream fileOutputStream =null;        ObjectOutputStream objectOutputStream = null;        //将内容写入到txt文件        fileOutputStream = new FileOutputStream(&quot;student.txt&quot;);        //文件输出流转对象输出流        objectOutputStream = new ObjectOutputStream(fileOutputStream);        //将list写入文件        objectOutputStream.writeObject(list);        //冲刷        objectOutputStream.flush();        //关闭资源        objectOutputStream.close();        fileOutputStream.close();&#125;&#125;</code></pre><p>启动类(Application)</p><pre><code class="java">package studentmassagesystem;import com.sun.org.apache.bcel.internal.generic.BREAKPOINT;import java.util.Scanner;/** * Description: * date: 2023/5/3 10:26 * * @author fjp * @version 1.0 */@SuppressWarnings(&quot;all&quot;)public class Application &#123;    public static void main(String[] args) &#123;        while(true)&#123;            System.out.print(&quot;------------------------------------------------------------------\n&quot;);            System.out.print(&quot;|                 xxxxxx学生管理系统                                |\n&quot;);            System.out.print(&quot;| 1.增加学生    2.删除学生   3.查找学生信息   4.修改学生信息   5.退出 |\n&quot;);            System.out.print(&quot;-------------------------------------------------------------------\n&quot;);            System.out.println(&quot;请输入要执行的操作(eg:1/2/3/4/5):&quot;);            Scanner scanner = new Scanner(System.in);            int tag = scanner.nextInt();            switch (tag)&#123;                case 1:                    StudentUtil.addMessage();                    break;                case 2:                    StudentUtil.deleteMessage();                    break;                case 3:                    boolean tag1 = true;                    while (tag1)&#123;                        System.out.println(&quot;1.查找全部学生信息   2.根据学号查找  3.返回上一级&quot;);                        int i = scanner.nextInt();                        if (i==1)&#123;                            StudentUtil.showMessage();                        &#125;                        if (i==2)&#123;                            StudentUtil.showIdMessage();                        &#125;                        if (i==3)&#123;                            tag1=false;                        &#125;                    &#125;                    break;                case 4:                    StudentUtil.modifyMessage();                    break;                case 5:                    return;            &#125;        &#125;    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;java基础学习结束,写一个学生信息管理系统,包括增加学生信息,删除学生信息,查找学生信息,更改学生信息.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;增加学生信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;从键盘录入学生的基本信息,存入txt文件,达到持久化存储
&lt;/code&gt;&lt;/pre</summary>
      
    
    
    
    <category term="java练习" scheme="http://example.com/categories/java%E7%BB%83%E4%B9%A0/"/>
    
    
    <category term="学生管理系统" scheme="http://example.com/tags/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础</title>
    <link href="http://example.com/2023/05/01/JAVA%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2023/05/01/JAVA%E5%9F%BA%E7%A1%80/</id>
    <published>2023-05-01T12:08:37.000Z</published>
    <updated>2023-05-01T12:09:49.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><h2 id="一、准备阶段W"><a href="#一、准备阶段W" class="headerlink" title="一、准备阶段W"></a>一、准备阶段W</h2><h2 id="1-JAVA的执行流程"><a href="#1-JAVA的执行流程" class="headerlink" title="1.JAVA的执行流程"></a>1.JAVA的执行流程</h2><pre><code>.Java文件（源文件）——&gt;javac编译——&gt;.class文件（字节码文件）——&gt;java运行——&gt;结果</code></pre><h2 id="2-开发细节"><a href="#2-开发细节" class="headerlink" title="2.开发细节"></a>2.开发细节</h2><pre><code>1.区分大小写2.Java方法是一条语句，以分号结束3.大括号成对出现4.一个Java文件中只能有一个public类。其它类个数不限。5.如果源文件包含一个public类，则文件名必须按照该类名命名。6.一个源文件中最多只能有一个public类，其他类个数不限，也可以将main方法写在非public类中，然后指定运行非public类，这样入口方法就是非public的main方法。</code></pre><h2 id="3-命名规则"><a href="#3-命名规则" class="headerlink" title="3..命名规则"></a>3..命名规则</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><pre><code>1.有字母数字下划线组成2.数字不能开头3.不能使用关键字和保留字，但可以包含关键字和保留字4.Java中严格区分大小写，长度无限制5.标识符不能包含空格6.不能使用特殊符号,除$和_</code></pre><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><pre><code>1.包名，多单词组成时所有字母都小写。如aaa.bbb.ccc2.类名，接口名,注解名,枚举名:多单词组成时，所有单词首字母都大写。如：TalkBankGame3.变量名，方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写。如aaaBbbCcc4.常量名：所有的字母都大写，多单词时每个单词用下划线连接。XXX_YYY_ZZZ</code></pre><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><h2 id="1-整型"><a href="#1-整型" class="headerlink" title="1.整型"></a>1.整型</h2><pre><code>int 整型 4字节short 短整型 2字节long  长整型 8字节，对于long需要加上L或l后缀区分byte  1字节</code></pre><h2 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2.浮点型"></a>2.浮点型</h2><pre><code>1.float：单精度浮点型  4字节，后缀加f2.double：双精度浮点型   8字节</code></pre><h2 id="3-字符型"><a href="#3-字符型" class="headerlink" title="3.字符型"></a>3.字符型</h2><pre><code>char 字符型  2字节，用单引号括起来，仅有一个字符注意：1)字符常量用单引号‘ ’2）java中允许使用转义符‘\’来将其后的字符转换为特殊字符常量    例如：char a=‘\n’;表示换行符3）在java中，char的本质是一个整数，在输出时，是Unicode码对应的字符4）可以直接给char附一个整数，然后输出时，会按照对应的Unicode字符输出5)char‘类型是可以进行运算的，相当于一个整数，因为都有对应的Unicode码</code></pre><h2 id="4-Boolean"><a href="#4-Boolean" class="headerlink" title="4.Boolean"></a>4.Boolean</h2><pre><code>布尔型，值为true和false</code></pre><h2 id="5-引用数据类型"><a href="#5-引用数据类型" class="headerlink" title="5.引用数据类型"></a>5.引用数据类型</h2><pre><code>除过上述的四种基本数据类型，其余都是引用数据类型常用的String用于定义字符串</code></pre><h2 id="6-基本数据类型转换"><a href="#6-基本数据类型转换" class="headerlink" title="6.基本数据类型转换"></a>6.基本数据类型转换</h2><pre><code>精度小的自动转换为精度大的数据类型：自动类型转换数据类型按照精度大小排序为(规则)：char ——&gt;int ——&gt;long ——&gt;float ——&gt;double byte ——&gt;short ——&gt;int ——&gt;long ——&gt;float ——&gt;double基本数据类型转字符串：将基本类型的值+“ ”即可String转基本数据类型：通过基本类型的包装类调用parseXX方法即可</code></pre><h2 id="三、运算符"><a href="#三、运算符" class="headerlink" title="三、运算符"></a>三、运算符</h2><h2 id="1-算数运算符"><a href="#1-算数运算符" class="headerlink" title="1.算数运算符"></a>1.算数运算符</h2><pre><code>加 +减 —乘 *除 /取余 %自增 ++自减 --</code></pre><h2 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2.关系运算符"></a>2.关系运算符</h2><pre><code>instanceof：检查是否是类的对象&gt; 大于&lt; 小于= 赋值== 全等于基本数据类型判断值是否相同引用数据类型判断内存地址是否相同&gt;= 大于等于&lt;= 小于等于!= 不等于基本数据类型判断值是否不相同引用数据类型判断内存地址是否不相同</code></pre><h2 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3.逻辑运算符"></a>3.逻辑运算符</h2><pre><code>短路与&amp;&amp;    全真为真，有假为假（第一个为假，后面条件不再判断）短路或||    有真为真，全假为假，（判断第一个条件为真，不再判断结果为真）逻辑与&amp;    全真为真（第一个条件为false，后面的条件任然判断）逻辑或|    有真为真（第一个第二个条件都要判断）^逻辑异或    相同为假，不同为真！非运算    取反</code></pre><h2 id="4-三元运算符"><a href="#4-三元运算符" class="headerlink" title="4.三元运算符"></a>4.三元运算符</h2><pre><code>条件表达式？表达式1:表达式2;    如果条件表达式为true，运算表达式1，如果条件表达式为false，运算表达式2.注意:赋值给变量时,表达式1和表达式2的类型必须相同.</code></pre><h2 id="四、自动拆装箱"><a href="#四、自动拆装箱" class="headerlink" title="四、自动拆装箱"></a>四、自动拆装箱</h2><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><pre><code>装箱:将基本数据类型转换成包装类型的过程拆箱:将包装类型装换成基本数据类型的过程</code></pre><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h2><pre><code>自动装箱都是通过包装类的valueOf()方法来实现,自动拆箱通过包装类对象的xxxValue()来实现.</code></pre><h2 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h2><h3 id="场景一-、将基本数据类型放入集合类"><a href="#场景一-、将基本数据类型放入集合类" class="headerlink" title="场景一 、将基本数据类型放入集合类"></a>场景一 、将基本数据类型放入集合类</h3><pre><code class="java">List&lt;Integer&gt; li = new ArrayList&lt;&gt;;for(int i=1;i&lt;50;i++)&#123;li.add(i);&#125;</code></pre><pre><code class="java">反编译:List&lt;Integer&gt; li = new ArrayList&lt;&gt;;for(int i=1;i&lt;50;i++)&#123;    li.add(Integer.valueOf(i));&#125;</code></pre><h3 id="场景二、包装类和基本类型的大小比较"><a href="#场景二、包装类和基本类型的大小比较" class="headerlink" title="场景二、包装类和基本类型的大小比较"></a>场景二、包装类和基本类型的大小比较</h3><pre><code class="java">Integer a=1;System.out.println(a==1?&quot;等于&quot;:&quot;不等于&quot;);boolean bool=false;System.out.println(bool?&quot;真&quot;:&quot;假&quot;);</code></pre><pre><code class="java">反编译:Integer a=1;System.out.println(a.IntValue==1?&quot;等于&quot;:&quot;不等于&quot;);boolean bool=false;System.out.println(bool.booleanValue?&quot;真&quot;:&quot;假&quot;);</code></pre><p>包装类与基本数据类型进行比较运算,先将包装类拆箱成基本数据类型,然后比较.</p><h3 id="场景三、包装类型的运算"><a href="#场景三、包装类型的运算" class="headerlink" title="场景三、包装类型的运算"></a>场景三、包装类型的运算</h3><p>对Integer对象进行四则运算</p><pre><code class="java">Integer i = 10;Integer j = 20;System.out.println(i+j);</code></pre><pre><code class="java">反编译:    Integer i = Integer.valueOf(10);    Integer j = Integer.valueOf(20);    System.out.println(i.intValue() + j.intValue());</code></pre><p>两个包装类型之间的运算,会被自动拆箱成基本类型.</p><h3 id="场景四、三目运算符的使用"><a href="#场景四、三目运算符的使用" class="headerlink" title="场景四、三目运算符的使用"></a>场景四、三目运算符的使用</h3><pre><code>    boolean flag = true;    Integer i = 0;    int j = 1;    int k = flag ? i : j;        在使用三目运算符时,会发生自动拆箱    1.表达式1和表达式2的值只要有一个时基本数据类型    2.表达式1和表达式2的值类型不一致,会强制拆箱升级成表示范围更大的那个类型</code></pre><pre><code class="java">反编译    boolean flag = true;    Integer i = Integer.valueOf(0);    int j = 1;    int k = flag ? i.intValue() : j;    System.out.println(k);</code></pre><p>如果三目运算符的表达式在自动拆箱的过程中为null.会发生自动拆箱导致的空指针异常.</p><h3 id="场景五、函数参数与返回值"><a href="#场景五、函数参数与返回值" class="headerlink" title="场景五、函数参数与返回值"></a>场景五、函数参数与返回值</h3><pre><code class="java">//自动拆箱public int getNum(Integer num)&#123;return num;&#125;//自动装箱public Integer getNum(int num)&#123;    return num;&#125;</code></pre><h2 id="五、语句的分类"><a href="#五、语句的分类" class="headerlink" title="五、语句的分类"></a>五、语句的分类</h2><p>顺序语句</p><pre><code>代码自上而下执行</code></pre><p>分支语句</p><pre><code>在多个分支选择执行其中一个</code></pre><p>循环语句</p><pre><code>重复执行一段代码</code></pre><h2 id="六、分支语句"><a href="#六、分支语句" class="headerlink" title="六、分支语句"></a>六、分支语句</h2><h3 id="1-if-判断语句"><a href="#1-if-判断语句" class="headerlink" title="1.if 判断语句"></a>1.if 判断语句</h3><pre><code>基础的if结构    语法:        if(条件表达式)&#123;            当条件表达式值为true时,执行此处代码        &#125;        if else结构    语法:        if(条件表达式)&#123;            当条件表达式值为true时,执行此处代码        &#125;else&#123;            当条件表达式值为false时,执行此处代码        &#125;    注意:        1,else可有可无        2,else只能有一个        3,else不能单独存在        else if结构    语法:        if(条件表达式1)&#123;            当条件表达式1为true,执行此处代码        &#125;else if(条件表达式2)&#123;            当条件表达式2为true,执行此处代码        &#125;else if(条件表达式3)&#123;            当条件表达式3为true,执行此处代码        &#125;        ...        else if(条件表达式n)&#123;            当条件表达式n为true,执行此处代码        &#125;else&#123;            当以上条件全为false,执行此处代码        &#125;    注意:        else if可以有多个        当上面的条件,将不会判断下面的条件        总结    if的语法:        if(条件表达式1)&#123;            当条件表达式1为true,执行此处代码        &#125;else if(条件表达式2)&#123;            当条件表达式2为true,执行此处代码        &#125;else if(条件表达式3)&#123;            当条件表达式3为true,执行此处代码        &#125;        ...        else if(条件表达式n)&#123;            当条件表达式n为true,执行此处代码        &#125;else&#123;            当以上条件全为false,执行此处代码        &#125;    注意:        1,else if可以有多个        2,else if可以一个都没有        3,else if不能独立存在        4,else 可有可无,最多只能有一个        5,当多个条件同时满足时,只会执行最上面的那个</code></pre><h3 id="2-switch"><a href="#2-switch" class="headerlink" title="2.switch"></a>2.switch</h3><pre><code>语法:    switch(变量名)&#123;        case 常量1:            当变量值等于常量1时,执行此处代码            int a;        break;        case 常量2:            当变量值等于常量2时,执行此处代码        break;        ...        case 常量n:            当变量值等于常量n时,执行此处代码        break;        default:            当变量值不等于以上常量时,执行的代码        break;    &#125;        常量:代码在编译后无法修改的值或变量称为常量    break:跳出当前代码块,case中可以没有break,但是如果没有会导致贯穿    swicth中case后的常量不能相同    JDK1.5以后switch可以判断字符串内容是否相同    switch只能判断值相等,if可以判断区间,也可以判断值是否相同</code></pre><p>变量的作用域</p><pre><code>概念:变量声明的代码块,为这个变量的作用域(就是这个变量可以使用的范围)</code></pre><h3 id="3-输入：Scanner"><a href="#3-输入：Scanner" class="headerlink" title="3.输入：Scanner"></a>3.输入：Scanner</h3><pre><code>简介:由JDK提供的一个类作用:键盘录入使用:    1,导包        语法:import java.util.Scanner;        书写位置:类上    2,创建Scanner对象        语法:            Scanner 变量名 = new Scanner(System.in);    3,等待用户输入        输入字符串            String 变量名2 = 变量名.next();            变量名2:就是用户输入的内容        输入整数            int 变量名2 = 变量名.nextInt();            变量名2:就是用户输入的内容练习:    键盘录入成绩判断其得分的区间</code></pre><h2 id="七、循环语句"><a href="#七、循环语句" class="headerlink" title="七、循环语句"></a>七、循环语句</h2><h3 id="1-while"><a href="#1-while" class="headerlink" title="1.while"></a>1.while</h3><pre><code>语法：while(条件表达式)&#123;    当条件表达式为true，执行此处代码i    此处代码执行完毕后，判断条件表达式是否为true，为true，执行此处代码    为false，结束循环&#125;</code></pre><h3 id="2-do-while"><a href="#2-do-while" class="headerlink" title="2.do-while"></a>2.do-while</h3><pre><code>语法：do&#123;        先执行此处代码,在判断条件表达式是否为true        如果为true,在此执行此处代码        如果为false结束循环&#125;while(条件表达式);</code></pre><h3 id="3-for"><a href="#3-for" class="headerlink" title="3.for"></a>3.for</h3><pre><code>语法:    for(表达式1;表达式2;表达式3)&#123;        循环体4    &#125;    表达式1:初始化变量    表达式2:循环条件    表达式3:修改变量    循环体4:重复执行的代码执行流程:    1,2,4,3,2,4,3,2,4,3....2    注意:表达式1只执行一次</code></pre><p>名词解释：</p><pre><code>死循环；无法结束的循环循环嵌套：在循环语句中使用循环语句</code></pre><h3 id="4-转义字符"><a href="#4-转义字符" class="headerlink" title="4.转义字符"></a>4.转义字符</h3><pre><code>概念:有特殊含义的字符\t:制表\&quot;:双引号字符\&#39;:单引号字符\n:换行\r\n:标准换行</code></pre><h3 id="5-流程控制语句"><a href="#5-流程控制语句" class="headerlink" title="5.流程控制语句"></a>5.流程控制语句</h3><pre><code>break:跳出当前循环continue:跳过本次循环</code></pre><h2 id="八、方法（函数）"><a href="#八、方法（函数）" class="headerlink" title="八、方法（函数）"></a>八、方法（函数）</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><pre><code>封装一段代码，使其便于使用</code></pre><h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2.优点"></a>2.优点</h3><pre><code>提高代码复用率降低代码耦合度提高代码编写效率方便使用</code></pre><h3 id="3-步骤"><a href="#3-步骤" class="headerlink" title="3.步骤"></a>3.步骤</h3><pre><code>1.定义2.调用</code></pre><h3 id="4-定义"><a href="#4-定义" class="headerlink" title="4.定义"></a>4.定义</h3><pre><code>位置：    类中，方法外        语法:        访问权限修饰符 修饰符 返回值类型 方法名(形参列表)&#123;            方法体        &#125;        注意：        访问权限修饰符:暂时使用public        修饰符:暂时使用static        返回值类型:就是返回值的数据类型.如果没有返回值,返回值类型为void.null表示为空        方法名:自定义,见名知意,小驼峰.一个类中不能出现方法名相同,形参列表也相同的方法        形参列表:可有可无            本质:声明的多个变量,使用逗号隔开        方法体:            return:结束当前方法            return xxx:结束当前方法,并返回xxx.注意此时返回值类型要与xxx的数据类型一致.只能返回一个    </code></pre><h3 id="5-调用"><a href="#5-调用" class="headerlink" title="5.调用"></a>5.调用</h3><pre><code>语法:        1,方法名(实参列表);        2,数据类型 变量名 = 方法名(实参列表);    注意:        1,实参列表要与形参列表一致(长度一致,顺序一致,数据类型一致)        2,调用无返回值的方法只能使用语法1        3,调用有返回值的方法可以选择使用语法1也可以选择使用语法2</code></pre><h3 id="6-多重调用"><a href="#6-多重调用" class="headerlink" title="6.多重调用"></a>6.多重调用</h3><pre><code>方法调用方法A,B,C三个方法    A中调用B,在B中调用C</code></pre><h3 id="7-重载"><a href="#7-重载" class="headerlink" title="7.重载"></a>7.重载</h3><pre><code>要求:    1,同一个类中    2,方法名相同    3,形参列表不同</code></pre><h3 id="8-递归"><a href="#8-递归" class="headerlink" title="8.递归"></a>8.递归</h3><pre><code>方法本身调用本身</code></pre><h2 id="九、数组"><a href="#九、数组" class="headerlink" title="九、数组"></a>九、数组</h2><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1.作用"></a>1.作用</h3><pre><code>存储一组数据类型相同的数据</code></pre><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h3><pre><code>1.长度不可变2.存储的数据类型一致</code></pre><h3 id="3-步骤-1"><a href="#3-步骤-1" class="headerlink" title="3.步骤"></a>3.步骤</h3><pre><code>声明/创建/使用</code></pre><h3 id="4-声明"><a href="#4-声明" class="headerlink" title="4.声明:"></a>4.声明:</h3><pre><code>语法:    数据类型[] 数组名;    数据类型 数组名[];</code></pre><h3 id="5-创建"><a href="#5-创建" class="headerlink" title="5.创建"></a>5.创建</h3><pre><code>静态创建:    语法:        数据类型[] 数组名 = &#123;值1,值2,值3,值4,...值n&#125;;    注意事项:        1,必须在声明时创建        2,其长度就是创建时值的个数动态创建:    语法:        带值            数组名 = new 数据类型[]&#123;值1,值2,值3,...&#125;;            注意:                其长度就是创建时值的个数        不带值            数组名 = new 数据类型[长度];            动态创建与静态创建的区别:    1,静态创建必须在声明时创建,动态创建可以将声明与创建分开,也可以同时进行    2,内存上来说        静态创建的内存在常量区        动态创建的内容在堆内存    3,静态创建是在代码加载时分配的内存空间,动态创建是在代码运行时分配的空间注意:    堆内存中的数据有默认值        基本数据类型默认为0        引用数据类型默认为null</code></pre><h3 id="6-使用"><a href="#6-使用" class="headerlink" title="6.使用"></a>6.使用</h3><pre><code>基本使用    改        修改指定位置的数据            语法:                数组名[下标] = 值;    查        查询数组长度            语法:                数组名.length        查询数组指定位置的数据            语法:                数组名[下标]            注意:                下标要在取值范围内,否则会产生数组下标越界异常扩展    遍历:将数组或集合中的数据逐个取出        方式1:普通for循环        方式2:foreach(只能做遍历)            foreach语法:                for(数据类型 变量名:要遍历的数组或集合)&#123;                                    &#125;                数据类型:遍历出的数据的数据类型                变量名:就是遍历出的数据        注意:foreach(增强for循环)在遍历时的速度是普通for的3倍                复制:    将数组A中的数据,逐个复制到数组中        思路:            1,创建新数组                注意:                    1,新数组长度等于老数组长度                    2,新数组的数据类型与老数组一致            2,遍历老数组                使用普通for循环            3,将老数组的值取出,赋值给新数组对应的位置            扩容:    将数组变大        思路:            1,创建一个新数组                注意:                    1,新数组长度大于老数组长度                    2,新数组的数据类型与老数组一致            2,遍历老数组            3,将老数组的值取出,赋值给新数组对应的位置            4,将新数组赋值给老数组</code></pre><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><pre><code>概念:将数组作为数据存储在数组中步骤:    1,声明    2,创建    3,使用声明    数据类型[][] 数组名;创建    静态创建        注意:声明与创建同时进行        语法:            数据类型[][] 数组名 = &#123;                &#123;值1,值2,值3,...&#125;,                &#123;值4,值5,..&#125;,                &#123;值6,值7,值8,值9,...&#125;,                ...            &#125;;    动态创建        带值            语法:                数组名 = new 数据类型[][]&#123;                    &#123;值1,值2,值3,...&#125;,                    &#123;值4,值5,..&#125;,                    &#123;值6,值7,值8,值9,...&#125;,                    ...                &#125;;        不带值            语法:                数组名 = new 数据类型[x][y];                x:二维数组中可容纳的一维数组的个数,必须在创建时说明                y:一维数组中可容纳的元素的个数,可以不写注意:    二维数组的长度指的是其中存储的一维数组的个数    使用:    改        修改二维数组中指定的一维数组            数组名[下标] = 新数组;            注意:不能使用静态创建        修改二维数组中指定的位置的元素            数组名[x][y] = 新值;            x:元素所在的一维数组在二维数组中的位置            y:元素在一维数组中的位置    查        查询数组长度            数组名.length        查询二维数组中指定位置的一维数组            数组名[下标];        查询二维数组中指定位置的元素            数组名[x][y]            x:元素所在的一维数组在二维数组中的位置            y:元素在一维数组中的位置遍历:    思路:        1,遍历二维数组,获取一维数组        2,遍历一维数组        </code></pre><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><pre><code> 作用:解决实参的长度必须与形参一致的问题 语法:数据类型... 变量名 使用位置:形参末尾使用 注意:一个方法只能使用一个可变参数</code></pre><h1 id="十、面向对象"><a href="#十、面向对象" class="headerlink" title="十、面向对象"></a>十、面向对象</h1><h2 id="1-面向过程"><a href="#1-面向过程" class="headerlink" title="1.面向过程"></a>1.面向过程</h2><blockquote><p>面向过程(Procedure Oriented)是一种以过程为中心的编程思想，是一种自顶而下的编程模式。最典型的面向过程的编程语言就是C语言。</p><p>简单来说，面向过程的开发范式中，程序员需要把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。</p><p>就是说，在进行面向过程编程的时候，不需要考虑那么多，上来先定义一个函数，然后使用各种诸如if-else、for-each等方式进行代码执行。最典型的用法就是实现一个简单的算法，比如实现冒泡排序。</p><p>面向过程进行的软件开发，其代码都是流程化的，很明确的可以看出第一步做什么、第二步做什么。这种方式的代码执行起来效率很高。</p><p>但是，面向过程同时存在着代码重用性低，扩展能力差，后期维护难度比较大等问题。</p></blockquote><h2 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2.面向对象"></a>2.面向对象</h2><blockquote><p>面向对象（Object Oriented）的雏形，最早在出现在1960年的Simula语言中，当时的程序设计领域正面临着一种危机：在软硬件环境逐渐复杂的情况下，软件如何得到良好的维护？</p><p>面向对象程序设计在某种程度上通过强调可重复性解决了这一问题。目前较为流行的面向对象语言主要有Java、C#、C++、Python、Ruby、PHP等。</p><p>简单来说，面向对象的开发范式中，程序员将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。</p><p>就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。比如:想要造一辆车，上来要先把车的各种属性定义出来，然后抽象成一个Car类。</p><p>面向对象的编程方法之所以更加受欢迎，是因为他更加符合人类的思维方式。这种方式编写出来的代码扩展性、可维护性都很高。</p><p>与其实面向对象是一种开发范式，倒不如说面向对象是一种对现实世界的理解和抽象的方法。通过对现实世界的理解和抽象，在运用封装、继承、多态等方法，通过抽象出对象的方式进行软件开发。</p></blockquote><h2 id="3-对象"><a href="#3-对象" class="headerlink" title="3.对象"></a>3.对象</h2><blockquote><p>对象就是类的具体实例<br>概念：万事万物皆对象<br>生活中：客观存在的事物皆为对象<br>代码中：在代码中存在的事物</p></blockquote><h2 id="4-类"><a href="#4-类" class="headerlink" title="4.类"></a>4.类</h2><blockquote><p>概念：多个对象抽象其共同点形成的概念</p><p>代码中：创建对象的模板</p></blockquote><h2 id="5-类和对象的关系"><a href="#5-类和对象的关系" class="headerlink" title="5.类和对象的关系"></a>5.类和对象的关系</h2><blockquote><p>类是抽象的，概念的，代表一类事物</p><p>对象时具体的，实际的，代表一个具体事物</p><p>类是对象的模板，对象是类的一个个体，对应一个实例</p></blockquote><pre><code>生活中:先有对象,后有类代码中:先有类,后有对象    一个类可以有多个对象.多个对象可以属于同一个类</code></pre><h2 id="6-类的定义与组成"><a href="#6-类的定义与组成" class="headerlink" title="6.类的定义与组成"></a>6.类的定义与组成</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1).定义"></a>1).定义</h3><pre><code>语法:    访问权限修饰符 class 类名&#123;        &#125;    访问权限修饰符:        暂时使用public或不写    类名:        1,同一个文件夹下类名不能相同        2,大驼峰</code></pre><h3 id="2-组成"><a href="#2-组成" class="headerlink" title="2).组成"></a>2).组成</h3><pre><code>1.属性（全局变量，成员变量）    作用：描述事物的静态特征    位置：方法外，类内    格式：权限修饰符 数据类型 属性名；    </code></pre><pre><code>方法：    作用：描述事物的行为（静态特征）    位置：类中，方法外    格式：        权限修饰符  返回值类型  方法名（新参列表）&#123;        方法体        &#125;</code></pre><pre><code>构造函数    本质：特殊的方法    作用：创建该类的对象    定义位置：类中。方法外    语法：    访问权限修饰符  构造函数名（形参列表）&#123;            方法体    &#125;      注意：        1.构造函数没有返回值类型        2.构造函数没有返回值        3.构造函数名和类名一致        4.使用new关键字调用        5.如果一个类中有多个构造函数，那么这些构造函数为重载关系        6.一个类一定会有一个构造函数，如果没有定义构造函数，系统将会提供无参构造器        7.构造函数不能形成递归</code></pre><h4 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h4><pre><code>成员变量：    声明在类中，方法外    有默认值，基本数据类型默认为0，引用数据类型默认为null    作用域：当前类中    生命周期：随着对象的创建而创建，随着所属对象的销毁而销毁局部变量：    方法中    没有默认值    作用域:当前代码块中    生命周期:随着方法调用而生成随着方法执行完毕而销毁</code></pre><h2 id="7-对象的创建与使用"><a href="#7-对象的创建与使用" class="headerlink" title="7.对象的创建与使用"></a>7.对象的创建与使用</h2><pre><code>创建    语法：        数据类型 对象名 = new 构造函数（实参列表）；        构造函数：即为该对象所属的类名</code></pre><p>面试题：</p><blockquote><p>Cat cat &#x3D; new Cat();</p><p>1.使用new关键字在堆内存中开辟一片空间</p><p>2.给属性赋初值</p><p>3.执行构造函数中的代码</p><p>4.将堆地址赋值给栈中的引用</p></blockquote><pre><code>使用：    获取属性值：        对象名.属性名    修改属性值        对象名.属性名 = 值；</code></pre><pre><code>调用：    对象名.方法名（实参列表）</code></pre><h2 id="8-this"><a href="#8-this" class="headerlink" title="8.this"></a>8.this</h2><blockquote><p>含义：谁调用this所在的方法this就表示谁</p></blockquote><pre><code>场景一：局部变量与成员变量名称相同时，使用this区分    成员变量(属性)    this.属性名    局部变量    变量名    就近使用原则</code></pre><pre><code>场景二：在本类方法中使用本类的属性或方法，默认用this调用。此时this可以忽略</code></pre><pre><code>场景三：本类构造函数中，调用本类其他构造函数语法:    this(实参列表);注意:    必须在构造函数第一行使用</code></pre><h1 id="十一-三大特征"><a href="#十一-三大特征" class="headerlink" title="十一.三大特征"></a>十一.三大特征</h1><h2 id="1-访问权限修饰符"><a href="#1-访问权限修饰符" class="headerlink" title="1.访问权限修饰符"></a>1.访问权限修饰符</h2><blockquote><p>作用:限制其修饰的内容使用范围</p><p>关键字:</p><p>public    公共的    当前项目可访问</p><p>protected    受保护的   当前包下或继承关系下可用</p><p>默认的   当前包下</p><p>private  私有的     当前类中可用</p></blockquote><h2 id="2-封装"><a href="#2-封装" class="headerlink" title="2.封装"></a>2.封装</h2><p>​<strong>定义</strong>:包装;封装就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，</p><p><strong>优点:</strong></p><pre><code>&gt;1.方便使用&gt;&gt;2.保护内部&gt;&gt;3.降低耦合度&gt;&gt;4.提高复用率</code></pre><p><strong>体现</strong></p><blockquote><p>变量:封装值或内存地址</p><p>方法:封装一段代码</p><p>类:封装多个属性,方法与构造函数</p><p>java中封装无处不在</p></blockquote><p><strong>包:</strong></p><blockquote><p>**本质:**src下的文件夹</p><p>**作用:**对java文件进行分类存储,使其便于寻找</p><p><strong>创建</strong>:  选择src—鼠标右键—new —package—填写包名</p><p><strong>包名:</strong>   规则:全小写</p><p>​潜规则:com.公司名或项目名.分类名</p><p><strong>注意:</strong></p><p>​.下一级文件夹</p><p>关键字:package,说明当前java文件所在的包</p></blockquote><p><strong>导包</strong></p><blockquote><p>作用:在当前java文件中使用其他文件夹下的类,此时需要导包<br>语法:<br>import 包名.类名;</p><p>位置:类上</p><p>关键字:import</p><p>*:所有</p></blockquote><p><strong>步骤</strong></p><blockquote><p>1.属性私有化</p><p>2.提供公共的set方法,用于对属性的判断并赋值</p><p>3.提供一个公共的get方法,用于获取属性值</p></blockquote><h2 id="3-继承"><a href="#3-继承" class="headerlink" title="3.继承"></a>3.继承</h2><p><strong>概念</strong></p><blockquote><p>生活中:晚辈继承长辈遗留下的精神或物质遗产</p><p>代码中:多个类抽取其共同点形成的类,此时该类与这几个类形成继承关系</p></blockquote><p><strong>优点</strong></p><blockquote><p>子类将拥有父类的所有属性和方法,构造函数除外</p><p>提高代码复用率</p></blockquote><p><strong>语法</strong></p><blockquote><p>访问权限修饰符   class  子类名  extends 父类名{</p><p>​属性</p><p>​方法</p><p>​构造函数</p><p>}</p><p>注意:</p><pre><code>1.一个父类可以有多个子类2.一个子类只能有一个父类,单继承3.子类构造函数中默认调用父类无参构造函数4.子类构造函数中必须调用父类的构造函数,默认先调用父类的构造函数5.Object是所有类的父类,如果一个没有明确的父类,默认继承Object6.开闭原则:对修改关闭对扩展打开</code></pre></blockquote><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a><strong>重写</strong></h4><blockquote><p>在继承关系中,子类中的方法与父类的方法,方法名相同,形参列表相同.</p><p>子类的方法访问权限修饰符不能小于父类的子类</p><p>该方法返回值类型与父类一致.</p></blockquote><h4 id="super"><a href="#super" class="headerlink" title="super"></a><strong>super</strong></h4><p>​含义:</p><pre><code>谁调用super所在的方法,super就表示谁的父类对象代表父类的引用，用于访问父类的属性，方法，构造器注意:    1.访问父类的属性,但不能访问父类的private属性,super.属性名,在子类方法中访问    2.访问父类的方法,但不能访问父类的private方法,super.方法名(参数列表),在子类方法中访问    3.访问父类的构造器,super(参数列表)只能放在子类构造器的第一句</code></pre><p><strong>使用场景:</strong></p><blockquote><p><strong>场景1</strong>:当子类重写了父类的方法后,在子类中使用super区分,在子类重写的方法还是父类的方法</p><p>​super.方法名(实参列表)     ——-父类提供</p><p>​方法名(实参列表) ——–子类重写的方法</p></blockquote><blockquote><p><strong>场景2</strong>:当子类属性名与父类属性名重名时,使用super区分</p><p>​super.属性名      父类属性</p><p>​属性名               子类属性</p></blockquote><blockquote><p>**场景3:**调用构造函数</p><p>​super(实参列表);—–只能在子类构造器第一行调用</p></blockquote><p><strong>细节:</strong></p><blockquote><ol><li><p>调用父类构造器的好处，（分工明确，父类属性由父类初始化，子类属性由子类初始化）</p></li><li><p>当子类中又有和 父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super，如果没有重名，使用super，this，直接访问效果一样</p></li></ol><p> super.方法名：直接查找父类，跳过本类查找</p><ol start="3"><li>super的访问不限于直接父类，如果爷爷类和本类中有同名成员，也可以使用super去访问爷爷类的成员，如果多个基类中有同名的成员，使用super遵循就近原则，也需要遵守权限规则。</li></ol></blockquote><p><strong>this与super</strong></p><blockquote><p>this:调用该方法的对象</p><p>super:调用该方法的父类对象</p></blockquote><h2 id="4-多态"><a href="#4-多态" class="headerlink" title="4.多态"></a>4.多态</h2><p><strong>概念:</strong>  </p><blockquote><p>一个事物的多种形态(方法或对象具有多种形态，多态建立在封装和继承的基础之上)</p></blockquote><h4 id="对象的多态"><a href="#对象的多态" class="headerlink" title="对象的多态"></a><strong>对象的多态</strong></h4><blockquote><p>子类对象转换为父类对象</p><p>​自动转换</p><p>​语法:               父类名    对象名  &#x3D;  子类对象;</p><p>父类对象转换为子类对象</p><p>​强制转换</p><p>​语法:         子类名    对象名   &#x3D;   (子类名)父类对象;</p><p>​注意:有风险</p></blockquote><h4 id="方法的多态"><a href="#方法的多态" class="headerlink" title="方法的多态:"></a><strong>方法的多态:</strong></h4><blockquote><p>重载:在同一个类中,方法名相同,形参列表不同</p><p>重写:在继承关系中,子类方法与父类方法,方法名相同,形参列表相同,返回值类型相同,访问权限修饰符不能减小</p><p>注意:当子类对象转换为父类对象后,调查重写的方法,依据执行的是子类重写后的方法.</p></blockquote><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><strong>instanceof</strong></h4><blockquote><p>作用:判断该对象是否属于该类</p><p>注意:判断的对象与类之间要存在关系</p><p>语法:</p><p>​boolean   变量名  &#x3D;  对象名  instanceof   类名;</p><p>如果为true,表示该对象属于该类</p><p>如果为false,表示该对象不属于该类</p></blockquote><h1 id="十二-、三大修饰符"><a href="#十二-、三大修饰符" class="headerlink" title="十二 、三大修饰符"></a>十二 、三大修饰符</h1><h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><blockquote><p>含义:抽象的,不可描述的</p><p>可以修饰类和方法</p><h4 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类:"></a><strong>修饰类:</strong></h4><pre><code>特点:不能直接创建对象语法:    访问权限修饰符  abstract class 类名&#123;        属性        方法        构造函数    &#125;名称:抽象类注意:    1.抽象类中不一定有抽象方法    2.子类继承抽象类,要么重写父类所有抽象方法,要么自己也是抽象类    3.抽象类不能被实例化    4.一旦包含抽象方法,则这个类必须声明为抽象类    5.抽象类可以有任意成员,如非抽象方法,构造器,静态属性</code></pre><h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><pre><code>特点:没有方法体语法:    访问权限修饰符  abstract 返回值类型 方法名(形参列表);    注意:    1.有抽象方法的类一定是抽象类    2.抽象类中可以有多个抽象方法    3.抽象方法不能有主体,即不能实现    4.抽象方法不能使用private，final，static来修饰，因为这些关键字都是和重写相违背的，final是不能继承的，static关键字和方法重写无关，private不能重写</code></pre></blockquote><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><blockquote><p>含义:最终的,不可修改的</p><p>可以修饰:变量,方法,类</p><h4 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a><strong>修饰变量</strong></h4><pre><code>修饰局部变量    语法:        final 数据类型 变量名 = 值;    注意:只能赋值一次     final修饰的变量就是常量修饰成员变量        语法:            访问权限修饰符 final 数据类型 属性名 = 值;        注意:            1.final 修饰的属性必须是声明赋值时            2.final 修饰的属性值不能被修改</code></pre><h4 id="修饰方法-1"><a href="#修饰方法-1" class="headerlink" title="修饰方法"></a>修饰方法</h4><pre><code>作用:不能被重写语法:    访问修饰符 final 返回值类型 方法名(形参列表)&#123;        方法体    &#125;</code></pre><h4 id="修饰类-1"><a href="#修饰类-1" class="headerlink" title="修饰类"></a>修饰类</h4><pre><code>作用:不能被继承,这种类被称为最终类语法:     访问权限修饰符 final class 类名&#123;    &#125;</code></pre><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h4><pre><code>1.不希望类被继承时,使用final修饰2.不希望父类的某个方法被子类覆盖/重写时可以使用final关键字3.当不希望类的某个属性的值被修改,就可以使用final修饰4.当不希望某个局部变量被修改,可以使用final修饰</code></pre><h4 id="细节"><a href="#细节" class="headerlink" title="细节:"></a>细节:</h4><pre><code>1.final修饰的属性在定义时,必须赋初值,并且以后不能改变2.如果final修饰的属性是静态的,则初始化的位置只能是:在定义时,在静态代码块,不能在构造器中赋值3.final类不能继承,但可以实例化4.如果类不是final类,但是含有fianal方法,则该方法不能被重写,但可以被继承5.一般来说,一个类已经是final类了.则没必要讲方法修饰成final方法6.final不能修饰构造方法7.final 往往与static搭配使用,效率更高,底层编译做了优化处理,静态属性增加final后,调用静态属性,静态方法不再被调用.8.包装类,String也是final类</code></pre></blockquote><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><blockquote><p>含义:静态的,公共的</p><p>可以修饰:属性,方法,代码块,内部类</p><h4 id="修饰属性"><a href="#修饰属性" class="headerlink" title="修饰属性"></a>修饰属性</h4><pre><code>特点:该属性属于该类的所有对象,该类的一个对象对其进行修改,该类的所有对象的属性都会被修改可以使用类名直接调用.语法:    访问权限修饰符  static 数据类型 属性名;</code></pre><h4 id="修饰方法-2"><a href="#修饰方法-2" class="headerlink" title="修饰方法"></a>修饰方法</h4><pre><code>特点:可以使用类名直接调用,也可以使用对象名调用语法:    访问权限修饰符  static 返回值类型 方法名(形参列表)&#123;        方法体    &#125;注意:    1.不能使用this或super关键字    2.不能直接使用本类中其他非静态属性或非静态方法    3.可以直接使用本类的静态属性或静态方法    4.非静态方法中可以直接使用静态属性或静态方法    </code></pre><h4 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h4><pre><code>特点:在类加载时被执行    注意:一个类在程序运行时,只会被加载一次语法:    static&#123;        代码块    &#125;注意:    1.静态代码快中可以使用静态属性与静态方法,不能直接使用非静态属性和非静态方法    2.静态代码快与静态属性,谁在前,谁先执行,为了可以再静态代码快中使用静态属性,必须将静态属性声明在静态代码块之前        类加载时机:该类第一次被执行使用时        1.第一次创建该类对象时        2.第一次使用该类调用属性时        3.第一次使用该类调用方法时        4.第一次使用反射机制加载该类时</code></pre><h4 id="继承关系中的执行流程"><a href="#继承关系中的执行流程" class="headerlink" title="继承关系中的执行流程"></a>继承关系中的执行流程</h4><pre><code>- 父类的静态代码块和静态属性- 子类的静态代码快和静态属性- 父类的普通代码块和普通属性初始化- 父类的构造方法- 子类的普通代码块和普通属性初始化- 子类的构造方法</code></pre><h4 id="创建对象时-在一个类调用的顺序是"><a href="#创建对象时-在一个类调用的顺序是" class="headerlink" title="创建对象时,在一个类调用的顺序是:"></a>创建对象时,在一个类调用的顺序是:</h4><pre><code>1）调用静态代码块和静态属性初始化（静态代码块和静态属性初始化的调用优先级一样，如果有多个静态代码块和多个静态变量初始化，则按照他们的顺序调用）2）调用普通代码块和普通属性的初始化（普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）3）调用构造方法</code></pre></blockquote><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><blockquote><p>语法:</p><pre><code>&#123;方法体&#125;</code></pre><p>作用:封装一段代码</p><p>使用位置:</p><pre><code>类中方法外.每次创建该类对象时被调用    注意:在构造函数之前执行    普通属性与代码块按顺序执行</code></pre></blockquote><h1 id="十三-接口"><a href="#十三-接口" class="headerlink" title="十三.接口"></a>十三.接口</h1><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体的情况把这些方法写出来</p><h2 id="含义"><a href="#含义" class="headerlink" title="含义:"></a>含义:</h2><pre><code>宏观:规则微观:功能</code></pre><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h2><blockquote><pre><code>1.定义2.使用</code></pre></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><pre><code>语法:    访问权限修饰符  interface 接口名&#123;        方法体;    &#125;组成:公共静态常量公共静态方法公共抽象方法default修饰的普通方法注意:公共静态方法和常量默认有public static final公共抽象方法包含:public abstract</code></pre></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><pre><code>1.接口使用接口通过多继承实现接口使用接口语法:    public interface 子接口名 extends  父接口名1,父接口名2....&#123;            &#125;注意:不能继承父接口的静态方法,其他的均可继承    2.类使用接口多实现:一个类可以实现多个接口语法:访问权限修饰符 class 子类名 extends 父类名 implements 父接口名1,父接口名2...&#123;&#125;注意:1.一个类可以实现多个接口2.子类要么重写所有接口提供的抽象方法,要么子类也是抽象类3.子类对象可以转换为多个实现的接口对象4.一个接口可以被多个类实现,所以多个类的对象可以转换为同一个接口的对象</code></pre></blockquote><h2 id="接口的特殊使用"><a href="#接口的特殊使用" class="headerlink" title="接口的特殊使用"></a>接口的特殊使用</h2><blockquote><p><strong>常量接口</strong></p><pre><code>概念:只有常量的接口public interface 接口名&#123;    数据类型 常量名1 = 值;    数据类型 常量名2 = 值;    数据类型 常量名3 = 值;&#125;</code></pre><p><strong>接口回调</strong></p><pre><code>概念:接口对象回来调用接口方法实例:点击按钮按钮类点击事件接口环境类    创建点击事件接口对象    创建按钮对象,传入接口对象    按钮对象,点击方法</code></pre></blockquote><h2 id="细节-1"><a href="#细节-1" class="headerlink" title="细节:"></a>细节:</h2><blockquote><pre><code>1.接口使用implements实现2.接口不能继承其他类,但可以继承其他接口(多继承)3.接口不能实例化4.接口的所有方法是public方法,接口中的抽象方法可以不用abstract修饰5.一个普通类实现接口,必须将该接口的方法都实现,或将自己定义为抽象类6.一个类可以同时实现多个接口7.接口中的属性,只能是final的,而且是public static final修饰符8.接口中属性的访问形式:接口名.属性名9接口的修饰符只能是public和默认的</code></pre></blockquote><h2 id="接口的多态"><a href="#接口的多态" class="headerlink" title="接口的多态"></a>接口的多态</h2><blockquote><p>接口存在多态传递,如果接口1继承了接口2,为类1实现了接口1,就相当于类1实现了接口2</p></blockquote><h1 id="十四-内部类"><a href="#十四-内部类" class="headerlink" title="十四.内部类"></a>十四.内部类</h1><p>作用:补全外部类功能</p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><blockquote><p>在类中定义的类称为内部类</p><pre><code>public class A&#123;    public class B&#123;    &#125;&#125;A为外部类B为内部类</code></pre></blockquote><h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h3><blockquote><pre><code>1.成员内部类    位置:类中.方法外    未使用static修饰2.静态内部类    定义位置:类中.方法外    使用static修饰3.局部内部类    定义位置:类中,方法中4.匿名内部类    定义位置:定义在外部类的成员位置上,或实参中</code></pre></blockquote><h3 id="3-成员内部类"><a href="#3-成员内部类" class="headerlink" title="3.成员内部类"></a>3.成员内部类</h3><blockquote><pre><code>可以加访问任何的访问权限修饰符,因为他也是成员成员内部类内部可定义:除去静态成员以外的成员都可以定义创建对象:情况1:在所在的外部类中创建该内部类对象    内部类类名 对象名 = new 内部类类名(实参列表);    注意:只是省略this关键字,所以这种创建方式不能再静态方法中使用.情况2:在其他类中创建该内部类对象    外部类类名.内部类类名 对象名 = 外部类对象.new 内部类名(实参列表);</code></pre></blockquote><h3 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4.静态内部类"></a>4.静态内部类</h3><blockquote><pre><code>使用static修饰静态内部类所有的成员都可以定义创建对象:外部类类名.内部类类名 对象名 = new 外部类类名.内部类类名(实参列表);</code></pre></blockquote><h3 id="5-局部内部类"><a href="#5-局部内部类" class="headerlink" title="5.局部内部类"></a>5.局部内部类</h3><blockquote><pre><code>注意:此时不能使用访问权限修饰符只能在当前方法中使用可以定义什么:除去静态成员,其他成员都可以创建对象:内部类类名 对象名 = new 内部类类名(实参列表);</code></pre></blockquote><h3 id="6-匿名内部类"><a href="#6-匿名内部类" class="headerlink" title="6.匿名内部类"></a>6.匿名内部类</h3><blockquote><pre><code>概念:没有类名的内部类称为匿名内部类定义位置:定义在外部类的成员位置上,或实参中语法:new 父类名或父接口名()&#123;    属性    方法&#125;;注意:1.一个类只能创建一个对象时,可以使用匿名内部类2.不能定义静态成员与抽象方法,没有构造函数优点:1.编写方便缺点:2.代码混乱,降低代码可读性</code></pre><p>细节:</p><pre><code>1.可以直接访问外部类的所有成员,包含私有2.不能添加访问修饰符,他是一个局部变量3.作用域:定义他的方法或代码快4.如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类成员，则可以使用（外部类.this.成员）</code></pre></blockquote><h1 id="十五-包装类"><a href="#十五-包装类" class="headerlink" title="十五.包装类"></a>十五.包装类</h1><p>八个基本数据类型所对应的引用数据类型</p><p>包装类:</p><pre><code>byte ----Byteshort----Shortint------Integerlong-----Longfloat----Floatdouble---Doubleboolean--Booleabchar-----Character</code></pre><p>提供的方法</p><pre><code>parsexxx();将相应的包装类转换成基本数据类型</code></pre><p>整数缓冲区</p><pre><code>-128~127原因:    因为系统中已经创建了-128~127之间有数的对象,在使用自动装箱时,如果值是在该范围内,直接使用已经创建好的对象,如果超过这个返回需要重新创建对象</code></pre><h1 id="十六-System"><a href="#十六-System" class="headerlink" title="十六.System"></a>十六.System</h1><p>由JDK提供的类</p><p>提供属性或方法</p><pre><code>static native void arraycopy(Object src,int  srcPos,                          Object dest, int destPos,                          int length)作用:将原数组中的一段数据复制到新数组    1参:原数组    2参:复制开始的位置    3参:新数组 4参:新数组开始的位置 5参:复制的长度 static native long currentTimeMillis()作用:获取当前时间与1970年1月1日00:00:00:000的时间差(格林威治时间)static void exit(int status)作用:结束当前程序    1参:终止状态码        0:正常退出        1:异常退出static void gc()作用:手动调用垃圾回收机制</code></pre><h1 id="十七-Object"><a href="#十七-Object" class="headerlink" title="十七.Object"></a>十七.Object</h1><p>概念：所有类的父类</p><p>意味：</p><pre><code>该类提供的属性与方法是所有类的对象都可以使用</code></pre><p>提供的方法</p><h2 id="1-equals"><a href="#1-equals" class="headerlink" title="1.equals"></a>1.equals</h2><pre><code>public boolean equals(Object obj)    作用:判断调用该方法的对象与传入的对象的内存地址是否相同    如果子类重写该方法,使用子类对象调用该方法执行的是重写的代码    如果要比较子类的对象属性值是否相同,要重写equals方法重写步骤:    1.判断内存地址是否相同    2.判断传入的对象是否属于该类对象    3.将传入的对象转换为该类对象(父类转子类对象)    4.使用调用该方法的对象的属性与传入的对象属性一一比较</code></pre><h2 id="2-toString"><a href="#2-toString" class="headerlink" title="2.toString"></a>2.toString</h2><pre><code>public String toString()作用:获取对象的包名.类拼接@字符串,再拼接对象的内存地址的16进制注意:    1.Object提供的toString方法返回的是对象的包名.类@对象内存地址的16进制,可以理解为是对象的信息,但是我们在观察对象时,想看到的是对象的属性值,所以我们可以在子类中重写toString方法,重写后对象在调用toString方法,执行的是重写后的toString方法.    2.重写toString方法,打印对象或拼接对象时,都会自动调用该对象的toString方法    3.直接输出一个对象时,toString方法会被默认调用</code></pre><h2 id="3-hashCode"><a href="#3-hashCode" class="headerlink" title="3.hashCode"></a>3.hashCode</h2><pre><code>作用:获取对象的哈希码值,近似可以理解为对象的内存地址注意:1.提高具有哈希结构的容器的效率2.两个引用,如果指定的是同一个对象,则哈希值肯定是一样的3.两个引用,如果指向的是不同的对象,则哈希值是不一样的4.哈希值主要根据地址号来的,不能完全等价于地址</code></pre><h2 id="4-finalize"><a href="#4-finalize" class="headerlink" title="4.finalize"></a>4.finalize</h2><pre><code>作用:系统回收该对象的内存时,才会被调用注意:    1.当对象被回收时,系统自动调用该对象的finalize方法,子类可以重写该方法做一些释放资源的操作    2.当某个对象没有任何引用时,则jvm就认为这个对象是一个垃圾对象,就会使用垃圾回收机制来销毁对象,在销毁前,就先调用finalize    3.垃圾回收机制的调用,是由系统来决定的,也可以通过System.gc主动触发垃圾回收机制</code></pre><h2 id="5-Math"><a href="#5-Math" class="headerlink" title="5.Math"></a>5.Math</h2><p>作用:数学运算与随机数</p><p>提供的方法</p><pre><code>static double random();    作用:随机获取0-1之间的数    使用:要想获得特定区间的随机数,random*区间最大值+1;</code></pre><pre><code>static int abs(int a);    作用:获取其指定数据的绝对值</code></pre><pre><code>static double floor(double a);    作用:向下取整</code></pre><pre><code>static double ceil(double a);    作用:向上取整</code></pre><pre><code>static int max(int a , int b)    作用:获取两数之间的最大值</code></pre><pre><code>static int min(int a , int b);    作用:获取两束之间的最小值</code></pre><pre><code>static double pow(double a,double b)    作用:计算a的b次幂</code></pre><h2 id="6-字符串"><a href="#6-字符串" class="headerlink" title="6.字符串"></a>6.字符串</h2><h3 id="6-1String"><a href="#6-1String" class="headerlink" title="6.1String"></a>6.1String</h3><blockquote><p><strong>细节:</strong></p><pre><code>1.String用于保存字符串,也是一组字符序列2.字符串常量对象是用双引号括起来的字符序列3.字符串的字符使用Unicode字符编码,一个字符占两个字节4.String 实现了很多构造器,构造器重载5.String是fianl类不能被继承6.Stirng保存字符串时保存在private final char value[];7.value是final类型,赋值后不能修改(地址不能修改,值可以修改),一个字符串对象一旦分配,其内容是不可变的,指向改变8.String 这个类实现了Serializable,说明String可以串行化,可以网络传播9.String这个类实现了Comparable,说明String对象可以比较</code></pre><p><strong>创建方式:</strong></p><pre><code>1.直接赋值    String s = &quot;hhhh&quot;;先从常量池查看是否有&quot;hhhhhh&quot;数据空间,如果有,直接指向:如果没有,则重新创建,然后指向,s最终指向的是常量池的地址空间2.调用构造器    String s = new String(&quot;xxxx&quot;);    先从堆中创建空间,里面维护了value属性,指向常量池的&quot;xxxx&quot;的空间,如果常量池没有&quot;xxxx&quot;重新创建,如果有,直接通过value指向,最终指向的是堆中的空间</code></pre><p><strong>常见方法:</strong></p><pre><code class="java">public String replace(String old,String newStr)    作用:替换    1参:要被替换的字符串    2参:替换后的字符串</code></pre><pre><code class="java">public int length()    作用:获取字符串长度</code></pre><pre><code class="java">char charAt(int index)    作用:获取字符串中指定位置的字符</code></pre><pre><code class="java">public char[] toCharArray()    作用:将字符串转换为字符数组</code></pre><pre><code class="java">public boolean equals(Object anObject)    作用:比较字符串内容是否相同</code></pre><pre><code class="java">public boolean equalsIgnoreCase(String anotherString)    作用:忽略大小写比较字符串内容是否相同</code></pre><pre><code class="java">public String trim()    作用:忽略前后空白</code></pre><pre><code class="java">boolean endsWith(String suffix)    作用:判断字符串是否以指定的字符串结束</code></pre><pre><code class="java">boolean startsWith(String prefix)    作用:判断字符串以什么开始</code></pre><pre><code class="java">public String toUpperCase()    作用:将字符串中的小写字母转换为大写字母</code></pre><pre><code class="java">public String toLowerCase()    作用:将字符串中的大写字母转换为小写字母</code></pre><pre><code class="java">boolean contains(String s)    作用:判断s是否在调用该方法的字符串中存在</code></pre><pre><code class="java">public int lastIndexOf(String str)    作用:获取指定的子字符串在字符串中最后一次出现的位置</code></pre><pre><code class="java">public int indexOf(String str)    作用:获取指定的子字符串在字符串中第一次出现的位置</code></pre><pre><code class="java">public String substring(int beginIndex)    作用:截取指定位置的字符串,从开始位置到字符串末尾    beginIndex:开始位置</code></pre><pre><code class="java">public String substring(int beginIndex , int endIndex)    作用:截取指定位置的字符串    1参:开始位置    2参:结束位置</code></pre><pre><code class="java">public String[] split(String regex)    作用:切割    1参:按什么字符串切割</code></pre><p>构造函数</p><pre><code class="java">public String(char value[])    将传入的字符数组转换为字符串public String(char value[],int offset,int count)    在char数组中,从offset开始截取count位字符</code></pre></blockquote><h3 id="6-2StringBuffer和StringBuilder"><a href="#6-2StringBuffer和StringBuilder" class="headerlink" title="6.2StringBuffer和StringBuilder"></a>6.2StringBuffer和StringBuilder</h3><p><strong>长度可变</strong></p><h4 id="1-StringBuffer"><a href="#1-StringBuffer" class="headerlink" title="1.StringBuffer"></a>1.StringBuffer</h4><p>​特点:jdk1.0出现,线程安全的,效率低</p><pre><code>StringBuffer是一个容器    1.StringBuffer的直接父类是AbstractStringBuilder    2.StringBuffer实现了Serializable,即StringBuffer的对象可以串行化    3.在父类中有一个属性char[] value,不是final    4.该value数组中存放字符串内容,引出存放在堆中的StringBuffer是一个public final class,所以StringBuffer不能被继承    5.因为StringBuffer字符内容是存在char[]value,所以增加和删除不用每次都更换地址,即每次都创建新的对象,故效率高于String</code></pre><h4 id="2-StringBuilder"><a href="#2-StringBuilder" class="headerlink" title="2.StringBuilder"></a>2.StringBuilder</h4><p>特性:JDK1.5出现,线程不安全,效率高</p><pre><code>1.一个可变字符序列,此类提供了一个与StringBuffer兼容的API,但不保证同步(StringBuilder不是线程安全的),该类被设计用做StringBuffer的一个简易替换,用在字符串缓存区被单个线程使用的时候,如果可能,简易有先采用StringBuilder,在大多数实现中,他比StringBuffer要快2.在StringBuilder上主要操作的是append和insert方法,可重载这些方法,以便于接受任意类型的数据3.单线程的情况下使用StringBuilder</code></pre><h4 id="3-提供的方法"><a href="#3-提供的方法" class="headerlink" title="3.提供的方法"></a>3.提供的方法</h4><pre><code>1.StringBuilder append(Object obj)    作用:给字符串尾部拼接字符串2.StringBuilder insert(int offset , String str)    作用:插入    1参:插入开始的位置    2参.插入的数据3.StringBuilder delete(int start,int end)    作用:删除指定区间的数据    1参:开始位置,包含    2餐:结束位置,不包含4.StringBuilder deleteCharAt(int index)    作用:删除指定位置的字符    1参:指定位置5.StringBuilder replace(int start ,int end,String str)    作用:替换    1.参:要替换的数据的开始位置,包含    2.参:要替换的数据的结束位置,不包含    3.替换后的字符串6.toString()    作用:将可变字符转换为不可变字符    StringBuffer str = new StringBuffer();    String s = str.toString();        不可变字符转可变字符    String str = &quot;hello&quot;;    StringBuffer s = new StringBuffer(str);</code></pre><h1 id="十八-BigDecimal和BigInteger"><a href="#十八-BigDecimal和BigInteger" class="headerlink" title="十八.BigDecimal和BigInteger"></a>十八.BigDecimal和BigInteger</h1><h2 id="1-BigDeciamal"><a href="#1-BigDeciamal" class="headerlink" title="1.BigDeciamal"></a>1.BigDeciamal</h2><p>适合保存精度更高的浮点型</p><p>构造函数</p><pre><code>BigDeciaml(Object obj);</code></pre><p>提供方法</p><pre><code>BigDecimal subtract(BigDecimal subtrahend)    作用:减法,使用调用该方法的对象的值减去传入的对象的值,返回计算结果BigDecimal add(BigDecimal augend)    作用:加法BigDeciamal multiply(BigDecimal multiplicand)    作用:乘法BigDeciaml divide(BigDecimal divisor)    作用:除法xxx xxxValue();    作用:获取BigDeciaml的值</code></pre><h2 id="2-BigInterger"><a href="#2-BigInterger" class="headerlink" title="2.BigInterger"></a>2.BigInterger</h2><p>BigInteger适合保存比较大的整型</p><p>方法同上</p><h1 id="十九-时间相关类"><a href="#十九-时间相关类" class="headerlink" title="十九.时间相关类"></a>十九.时间相关类</h1><h2 id="1-Date"><a href="#1-Date" class="headerlink" title="1.Date"></a>1.Date</h2><p>概念:日期</p><p>创建</p><pre><code class="java">//public Date();获取当前系统时间//public Date(long date);//获取距离1970年1月1日00.00.00的时间,单位毫秒        Date date = new Date();        System.out.println(date);        Date date1 = new Date(1000);        System.out.println(date1);</code></pre><pre><code class="java">new Date()默认输出的格式为国外就需要格式转换,通过创建SimpleDateFormat对象可以指定格式: yyyy年MM月dd日  hh:mm:ss EE代表星期中的天数SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy年MM月dd日 hh:mm:ss E&quot;);</code></pre><p>​format:将时间对象转换为指定格式的字符串<br>​parse:将指定格式的字符串转换为时间</p><p>before,after</p><h2 id="2-Calendar"><a href="#2-Calendar" class="headerlink" title="2.Calendar"></a>2.Calendar</h2><p>概念:日历</p><p>创建</p><pre><code>static Calender getInstance()</code></pre><p>方法</p><pre><code>getSystem.out.println(&quot;年&quot;+instance.get(Calendar.YEAR));System.out.println(&quot;月&quot;+(instance.get(Calendar.MONTH)+1));//Calender&#39;是按照0开始编号System.out.println(&quot;日&quot;+instance.get(Calendar.DAY_OF_MONTH));System.out.println(&quot;小时&quot;+instance.get(Calendar.HOUR));System.out.println(&quot;分钟&quot;+instance.get(Calendar.MINUTE));System.out.println(&quot;秒&quot;+instance.get(Calendar.SECOND));setaddgetTime</code></pre><h2 id="3-第三代时间"><a href="#3-第三代时间" class="headerlink" title="3.第三代时间"></a>3.第三代时间</h2><p>在JDK8中加入了LocalDate(日期)，LocalTime(时间)，LocalDateTime（日期时间）</p><ul><li><p>LocalDate只包含日期，可以获取日期字段</p></li><li><p>LocalTime只包含时间，可以获取时间字段</p></li><li><p>LocalDateTime包含日期+时间，可以获取日期和时间字段</p></li></ul><pre><code class="java"> //使用now返回表示当前时间的对象    LocalDateTime now = LocalDateTime.now();    System.out.println(now);    System.out.println(&quot;年:&quot;+now.getYear());    System.out.println(&quot;月:&quot;+now.getMonth());    System.out.println(&quot;月:&quot;+now.getMonthValue());    System.out.println(&quot;日:&quot;+now.getDayOfMonth());    System.out.println(&quot;时:&quot;+now.getHour());    System.out.println(&quot;分:&quot;+now.getMinute());    System.out.println(&quot;秒:&quot;+now.getSecond());  //可以获取年月日    LocalDate now1 = LocalDate.now();    System.out.println(now1.getYear());    //可以获取时分秒    LocalTime now2 = LocalTime.now();</code></pre><pre><code class="java"> //使用DateTimeFormatter  格式日期类LocalDateTime now3 = LocalDateTime.now();DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy年MM月dd日  HH时mm分ss秒&quot;);String str=dateTimeFormatter.format(now3);System.out.println(str);</code></pre><h1 id="二十-泛型"><a href="#二十-泛型" class="headerlink" title="二十.泛型"></a>二十.泛型</h1><p>作用:将数据类型作为参数传递</p><p>语法</p><pre><code>定义:    &lt;泛型1,泛型2...&gt;    情况1:在方法上        访问权限修饰符 修饰符 &lt;泛型1,泛型2...&gt; 返回值类型 方法名(形参列表)&#123;                &#125;    情况2:在类上定义        访问权限修饰符 class 类名&lt;泛型1,泛型2...&gt;&#123;&#125;  使用:     泛型名         情况1:在方法中使用             在方法中任意使用数据类型的地方都可以使用该泛型作为数据类型         情况2:在类中使用            在类中任意使用数据类型的地方都可以使用该泛型作为数据类型</code></pre><p>注意:<strong>泛型中只能使用引用数据类型</strong></p><h1 id="二十一-集合"><a href="#二十一-集合" class="headerlink" title="二十一.集合"></a>二十一.集合</h1><h3 id="1-作用-2"><a href="#1-作用-2" class="headerlink" title="1.作用"></a>1.作用</h3><blockquote><p>动态的存储一组数据类型相同的数据</p></blockquote><h3 id="2-特点-1"><a href="#2-特点-1" class="headerlink" title="2.特点"></a>2.特点</h3><blockquote><p>长度可变</p></blockquote><h3 id="3-名称"><a href="#3-名称" class="headerlink" title="3.名称"></a>3.名称</h3><blockquote><p>长度:集合中存在的元素个数</p><p>下标:元素在集合中的位置</p><p>元素:集合中存储的数据</p></blockquote><h3 id="4-体系结构"><a href="#4-体系结构" class="headerlink" title="4.体系结构"></a>4.体系结构</h3><blockquote><h2 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1.Collection"></a>1.Collection</h2><p>分类:List,Set</p><pre><code>List特点:有序(存入和取出顺序一致),由下标,可以重复子类:    ArrayList:        特点:JDK1.2出现,线程不安全的        数据结构:数组        特点:查询效率高,增删效率低    LinkedList      特点:查询效率低,增删效率高      数据结构:链表   Vector:      特点:JDK1.0出现,线程安全      数据结构:数组      Set特点:无序,无下标,元素不允许重复子类:    HashSet        底层:HashMap        数据结构:            JDK1.8以前数组+链表            JDK1.8之后数组+链表+红黑树    TreeSet      数据结构:红黑树      注意:指定比较规则  LinkedHashSet      特点:有序      数据结构:数组+双向链表</code></pre></blockquote><h2 id="Collection提供的方法"><a href="#Collection提供的方法" class="headerlink" title="Collection提供的方法"></a>Collection提供的方法</h2><blockquote><pre><code>增:boolean add(E e)    作用:一次添加一个数据    参数:要添加的数据    返回值:是否添加成功boolean addAll(Collection&lt;? extends E&gt; c);作用:一次添加一组数据参数:要添加的数据集合返回值:    是否添加成功,哪怕只添加一个也算成功,全部失败才是失败删:boolean remove(Object o)    作用:一次删除一个数据    参数:要删除的数据    返回值:是否删除成功    注意:如果集合中有多个要删除的数据,智能删除第一个boolean removeAll(Collection&lt;?&gt; c)作用:一次删除一组数据参数:要删除的数据集合返回值:是否删除成功注意:如果原集合中多次出现删除集合中的数据,那么元集合中的该数据会全部被删除void clear()作用:清空集合中的数据查:int size()    作用:查询集合长度boolean contains(Object o);作用:判断集合中是否包含指定元素boolean containsAll(Collection&lt;?&gt; C)作用:判断集合中是否全部包含指定的集合中的元素注意:判断的是是否全部包含boolean isEmpty();作用:判断集合是否为空集合注意:空集合表示集合中没有元素,而不是集合为nullIterator&lt;E&gt; Iterator()作用:获取当前集合的迭代器迭代器方法:    boolean hasNext();判断下一个是否有值    E next(); 移动游标,并返回指向的数据</code></pre><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><pre><code>遍历:迭代器foreach</code></pre></blockquote><h3 id="5-List提供的方法"><a href="#5-List提供的方法" class="headerlink" title="5.List提供的方法"></a>5.List提供的方法</h3><pre><code>增:    void add(int index, E element)    作用:给指定位置插入一个数据    void addAll(int index,Collection&lt;E&gt; C)    作用:给指定位置插入一组数据    删:    E remove(int index)        作用:删除指定位置的数据改:    E set(int index,E element)        作用:修改指定位置的元素        参数:1参,指定的位置;2参,修改后的元素    查:    E get(int index)        作用:获取指定位置的元素</code></pre><h3 id="6-HashSet的剔重原理"><a href="#6-HashSet的剔重原理" class="headerlink" title="6.HashSet的剔重原理"></a>6.HashSet的剔重原理</h3><pre><code>1.存入对象先判断对象的hashCode值是否与已经存储的数据hashcode值是否相同2.如果相等,在使用本次存入的对象与集合中的对象使用equals方法一一比较3.如果equals也相同,认为对象已经存储,将不再存入该对象</code></pre><h3 id="7-TreeSet存储"><a href="#7-TreeSet存储" class="headerlink" title="7.TreeSet存储"></a>7.TreeSet存储</h3><pre><code>TreeSet存储的数据要么拥有比较性(让存储的对象的类实现Comparable)要么指定比较器(创建TreeSet传入Comparator对象)</code></pre><h1 id="二十二-Map"><a href="#二十二-Map" class="headerlink" title="二十二.Map"></a>二十二.Map</h1><h3 id="1-作用-3"><a href="#1-作用-3" class="headerlink" title="1.作用:"></a>1.作用:</h3><p>​存储一组键值对应的数据类型的数据</p><h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h3><blockquote><p>名称</p><pre><code>键:key值:value</code></pre><p>体系结构</p><pre><code>Map    HashMap        特点:使用键值对的中键的hashcode值进行排序,允许空键空值,JDK1.2,线程不安全的    Hashtable        特点:使用键值对的中键的hashcode值进行排序,不允许空键空值,JDK1.0,线程安全的    TreeMap        特点:要求键要么拥有比较性,要么指定key的比较器    Properties        特点:HashMap的子类,可以加载读取文件中的内容,也可以向文件中写入内容注意:    key值不能重复</code></pre><p>Map提供的方法</p><pre><code>增    V put(K key, V value);        作用:添加        注意:            如果map中不存在该key,返回值为null            如果map中存在该key那么此时就是替换,返回被替换的值    void putAll(Map&lt;? extends K, ? extends V&gt; m);        作用:添加一组键值对删    V remove(Object key);        作用:通过key删除指定的键值对        返回值:被删除的值    void clear();        作用:清空查    int size();        作用:查询map中键值对的个数    boolean isEmpty();        作用:判断是否为空map    boolean containsKey(Object key);        作用:判断是否包含指定的key    boolean containsValue(Object value);        作用:判断是否包含指定的value    V get(Object key);        作用:获取key指定的值    Set&lt;K&gt; keySet();        作用:获取所有key的集合    Collection&lt;V&gt; values();        作用:获取所有值的集合    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();        作用:获取所有键值对的集合改    V put(K key, V value);        注意:如果存储数据时,key已经存在,此时就是修改**Map接口的遍历方式**</code></pre></blockquote><h3 id="3-特点"><a href="#3-特点" class="headerlink" title="3.特点:"></a>3.特点:</h3><pre><code>1.Map和collection并列存在,用于保存具有映射关系的数据Key-Value2.Map中的Key和Value可以是任何引用数据类型,会封装到HashMap&amp;$Node对象中3.Map中的Key不允许重复,有相同的key时,采用替换机制,新出现的替换已有的,原因和HashSet一样4.Map中value可重复5.Map的key可以为null,value也可以为null,key只能有一个null,value为null可以有多个6.常用的String类可作为Map的key7.key和value之间存在一对一关系，及通过指定可以总能找到对应的value。</code></pre><h3 id="4-Map接口的遍历方式"><a href="#4-Map接口的遍历方式" class="headerlink" title="4.Map接口的遍历方式"></a><strong>4.Map接口的遍历方式</strong></h3><pre><code class="java">Map map=new HashMap();     map.put(&quot;舒克&quot;,&quot;贝塔&quot;);     map.put(&quot;李大头&quot;,&quot;李大脑袋&quot;);     map.put(&quot;郭德纲&quot;,&quot;于谦&quot;);     map.put(&quot;岳云鹏&quot;,&quot;孙越&quot;);     map.put(null,&quot;kk&quot;);     map.put(&quot;king&quot;,null);System.out.println(&quot;===========第一种遍历===========&quot;);     //第一种遍历，先取出所有的Key，再通过Key取出对应的valueSet keyset = map.keySet();    //(1)增强forfor (Object key :keyset) &#123;    System.out.println(key+&quot;-&quot;+map.get(key));&#125;    //（2）迭代器Iterator iterator = keyset.iterator();while (iterator.hasNext()) &#123;    Object key =  iterator.next();    System.out.println(key + &quot;-&quot; + map.get(key));&#125;System.out.println(&quot;===========第二种遍历===========&quot;);//第二种，把所有的value取出Collection values = map.values();//可以使用collection使用的所有遍历方式//(1)迭代器Iterator iterator1 = values.iterator();while (iterator1.hasNext()) &#123;    Object value =  iterator1.next();    System.out.println(value);&#125;//(2)for增强for (Object o :values) &#123;    System.out.println(o);&#125;System.out.println(&quot;============第三种遍历============&quot;);//第三种遍历方式，通过EntrySet获取Set entryset = map.entrySet();//（1）增强forfor (Object entryset1 :entryset) &#123;    //将entryset1转成Map.entry    Map.Entry m=(Map.Entry) entryset1;    System.out.println(m.getKey()+&quot;-&quot;+m.getValue());&#125;//（2）迭代器Iterator iterator2 = entryset.iterator();while (iterator2.hasNext()) &#123;    Object next =  iterator2.next();     //将iterator2转成Map.entry    Map.Entry m1=(Map.Entry) next;    System.out.println(m1.getKey()+&quot;-&quot;+m1.getValue());&#125;</code></pre><h3 id="5-开发中如何选择集合实现类"><a href="#5-开发中如何选择集合实现类" class="headerlink" title="5.开发中如何选择集合实现类*"></a>5.<em>开发中如何选择集合实现类</em>*</h3><ol start="3"><li><pre><code>/*开发中如何选择集合实现类**  1. **先判断存储的类型（一组对象或一组键值对）**2. **一组对象（单列）：collection接口**   **允许重复：List**            **增删多：LinkedList   底层维护了一个双向链表**            **改查多：ArrayList    底层维护Object类型的可变数组**   **不允许重复  Set**            **无序:HashSet 底层是HashMap  维护了一个哈希表即数组+链表+红黑树**            **排序：TreeSet**            **插入和取出顺序一致：LinkedHashSet，维护数组+双向链表**3. **一对键值对（双列）：Map**   **键无序：HashMap  底层是：哈希表  jdk7：数组+链表   jdk8：数组+链表+红黑树**   **键排序：TreeMap   **键插入和取出顺序一致：LinkedHashMap      **读取文件：Properties   */</code></pre><h3 id="6-扩容机制"><a href="#6-扩容机制" class="headerlink" title="6.扩容机制"></a>6.扩容机制</h3><pre><code>**扩容机制：**1. HashMap底层维护了Node类型的数组table，默认为nll2. 当创建对象时，将加载因子（loadfactor）初始化为0.753. 当添加key-value时，通过key的哈希值得到table的索引，然后判断该索引处是否有元素，如果没有元素直接添加，如果该索引处有元素，判断钙元素的key是否和准备加入的key相等，如果相等，则直接替换val：如果不相等需要判断是树结构还是链表结构，做出相应的处理，如果添加时发现容量不够，则需要扩容4. 第一次添加，则需要扩容table容量为16，临界值为125. 以后再扩容，则需要扩容table容量为原来的2倍32，临界值为原来的2倍，即24，以此类推6. 在java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD(默认为8)，并且table的大小&gt;=MIN_TREEIFY_CAPACITY(默认64)就会进行树化</code></pre><h3 id="7-HashTable"><a href="#7-HashTable" class="headerlink" title="7.HashTable"></a>7.HashTable</h3><pre><code>1. 存放的元素时键值对 k-v2. hashtable的键和值都不能为空3. hashtable使用方法和HashMap基本一样4. hashtable是线程安全的5. hashtable底层有数组hashtable$Entry[]初始值为11，threshold=86. 扩容按照自己的扩容机制进行7. 扩容时执行addEntry（hash，key，value，index）；添加一个k-v封装在Entry8. 当count&gt;=threshold时就进行扩容9. 新的扩容时  （旧容量&lt;&lt;1）+1</code></pre><h3 id="8-Properties"><a href="#8-Properties" class="headerlink" title="8.Properties"></a>8.Properties</h3></li><li><p>properties类继承自hashtable类并且实现了Map接口，也是使用一种键值对的形式保存数据</p></li><li><p>使用特点和hashtable类似，不能有空的键和空的值</p></li><li><p>properties可以用于从  xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改</p></li><li><p>说明xxx.properties文件通常作为配置文件</p></li></ol><h3 id="9-collection工具类"><a href="#9-collection工具类" class="headerlink" title="9.collection工具类"></a>9.collection工具类</h3><ol><li>Collections是一个操作Set、List、Map等集合的工具类</li><li>Collections中提供了一系列静态的方法对集合元素进行排序、查询、修改等操作</li><li>排序操作：（均为static方法）<ul><li>resverse（List）：反转List中元素的顺序</li><li>shuffle（List）：对List集合元素进行随机排序</li><li>sort（List）：根据元素的自然顺序对指定的lisdt集合元素按升序排序</li><li>sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序</li><li>swap（List，int，int）：将指定list集合中i处元素和j处元素进行交换</li></ul></li></ol><p>4.查找，替换</p><ul><li>Object max（Collection）:根据元素的自然顺序，返回给的集合中最大的元素</li><li>Object  max（Collection，Comparator）根据Comparator指定的顺序，返回给定集合中最大的元素4</li><li>Object min（Collection）</li><li>Object  min（Collection，Comparator）</li><li>int  frequency（Collection，Object）将返回指定集合中指定元素出现的次数</li><li>void copy（List dest，List dest）将src中的内容复制到dest中</li><li>boolean  replaceAll（List list，Object oldVal，Object newVal）使用新值替换List对象的所有旧值</li></ul><h1 id="二十三-异常"><a href="#二十三-异常" class="headerlink" title="二十三.异常"></a>二十三.异常</h1><h3 id="1-概念-1"><a href="#1-概念-1" class="headerlink" title="1.概念:"></a>1.概念:</h3><p>在java语言中,将程序执行中发生的不正常情况称为异常</p><h3 id="2-分类-1"><a href="#2-分类-1" class="headerlink" title="2.分类:"></a>2.分类:</h3><pre><code>1.Error:java虚拟机无法解决的严重问题,如jvm系统内部错误,资源耗尽等2.Exception:因编程错误,或偶然的外部因素导致的一般性问题,可以使用正对性的代码处理,例如空指针访问,网络中断等.Exception分为两大类,运行时异常和编译时异常</code></pre><p>检查时异常<br>        概念:因语法问题导致的错误<br>        解决:修改语法<br>    运行时异常<br>        概念:但是因为编写时思路问题,或传入的数据导致程序无法正常运行<br>        解决:更换思路,修改传入的数据,加入容错判断</p><p>体系结构:</p><p>​Throwable:</p><p>​Error(错误)</p><p>​Exception(异常):CheckedException(检查时异常),RuntimeException(运行时异常)</p><h3 id="3-五大运行异常"><a href="#3-五大运行异常" class="headerlink" title="3.五大运行异常"></a>3.五大运行异常</h3><pre><code>1. NullPointerException 空指针异常   当应用程序试图在需要对象的地方使用null时，抛出该异常2. ArithmeticException  数学运算异常   当出现异常的运算条件时，抛出此异常3. ArrayIndexOutOfBoundsException数组下标越界异常   用非法索引访问数组时抛出异常，如果索引为负或大于等于数组，则为非法索引4. ClassCastException类型转换异常   当时图将对象强制转换为不是实例的子类时，抛出该异常5. NumberFormatException数字格式不正确异常   当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常=&gt;使用异常我们可以确保输入是满足条件数字</code></pre><h3 id="4-编译异常"><a href="#4-编译异常" class="headerlink" title="4.编译异常"></a>4.编译异常</h3><pre><code>SQLException    操作数据库时查询表可能发生异常IOException   操作文件时发生异常FileNotFoundException     当操作一个不存在的文件时，发生异常ClassNotFoundException    加载类，而类不存在时，发生异常EOFException    操作文件，到文件末尾，发生异常IllegalArguementException    参数异常</code></pre><h3 id="5-异常处理方式"><a href="#5-异常处理方式" class="headerlink" title="5.异常处理方式"></a>5.异常处理方式</h3><pre><code>try-catch    语法:    try&#123;        异常代码    &#125;catch(异常类型 变量名)&#123;        处理方式    &#125;catch(异常类型 变量名)&#123;        处理方式    &#125;.....    catch(异常类型 变量名)&#123;        处理方式    &#125;finally&#123;        必须执行的代码    &#125;注意:    1.如果发生异常,则异常后面的代码不再执行,直接进入catch    2.如果没有异常发生,则顺序执行try的代码块,不会进入catch    3.如果希望不管是否发生异常,都执行某段代码(关闭连接,释放资源)则使用finally    4.可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求父类异常在后，子类异常在前，比如（Exception在后，NULLpointerException在前）如果发生异常，只会匹配一个catch    5.也可以使用try-finally配合使用，**这种用法相当于没有捕获异常**，因此程序会崩。应用场景，就是执行一段代码，不管是否发生异常，都必须执行某个业务逻辑    6.捕获异常后，有return时，执行return但不会返回return的后缀，  执行finally</code></pre><pre><code>throws:    将发生的异常抛出,交给调用者自行处理,最顶尖的处理者是JVM    语法:        throws 异常类型1,异常类型2....        使用位置方法的形参之后    基本介绍:    1.如果一个方法中的语句执行时,可能生成某种异常,但是并不能确定如何处理这种异常,则此方法应显示声明抛出异常,表明该方法将不对异常进行处理,而是由方法的调用者处理    2.在方法声明时,可以使用throws抛出异常,throws后面的异常类型可以是方法中产生的异常类型,也可以是它的父类.    3.throws可以抛出多个异常    细节:    1. 对于编译异常，程序中必须处理，比如：try-catch或者throws    2. 对于运行时异常，程序中如果没有处理，默认就是throws的处理方式    3. 子类重写父类方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出异常类型的子类    4. 在throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必thows</code></pre><pre><code>throw    声明异常    语法:        throw 异常对象;    位置:方法中</code></pre><h3 id="6-自定义异常"><a href="#6-自定义异常" class="headerlink" title="6.自定义异常"></a>6.自定义异常</h3><p>当程序中出现某些错误时,但是该错误信息并没有在Throwable子类中描述处理,这个时候可以自己设计异常类,用于描述错误信息.</p><p>1.步骤:</p><pre><code>1.定义类:自定义异常类,2.异常类类名继承Exception或者RuntimeException3.编写其构造函数</code></pre><h1 id="二十四-数据结构"><a href="#二十四-数据结构" class="headerlink" title="二十四.数据结构"></a>二十四.数据结构</h1><h3 id="1-栈"><a href="#1-栈" class="headerlink" title="1.栈"></a>1.栈</h3><p>​先进后出</p><p>代码示例:</p><pre><code class="java">public class Stack &#123;    public static void main(String[] args) &#123;        stack01();    &#125;    public static void  stack01()&#123;        ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;();        for (int i = 0; i &lt;5; i++) &#123;            integers.add(i);        &#125;        while (integers.size()&gt;0)&#123;            Integer remove = integers.remove(integers.size() - 1);            System.out.print(remove+&quot; &quot;);        &#125;            System.out.println(integers);    &#125;&#125;</code></pre><h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2.队列"></a>2.队列</h3><p>​先进先出</p><p>代码示例:</p><pre><code class="java">public class Queue &#123;    public static void main(String[] args) &#123;        queue();    &#125;    public static void queue()&#123;        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        for (int i = 0; i &lt;5; i++) &#123;            list.add(i);        &#125;        while (list.size()&gt;0)&#123;            Integer remove = list.remove(0);            System.out.print(remove+&quot; &quot;);        &#125;    &#125;&#125;</code></pre><h3 id="3-单链表"><a href="#3-单链表" class="headerlink" title="3.单链表"></a>3.单链表</h3><p>​<img src="C:\Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230417193112848.png" alt="image-20230417193112848"></p><pre><code class="java">public class SingleLinkedList &#123;    public static void main(String[] args) &#123;        Node node4 = new Node(&quot;4&quot;,null);        Node node3 = new Node(&quot;3&quot;,node4);        Node node2 = new Node(&quot;2&quot;,node3);        Node node1 = new Node(&quot;1&quot;,node2);        System.out.print(node1.getData()+&quot;\t&quot;);        System.out.print(node1.next().getData()+&quot;\t&quot;);        System.out.print(node1.next().next().getData()+&quot;\t&quot;);        System.out.print(node1.next().next().next().getData()+&quot;\t&quot;);    &#125;&#125;class Node&#123;    private Object data;    private Node next;    public Node() &#123;    &#125;    public Node(Object data, Node next) &#123;        this.data = data;        this.next = next;    &#125;    public Object getData() &#123;        return data;    &#125;    public void setData(Object data) &#123;        this.data = data;    &#125;    public Node getNext() &#123;        return next;    &#125;    public void setNext(Node next) &#123;        this.next = next;    &#125;    public Node next()&#123;        return next;    &#125;</code></pre><h1 id="二十五-线程"><a href="#二十五-线程" class="headerlink" title="二十五.线程"></a>二十五.线程</h1><h3 id="1-作用-4"><a href="#1-作用-4" class="headerlink" title="1.作用:"></a>1.作用:</h3><p>​使代码可以同时执行多个事物</p><h3 id="2-名词"><a href="#2-名词" class="headerlink" title="2.名词"></a>2.名词</h3><pre><code>进程:一个正在执行的程序进程是程序的一次执行过程,或是正在运行的一个程序.是动态过程:有他自身的产生,存在,消亡</code></pre><pre><code>线程: 一个执行路径线程是由进程创建的,是进程的一个实体,一个进程可以有多个线程</code></pre><pre><code>单线程:同一时刻,只允许执行一个线程多线程:同一时刻,可以执行多个线程</code></pre><pre><code>主线程:一个线程创建时自带的一条线程,称为主线程</code></pre><pre><code>子线程:除主线程外都是子线程</code></pre><pre><code>守护线程(后台线程):    特点:如果一个进程的前台线程全部被销毁,此时不管是否有守护线程正在执行,此时进程都将被回收前台线程:    特点:如果一个进程中有前台线程存活,此时系统将不会回收进程</code></pre><h3 id="3-组成"><a href="#3-组成" class="headerlink" title="3.组成:"></a>3.组成:</h3><h3 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h3><pre><code>线程抢夺CPU执行权后可执行的时间</code></pre><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><pre><code>一个线程一个栈内存,多个线程共享一个堆内存</code></pre><h3 id="4-线程的创建"><a href="#4-线程的创建" class="headerlink" title="4.线程的创建"></a>4.线程的创建</h3><h3 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h3><pre><code>方式一:    创建Thread的子类对象    步骤:        1.创建一个类        2.使其继承Thread        3.重写run方法    注意:当前线程启动后,将执行如方法中的代码        4.创建该类对象    优点:可以创建无数个该类对象      方式二:      使用匿名内部类的形式创建Thread的子类对象          步骤:              Thread 对象名 = new Thread()&#123;                  重写run方法              &#125;          优点:便于书写        缺点:只能创建一个该线程对象</code></pre><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><pre><code>方式一:普通方式创建Runnable的子类对象    步骤:        1.创建一个类        2.使其实现Runnable接口        3.重写run方法        4.创建该类对象        5.在创建线程对象时传入该类对象(线程任务对象)方式二:    使用匿名内部类创建Runnable的子类对象        步骤:        1.Runnable 对象名 = new Runnable()&#123;            重写run方法        &#125;;        2.创建线程对象时传入该类对象(线程任务对象)</code></pre><h3 id="5-线程使用"><a href="#5-线程使用" class="headerlink" title="5.线程使用"></a>5.线程使用</h3><h5 id="5-线程的启动"><a href="#5-线程的启动" class="headerlink" title="5.线程的启动"></a>5.线程的启动</h5><pre><code>线程对象.start();注意:    1.当线程启动后会开启新的执行路径,执行run方法中的代码    2.如果直接使用线程对象调用run方法,不会开启新的执行路径</code></pre><h5 id="6-线程的销毁"><a href="#6-线程的销毁" class="headerlink" title="6.线程的销毁"></a>6.线程的销毁</h5><pre><code>线程已经启动,无法控制,需要等待执行完run方法中的代码</code></pre><h5 id="7-获取当前线程对象"><a href="#7-获取当前线程对象" class="headerlink" title="7.获取当前线程对象"></a>7.获取当前线程对象</h5><pre><code>Thread.currentThread();</code></pre><h5 id="8-线程名城"><a href="#8-线程名城" class="headerlink" title="8.线程名城"></a>8.线程名城</h5><pre><code>获取线程名称:    线程对象.getName();修改线程名称    线程对象.setName(name);注意:在启动前修改</code></pre><h5 id="9-线程优先级"><a href="#9-线程优先级" class="headerlink" title="9.线程优先级"></a>9.线程优先级</h5><pre><code>作用:提高线程抢夺到CPU执行权的概率语法:    线程对象.setPriority(int);注意:    1.取值范围1-10;    2.必须在线程启动前</code></pre><h5 id="10-线程休眠"><a href="#10-线程休眠" class="headerlink" title="10.线程休眠"></a>10.线程休眠</h5><pre><code>作用:让线程暂时停止运行方法:    static void sleep(休眠时间);注意:    1.单位毫秒    2.使用类调用,使当前线程休眠    3.线程休眠期间不会抢夺CPU执行权</code></pre><h5 id="11-线程礼让"><a href="#11-线程礼让" class="headerlink" title="11.线程礼让"></a>11.线程礼让</h5><pre><code>作用:将获取道德cpu执行权让出,重新参与抢夺方法:    static native void yield();</code></pre><h5 id="12-线程合并"><a href="#12-线程合并" class="headerlink" title="12.线程合并"></a>12.线程合并</h5><pre><code>作用:合并线程方法:    public final void join();</code></pre><h5 id="13-守护线程"><a href="#13-守护线程" class="headerlink" title="13.守护线程"></a>13.守护线程</h5><pre><code>有名:后台线程特点:当一个进程中有前台线程存活,此时该进程就不会被系统回收如果一个进程中只剩余后台线程,此时不管后台线程中的代码是否运行完毕,系统都将回收该进程方法:    public final void setDaemon(boolean on);    true:表示守护线程,默认为false,表示前台线程    注意:        1.创建线程对象与主线程默认为前台线程        2.必须在线程启动前</code></pre><h3 id="6-线程的生命周期"><a href="#6-线程的生命周期" class="headerlink" title="6.线程的生命周期"></a>6.线程的生命周期</h3><pre><code>线程可以处于以下状态之一1. NEW: 尚未启动的线程处于此状态2. RUNNABLE:在java虚拟机中执行的线程处于此状态；内部会分为ready和running两部分，执行哪一个由调度器决定3. BLOCKED: 被阻塞等待监视器锁定的线程处于此状态4. WAITING ：正在等待另一个线程执行特定动作的线程处于此状态5. TIMED_WAITING :正在等待另一个线程执行动作达到指定等待时间的线程处于此状态（超时等待）6. TERMINATED:一退出的线程出于此状态</code></pre><p><img src="C:\Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230418171549456.png" alt="image-20230418171549456"></p><h3 id="7-Thread和Runnable的区别"><a href="#7-Thread和Runnable的区别" class="headerlink" title="7.Thread和Runnable的区别"></a>7.Thread和Runnable的区别</h3><pre><code>1. 从java设计来看，通过继承Thread或者实现Runnable接口来创建线程本质上没有区别，从jdk帮助文档我们可以见到Tread类本身就实现了Runnable接口2. 实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制</code></pre><h3 id="8-线程安全问题"><a href="#8-线程安全问题" class="headerlink" title="8.线程安全问题"></a>8.线程安全问题</h3><h5 id="原因"><a href="#原因" class="headerlink" title="原因:"></a>原因:</h5><p>多个线程操作同一数据,会导致线程安全问题</p><h5 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h5><p>保证同时只能有一个线程操作该数据</p><h5 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h5><pre><code>方案一:同步代码块    语法:        synchronized(锁对象)&#123;            要同步的代码        &#125;    注意:    1.所有对象都可以作为锁对象    2.多个线程的锁对象要是同一个对象</code></pre><pre><code>方案二:同步方法    语法:        访问权限修饰符 synchronized 返回值类型 方法名(形参列表)&#123;        &#125;    注意:        1.同步方法法人锁对象是this        2.多个线程的锁对象要是同一个对象</code></pre><pre><code>方案三:同步静态方法    语法:        访问权限修饰符 synchronized static 返回值类型 方法名(形参列表)&#123;                &#125;    注意:        1.同步静态方法的锁对象是该类的对象            类对象:当JVM加载类时.会产生一个对象,该对象就是该类的类对象,一个类只有一个类对象        2.多个线程的锁对象要是同一个对象</code></pre><h3 id="9-死锁"><a href="#9-死锁" class="headerlink" title="9.死锁"></a>9.死锁</h3><h5 id="原因-1"><a href="#原因-1" class="headerlink" title="原因:"></a>原因:</h5><p>多个线程互相持有对方所需的锁资源</p><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><pre><code class="java">Object A = new Object();Object B = new Object();线程1:    xxx    synchronized (A)&#123;        xxx        synchronized (B)&#123;            xxx        &#125;    &#125;线程2:    xxx    synchronized (B)&#123;        xxx        synchronized (A)&#123;            xxx        &#125;    &#125;</code></pre><p>避免思路</p><pre><code>不要在同步中使用</code></pre><h3 id="10-线程间通讯"><a href="#10-线程间通讯" class="headerlink" title="10.线程间通讯"></a>10.线程间通讯</h3><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><pre><code>1.线程间通讯的方法是由Object提供的2.只能在同步中使用3.只能使用所在的同步的锁对象调用</code></pre><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><pre><code>唤醒线程    notify():随机唤醒一个    notifyAll():唤醒所有    注意:只能唤醒以同一个对象调用wait方法的线程线程休眠:    wait() 无限休眠    wait(int ms) 有限期休眠(休眠ms毫秒)    wait(int ms,int ns)有限期休眠    注意:        ms为毫秒,ns为纳秒    </code></pre><h3 id="11-wait和sleep的区别"><a href="#11-wait和sleep的区别" class="headerlink" title="11.wait和sleep的区别"></a>11.wait和sleep的区别</h3><pre><code>1.wait在休眠期会释放所持有的锁资源,sleep不会2.wait必须在同步使用,sleep没有限制3.wait必须使用所在的同步锁对象调用,sleep使用Thread类或者Thread类的对象调用4.wait由Object提供,sleep由Thread类提供</code></pre><h3 id="13-线程池"><a href="#13-线程池" class="headerlink" title="13.线程池"></a>13.线程池</h3><h5 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h5><p>​优化线程</p><h5 id="原因-2"><a href="#原因-2" class="headerlink" title="原因:"></a>原因:</h5><pre><code>一个线程大约占1MB的运行内存大量创建线程时可能会导致内存溢出大量的创建线程也导致需要对象线程频繁的创建与回收</code></pre><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><pre><code>1.使用空闲的线程执行新的任务(线程复用)2.使用一个容器来管理线程的创建,回收,复用等注意:java中提出线程池来完成以上操作</code></pre><h5 id="线程池的体系结构"><a href="#线程池的体系结构" class="headerlink" title="线程池的体系结构"></a>线程池的体系结构</h5><pre><code>Executor(接口)    提供的方法:        void execute(Runnable command);        作用:执行线程任务,子接口提供了submit优于该方法    子类或子接口        ExecutorService(接口)            提供的方法:                void shutdown();                作用:关闭线程池                boolean isShutdown();                作用:判断线程池是否关闭                Future&lt;T&gt; submit(线程任务)                作用:提交线程任务            子类或子接口:                ScheduledExecutorService(接口)                ThreadPoolExecutor(类)                    构造函数:                        public ThreadPoolExecutor(int corePoolSize,                                    int maxmumPoolSize,                                    long keepAliveTime,                                    TimeUnit unit,                                    BlockingQueue&lt;Runnable&gt; workQueue,                                    ThreadFactory threadFactory,                                    RejectedExecutionHandler handler)                                                        corePoolSize:h核心线程数,线程池中最少有几个线程                    maximumPoolSize:最大线程数,线程中最多可以容纳的线程数                    keepAliveTime:销毁时间,当线程执行完任务后,多久销毁                    until:时间单位                    workQueue:存储执行的线程任务的集合(队列形式)                    threadFactory:创建线程                    handler:优化线程,使其线程复用的算法</code></pre><h5 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h5><pre><code>作用:创建线程池原因:应为ThreadPoolExecutor过于麻烦,所以JDK提供该类帮助我们创建线程池提供的方法    1.固定线程池    特点:线程池中的线程数量恒定,当线程任务小于线程数量时,随机在线程池中挑选线程执行任务,当线程任务大于线程数量,会先执行前面的任务,后等前面任务执行完毕后,使用执行完毕的线程,执行剩余任务.    static ExecutorService newFixedThreadPool(int nThreads)        nThreads:线程池中线程的数量            2.可变线程池    特点:线程池中的线程数量可变    static ExecutorService newCachedThreadPool()        3.单例线程池    特点:一个线程池只有一个线程    static ExecutorService newSingleThreadExecutor()        4.抢占线程池    static ExecutorService newWorkStealingPool()        5.调度线程池    特点:该线程池执行任务可以延迟,也可以延迟重复执行    static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)    corePoolSize:线程池中线程的数量        6.单例调度线程池    特点:调度线程池中只有一个线程    static ScheduledExecutorService newSingleThreadScheduledExecutor();</code></pre><h5 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h5><pre><code>步骤:1.创建线程池2.提交任务3.关闭线程池</code></pre><h5 id="调度线程池-ScheduledExecutorService"><a href="#调度线程池-ScheduledExecutorService" class="headerlink" title="调度线程池:ScheduledExecutorService"></a>调度线程池:ScheduledExecutorService</h5><pre><code>提供的方法:    public ScheduledFuture&lt;?&gt; schedule(线程任务,long delay,TimeUnit unit)    作用:延迟执行   </code></pre><pre><code>public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command                                            long initialDelay                                            long period                                            TimeUnit unit);    作用:延迟重复执行    1参,执行的任务    2参,延迟时间    3参,间隔时间 = 本次任务开始时间 - 上次任务开始时间    注意:如果上次任务执行时间&gt;间隔时间,那么当上次任务执行完毕后,本次任务直接开始   4参,时间单位</code></pre><pre><code>public ScheduledFuture&lt;?&gt; scheduleWithFixedDaley(Runnable command,                                            long initialDelay                                            long delay                                            TimeUnit unit);    作用:延迟重复执行    1参,执行任务    2参,延迟时间    3参,间隔时间= 本次任务开始时间-上次任务结束时间    4时间单位</code></pre><h3 id="14-Callable"><a href="#14-Callable" class="headerlink" title="14.Callable"></a>14.Callable</h3><p>作用:有返回值的线程任务对象</p><p>注意:无法在创建Thread对象时传入,必须配合线程池使用</p><h3 id="15-Lock"><a href="#15-Lock" class="headerlink" title="15.Lock"></a>15.Lock</h3><p>作用:简化同步</p><h5 id="同步"><a href="#同步" class="headerlink" title="同步:"></a>同步:</h5><pre><code>同步代码块    synchronize(锁对象)&#123;        //关锁        代码        //开锁    &#125;同步方法    访问权限修饰符 synchronize 返回值类型 方法名(形参列表)&#123;        //关锁        方法        //开锁    &#125;同步静态方法    访问权限修饰符 synchronize static 返回值类型 方法名(形参列表)&#123;        //关锁        方法        //开锁    &#125;</code></pre><h5 id="lock体系"><a href="#lock体系" class="headerlink" title="lock体系"></a>lock体系</h5><pre><code>Lock    提供的方法:        void lock():关锁        void unLock():开锁            Condition newCondition():获取锁对象            void await():无限期休眠            void signal():随机唤醒一个            void signalAll():唤醒所有    子类:        ReentrantLock        ReadWriteLock    提供的方法:        Lock readLock():获取读锁        Lock writeLock():获取写锁        注意:            读-写互斥            读-读 不互斥            写-写互斥    子类        ReentrantReadWriteLock</code></pre><h1 id="二十六-x2F-设计模式"><a href="#二十六-x2F-设计模式" class="headerlink" title="二十六&#x2F;设计模式"></a>二十六&#x2F;设计模式</h1><p>作用:解决特定问题的思路</p><h3 id="1-生成者与消费者"><a href="#1-生成者与消费者" class="headerlink" title="1.生成者与消费者"></a>1.生成者与消费者</h3><p>1.生产者消费者模式解决进销存业务</p><pre><code>生产    无限生产销售    无限销售工厂    生产的方法    出货的方法库存数量商品数量上限:100商品数量下限:0</code></pre><h3 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2.单例模式"></a>2.单例模式</h3><p>解决的问题</p><pre><code>一个类只能有一个对象</code></pre><p>分类</p><pre><code>懒汉式    步骤:        1,私有化构造函数        2,提供一个公共的属性,记录该类的唯一对象        3,提供一个公共的静态方法返回该类创建好的对象    优点:        节省内存    缺点:        有线程安全问题饿汉式    步骤:        1,私有化构造函数        2,提供一个公共的属性,记录该类的唯一对象,并创建该对象        3,提供一个公共的静态方法返回该类创建好的对象    优点:        不存在线程安全问题    缺点:        浪费内存        线程安全的懒汉式    代码:        public class C &#123;       private static C c;       private C()&#123;       &#125;       public synchronized C getInstance()&#123;           if (c == null)&#123;               c = new C();           &#125;           return c;       &#125;   &#125;优点:    线程安全缺点:    效率慢    内部类饿汉式    代码:   public class D &#123;       private D()&#123;       &#125;       public static D getInstance()&#123;           return InClass.getD();       &#125;       static class InClass&#123;           private static D d = new D();           public static D getD()&#123;               return d;           &#125;       &#125;   &#125;</code></pre><h3 id="3-工程模式"><a href="#3-工程模式" class="headerlink" title="3.工程模式"></a>3.工程模式</h3><p><strong>解决问题</strong></p><pre><code>特定编号生产特定商品</code></pre><pre><code>家具厂    沙发    椅子    床    衣柜    茶几    ...分析:    类        家具厂类            家具接口对象 生产的方法(编号)&#123;                switch(编号)&#123;                    case 1:            &#125;        &#125;    家具接口    沙发类 实现 家具接口    椅子类 实现 家具接口    床类 实现 家具接口    衣柜类 实现 家具接口    茶几类 实现 家具接口</code></pre><h1 id="二十七-IO流"><a href="#二十七-IO流" class="headerlink" title="二十七.IO流"></a>二十七.IO流</h1><h3 id="1-作用-5"><a href="#1-作用-5" class="headerlink" title="1.作用"></a>1.作用</h3><pre><code>传输数据</code></pre><h3 id="2-分类-2"><a href="#2-分类-2" class="headerlink" title="2.分类"></a>2.分类</h3><pre><code>按照流向分类    输入流    输出流按照传输的最小数据单位分类    字节流        最小单位:byte    字符流        最小单位char                   按照功能分类           节点流:               从数据源到程序,或从程序直接到数据源           包装流(过滤流)            在节点流的基础上增强功能            注意:所有的包装流都使用了装饰者模式</code></pre><h3 id="3-字节流"><a href="#3-字节流" class="headerlink" title="3.字节流"></a>3.字节流</h3><p>体系结构:</p><pre><code>InputStream(字节输入流顶级接口)    方法:        int read();一次读取一个字节,返回值为读取到的字节        int read(byte b[]):一次读取一组字节数据到数组B中,返回值为读取到的字节长度,当返回值为-1时表示读取结束        int read(byte[],int off,int len);一次读取一组字节数据到数组b中,从off位置开始存储,存储len个字节        返回值为读取到的字节长度,当返回值为-1时表示读取结束                void close(); 关闭流对象        </code></pre><h4 id="3-1-OutputStream-字节输出流顶级接口"><a href="#3-1-OutputStream-字节输出流顶级接口" class="headerlink" title="3.1.OutputStream(字节输出流顶级接口)"></a>3.1.OutputStream(字节输出流顶级接口)</h4><pre><code>方法:    void write(int b);一次写入一个字节    void write(byte b[]);一次写入一组字节    void write(byte b[],int off,int len);一次写入一组字节,从off位置开始,写入len    void flush():冲刷    void close();关流</code></pre><h4 id="3-2文件字节流"><a href="#3-2文件字节流" class="headerlink" title="3.2文件字节流"></a>3.2文件字节流</h4><pre><code>FileInputStream    分类:        输入流:文件到程序        节点流FileOutputStream    分类:        输出流:程序到文件        节点流</code></pre><h4 id="3-3内存流"><a href="#3-3内存流" class="headerlink" title="3.3内存流"></a>3.3内存流</h4><pre><code>作用:在读取数据过程中,因数据不全导致的乱码问题ByteArrayInputStreamByteArrayOutputStream    特有方法:        byte toByteArray();将内存流中的数据获取出来</code></pre><h4 id="3-4缓冲流"><a href="#3-4缓冲流" class="headerlink" title="3.4缓冲流"></a>3.4缓冲流</h4><pre><code>作用:提高读写效率注意:    包装流    BufferedInputStream    BufferedOutputStream    注意:默认缓冲区大小为8kb</code></pre><h4 id="3-5对象流"><a href="#3-5对象流" class="headerlink" title="3.5对象流"></a>3.5对象流</h4><pre><code>作用:将对象写入到文件中,或从文件中读取对象注意:    1.读写的对象所属的类要实现序列化接口    2.一个对象流只能读写一个对象    3.存储的所有数据都必须进行序列化    4.static修饰的属性,transient修饰的属性不参与序列化    ObjectInputStream    readObject():读取对象,只读第一个ObjectOutputStream    wirteObject();写入对象</code></pre><h3 id="4-字符流"><a href="#4-字符流" class="headerlink" title="4.字符流"></a>4.字符流</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h4><pre><code>传输的数据单位最小为字符(char)</code></pre><h4 id="字符流体系"><a href="#字符流体系" class="headerlink" title="字符流体系"></a>字符流体系</h4><pre><code>Reader    概念:所有字符输入流的父类    提供方法:        int read(),一次获取一个字符,返回值为读取到的字符.        int read(char c[]):一次去取一组字符到数组c中,返回值为读取到的字符长度,当为-1时表示读取结束        int read(char c[],int off,int len)            一次去取一组字符到数组c中,从off位置开始存储,存储len个,返回值为读取到的字符长度,当为-1时别是读取结束        void close() 关闭</code></pre><pre><code>Wirter    概念:所有字符输出流的父类    提供的方法:        void write(int c)        void write(char cbuf[])        void write(char cbuf[],int off,int len)        void write(String str)        void flush()        void close()</code></pre><h4 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h4><pre><code>FileReaderFileWriter</code></pre><h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><pre><code>BufferedReader    readLine();读取一行BufferedWriter    nextLine():写入下一行</code></pre><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><pre><code>InputStreamReaderOutputStreamWriter</code></pre><h4 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h4><pre><code>PrintStream    注意:字节流</code></pre><h3 id="5-File"><a href="#5-File" class="headerlink" title="5.File"></a>5.File</h3><pre><code>概念:文件或文件夹对应的类</code></pre><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><pre><code>1.创建File类的对象2.调用属性或方法</code></pre><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><pre><code>公共构造函数    File(String pathname)        pathname:文件或文件夹的路径    File(String parent,String child)        parent:上级文件夹的路径        child:当前文件的名称.后缀名    File(File parent,String child)        parent:上级文件夹的file对象        child:当前文件的名称.后缀名            File(URI uri)        uri:资源所在位置        如:            URI uri = URI.create(&quot;D:\\a.txt&quot;);            File file = new File(uri);    注意:      路径分为绝对路径和相对路径          绝对路径:从盘符开始          相对路径:相对于项目路径下              注意:                  . 当前路径                  ..上级文件夹</code></pre><h4 id="属性"><a href="#属性" class="headerlink" title="属性:"></a>属性:</h4><pre><code>public static separator:获取当前系统的路径分隔符</code></pre><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><pre><code>mkdir():创建一级文件夹mkdirs():创建多级文件夹createNewFile():创建一级文件delete():删除一级文件或一级文件夹getParent():获取上级文件夹路径getParentFile():获取上级文件夹的file对象getPath():获取当前路径getAbsolutePath():获取当前文件的绝对路径getAbsoluteFile():获取绝对路径文件isDirectory():判断是否为文件夹isFile()判断是否为文件exists():判断文件或文件夹是否存在length():获取文件大小,单位字节renameTo():修改文件名称File[] listFiles();File[] listFiles(FileFilter ff);File[] listFiles(FilenameFilter ff);    获取当前文件夹下的文件或文件夹    注意:        FileFilter是文件过滤器        重写的是boolean accept(File pathname)        当返回值为true表示可以通过,反之false不通过                FilenameFilter文件名称过滤器            重写的是boolean accept(File f , String name)            当返回值为true表示可以通过,反之false不通过            f:父级文件对象            name:当前文件名称</code></pre><h1 id="二十八-网络编程"><a href="#二十八-网络编程" class="headerlink" title="二十八.网络编程"></a>二十八.网络编程</h1><h3 id="1-网络相关概念"><a href="#1-网络相关概念" class="headerlink" title="1.网络相关概念"></a>1.网络相关概念</h3><p><strong>概念</strong>:两台设备之间通过网络实现数据通信</p><p><strong>网络通信</strong>:将数据通过网络从一台设备传输到另一台设备</p><p>java.net包提供了一系列的类或接口,供程序员使用,完成网络通信</p><h4 id="常用名词"><a href="#常用名词" class="headerlink" title="常用名词"></a>常用名词</h4><pre><code>互联网(Internet):点与点相连万维网(www):端与端相连物联网:物物互联网络编程:让计算机与计算机之间建立连接.</code></pre><h3 id="2-OSI网络架构"><a href="#2-OSI网络架构" class="headerlink" title="2.OSI网络架构"></a>2.OSI网络架构</h3><pre><code>简介    open System Interconnect开放式系统互联    存在于概念和理论上的一种模型,他的缺点是分层太多,增加了网络工作的复杂性,所以没有大规模应用</code></pre><p><img src="C:\Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230424171347594.png" alt="image-20230424171347594"></p><pre><code>第一层:物理层为设备之间的数据通信提供传输信号和物理介质(双绞线,光导纤维)作用:建立/维护/断开物理连接.第二层:链路层在物理层上,通过规程或协议(差错控制)来控制传输数据的正确性(MAC)    作用:接受来自物理层的位流形式的数据,并封装成帧,传送到上一层,同样,也将来自上层的数据帧,拆装为位流形式的数据转发到物理层,并且还负责处理接收端发回的确认帧的信息,以便提供可靠的数据传输    第三层:网络层负责定义了能够标识所有网络节点的逻辑地址(IP地址)    作用:逻辑寻址,Ip地址,在下两层的基础上向资源子网提供服务    第四层:传输层负责是否选择差错回复协议,数据流重用,错误顺序排序(tcp,udp)    作用:提供可靠的和不可靠的传输机制TCP/UDP    第五层:会话层负责使应用建立和维持会话,使通信在失败时继续恢复通信(断电续传)    作用:建立/终止/管理实体间会话连接    第六层:表示层负责定义转换数据格式及加密,允许选择以二进制或ASCII格式传输    作用:分装数据格式(加密解密,压缩解压缩)    第七层:应用层负责文件访问和管理/可靠运输服务,远程操作服务(HTTP/FTP/SMTP)    作用:人与机器电脑交互的窗口    </code></pre><h3 id="3-IP地址"><a href="#3-IP地址" class="headerlink" title="3.IP地址"></a>3.IP地址</h3><h4 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址:"></a>ip地址:</h4><pre><code>1.概念:用于标识网络中的每台计算机/主机2.查看ip地址:ipconfig3.ip地址的表现形式:点分十进制  xx.xx.xx.xx4.每一个十进制的范围是0-2555.IP地址的组成= 网络地址+主机地址6.ipv6是互联网工程任务组设计的用于代替ipv4的下一代ip协议，其地址数量号称可以为全世界每一粒沙子编上一个地址7.由于ipv4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。ipv6的使用，不仅解决了网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍</code></pre><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><pre><code>1.www.baidu.com2.好处:方便记忆,解决记忆ip的困难3.概念:将ip地址映射成域名</code></pre><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><pre><code>1.概念:用于标识计算机上某个特定的网络程序2.表现形式:以整数形式,范围0-655353.0-1024已经被占用,比如:ssh 22, ftp 21,smtp 25,http 804.常见的网络端口号    tomcat:8080    musql:3306    oracle:1521    </code></pre><h3 id="4-通信协议"><a href="#4-通信协议" class="headerlink" title="4.通信协议"></a>4.通信协议</h3><h4 id="TCP-x2F-IP网络框架"><a href="#TCP-x2F-IP网络框架" class="headerlink" title="TCP&#x2F;IP网络框架"></a>TCP&#x2F;IP网络框架</h4><p><img src="C:\Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230424174928746.png" alt="image-20230424174928746"></p><pre><code>TCP协议:传输控制协议是一种面向连接的/可靠的/基于字节流的传输层通信协议.数据大小无限制.建立连接的过程需要三次握手,断开连接的过程需要四次挥手,  在连接中可进行大数据量的传输；传输完毕，需释放已建立的连接，效率低。UDP协议:用户数据报协议    是一种无连接的传输层协议,提供面向事物的简单不可靠信息传送服务,每个包的大小64kb,因无需连接，故是不可靠的；发送数据结束时无需释放资源（因为不是面向连接的），速度快；</code></pre><h3 id="5-InetAddress"><a href="#5-InetAddress" class="headerlink" title="5.InetAddress"></a>5.InetAddress</h3><p><strong>功能:</strong></p><pre><code>1.获取本机InetAddress对象,getLocalHost2.根据指定主机名/域名获取IP地址对象,getByName3.获取InetAddress对象的主机名getHostNmae4.获取InetAddress对象的地址getHostAddress</code></pre><pre><code class="java">//获取主机名+ip地址InetAddress localHost = InetAddress.getLocalHost();System.out.println(localHost);//获取主机名String hostName = localHost.getHostName();System.out.println(hostName);InetAddress byName = InetAddress.getByName(&quot;DESKTOP-HT1OC9N&quot;);System.out.println(byName);</code></pre><h3 id="6-Socket编程"><a href="#6-Socket编程" class="headerlink" title="6.Socket编程"></a>6.Socket编程</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h4><pre><code>socket:套接字,网络中的一个节点通讯要求:地址+端口号</code></pre><h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><pre><code>TCP:面向有连接,安全可靠的,速度慢    特点:三次握手,四次挥手UDP:面向无连接,不安全,速度快</code></pre><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><pre><code>简介:是一种面向连接的/可靠的/基于字节流的传输层通信协议,数据大小无限制,建立连接过程需要三次握手,断开连接的过程需要四次挥手注意:分为客户端Socket与服务器ServerSocket</code></pre><h4 id="服务端开发步骤"><a href="#服务端开发步骤" class="headerlink" title="服务端开发步骤"></a>服务端开发步骤</h4><pre><code>1.创建ServerSocket,指定端口2.调用accept等待客户端接入3.使用输入流,接收客户端请求中的数据4.使用输出流,给客户端回馈数据(可选)5.关闭释放资源</code></pre><h4 id="客户端开发步骤"><a href="#客户端开发步骤" class="headerlink" title="客户端开发步骤"></a>客户端开发步骤</h4><pre><code>1.创建Socket对象,指定服务器IP+端口2.使用输出流,发起请求,给服务器发送数据3.使用输入流,界海服务器返回的数据(可选)4.关闭释放资源</code></pre><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><pre><code>简介:UDP协议是一种不可靠的网络协议,提供面向事务的简单不可靠信息传送服务,每个包的大小64kb分为:接收端与发送端</code></pre><h4 id="发送端开发步骤"><a href="#发送端开发步骤" class="headerlink" title="发送端开发步骤"></a>发送端开发步骤</h4><pre><code>1.创建发送端的Socket对象(DatagramSocket)2.创建数据,并打包3.调用DatagramSocket对象的方法发送数据4.关闭发送端</code></pre><h4 id="接收端开发步骤"><a href="#接收端开发步骤" class="headerlink" title="接收端开发步骤"></a>接收端开发步骤</h4><pre><code>1.创建发送端Socket(DatagramSocket)2.创建一个数据包,用于接收数据3.调用DatagramSocket对象的方法接受数据4.解析数据包,在控制台显示5.关闭接收端</code></pre><h1 id="二十九-反射"><a href="#二十九-反射" class="headerlink" title="二十九.反射"></a>二十九.反射</h1><h3 id="1-反射机制"><a href="#1-反射机制" class="headerlink" title="1.反射机制"></a>1.反射机制</h3><pre><code>1.反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息(如成员变量,成员方法,构造器)并能操作对象的属性及方法,反射在设计模式和框架底层都会用到2.加载完类之后,在堆中就产生了一个class对象(一个类只有一个class对象)这个对象包含了类的完整结构信息,通过这个对象得到类的结构,这个对象就像一面镜子,透过这个镜子看到类的结构,所以称为反射</code></pre><h3 id="2-类对象"><a href="#2-类对象" class="headerlink" title="2.类对象"></a>2.类对象</h3><pre><code>一个类被加载时会产生一个对象,该对象称为该类的类对象,该对象属于Class类的对象类对象中包含该类的所有信息,如包,实现的接口,类名,属性,方法,构造函数,注解等内容注意:一个类只有一个类对象</code></pre><h3 id="3-java反射机制可完成的任务"><a href="#3-java反射机制可完成的任务" class="headerlink" title="3.java反射机制可完成的任务:"></a>3.java反射机制可完成的任务:</h3><pre><code>1.在运算时判断任意一个对象所属的类2.在运行时构造任意一个类的对象3.在运行时得到任意一个类所具有的成员变量和方法4.在运行时调用任意一个对象的成员变量和方法&#39;5.生成动态代理</code></pre><h3 id="4-反射相关的主要类"><a href="#4-反射相关的主要类" class="headerlink" title="4.反射相关的主要类"></a>4.反射相关的主要类</h3><pre><code>1. java.lang.Class代表一个类,Class对象表示某个类加载后在堆中的对象2.java.lang.reflect.Field 代表类的成员变量,Filed对象表示某个类的成员变量//getFiled不能得到私有属性3.java.lang.reflect.Method 代表类方法,Method对象表示某个类的方法4.java.lang.reflect.Constructor 代表类的构造方法Constructor对象表示构造器(),括号内可以指定参数类型,String.class</code></pre><h3 id="5-反射的优缺点"><a href="#5-反射的优缺点" class="headerlink" title="5.反射的优缺点"></a>5.反射的优缺点</h3><p>​<strong>优点</strong></p><p>​可以动态的创建和使用对象,使用灵活,没有反射机制,框架技术就失去了底层支撑</p><p>​<strong>缺点</strong></p><p>​使用反射机制基本都是解释执行,对执行速度有影响</p><h3 id="6-如何获取类对象"><a href="#6-如何获取类对象" class="headerlink" title="6.如何获取类对象"></a>6.如何获取类对象</h3><pre><code>方式1:类名.class方式2.对象名.getClass()方式3:Class.forName(&quot;类的全路径&quot;)    类的全路径:类所属的包名+类名</code></pre><h3 id="7-类对象-Class类"><a href="#7-类对象-Class类" class="headerlink" title="7.类对象(Class类)"></a>7.类对象(Class类)</h3><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><pre><code>1.Class也是类,因此也继承Object类2.Class类对象不是new出来的,而是系统创建的3.对于某个类的Class对象,在内存中只有一份,因为类只加载一次4.每个类的实例都会记得自己由那个Class实例所生成5.通过Class可以完整的得到一个类的完整结构,通过一系列API6.Class对象存放在堆中7.类的字节码二进制数据,是在方法区的,有的地方称为类的元数据(包括方法代码,变量名,方法名,访问权限)</code></pre><h5 id="提供的方法"><a href="#提供的方法" class="headerlink" title="提供的方法"></a>提供的方法</h5><pre><code>类相关:    包        Pckage getPackage()    类名        String getSimpleName()    类的全路径名        String getName()    父类的类对象        Class&lt;? super T&gt; getSuperclass()    接口的类对象        Class&lt;?&gt;[] getInterface()    调用缺省构造函数,返回该Class对象的一个实例     Object newInstance()        </code></pre><pre><code>属性相关    获取所有的公共属性,包含父类提供的公共属性        Field[] getFields();    获取所有的属性,不包含父类提供的        Field[] getDeclaredField()    获取指定的公共属性        Field getField(String name)    获取指定的属性        Field getDeclaredField(String name)    Field提供的方法        Object get(Object obj);            作用:获取指定对象的该属性值            1参:指定对象        void set(Object obj,Object v)            作用:修改指定对象的改属性值            1参:指定的对象            2参:修改后的值        setAccessible(boolean flag) 是否略过访问权限修饰符            默认为false,表示不略过            当值为true表示略过</code></pre><pre><code>方法相关    获取所有的公共方法,包含父类提供的        Method[] getMethods()        获取所有的方法,不包含父类        Method[] getDeclaredMethods()            获取单独一个公共的方法        Method getMethod(String name,Class&lt;?&gt;...parameterTypes)        1参:要获取的方法名        2参:该方法的形参列表对应的数据类型的对象        注意:按顺序书写,基本数据类型的类对象是数据类型.class,其包装类的类对象是类名.class                获取单独一个方法        Method getDeclaredMethod(Stirng name,Class&lt;?&gt;...parameterTypes)        1参:要获取的方法名        2参:该方法的形参列表对应的数据类型的类对象        注意:按顺序书写,基本数据类型的类对象是数据类型.class,其包装类的类对象是类名.class                Method提供的方法        Object invoke(Object obj,Object...args)            作用:执行该方法            1.执行该方法的对象            2参:执行该方法所需要的实参列表            返回值:执行该方法的返回值                    setAccessible(boolean flag) 是否略过访问权限修饰符            默认为false,表示不略过            当值为true表示略过</code></pre><pre><code>构造函数相关    Constructor&lt;?&gt;[] getConstructors()        作用:获取该类中所有的公共构造函数            Constructor&lt;?&gt;[] getDeclaredConstructors()        作用:获取所有的构造函数            Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;...parameterTypes)        作用:获取指定的一个构造函数        参数:构造函数对比的形参列表的数据类型的类对象            Constructor提供的方法            Class&lt;?&gt;[] getInterface()    调用缺省构造函数,返回该Class对象的一个实例     Object newInstance()</code></pre><h1 id="三十-枚举"><a href="#三十-枚举" class="headerlink" title="三十.枚举"></a>三十.枚举</h1><h3 id="1-使用步骤"><a href="#1-使用步骤" class="headerlink" title="1.使用步骤"></a>1.使用步骤</h3><pre><code>1.定义2.使用</code></pre><h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2.定义:"></a>2.定义:</h3><pre><code>语法:    访问权限修饰符 enum 枚举名(        属性名1,属性名2,属性名2,....属性名n        )</code></pre><h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h3><pre><code>情况1:    使用枚举的属性    语法:枚举名.属性名情况2:    枚举作为形参    传递实参时必须传入枚举的属性</code></pre><h3 id="4-自定义枚举"><a href="#4-自定义枚举" class="headerlink" title="4.自定义枚举"></a>4.自定义枚举</h3><pre><code>1不需要提供set方法,枚举对象值通常为只读2.对枚举对象/属性使用final static共同修饰,实现底层优化3.枚举对象名通常全部大写,常量的命名规范4.枚举对象根据需要,也可以有多个属性]</code></pre><h4 id="5-特点"><a href="#5-特点" class="headerlink" title="5.特点"></a>5.特点</h4><pre><code>1.构造器私有化2.本类内创建一组对象 public static final 类型名3.对外暴露对象(通过为对象添加public static final修饰符)4.可以提供get方法,不提供set方法</code></pre><p><strong>注意事项</strong>：</p><ol><li>当我们使用enum关键字开发一个枚举时，默认会继承Enum类，而且是一个final类</li><li>传统的public final static  Season01 SPRING&#x3D;new Season01(“春天”,”温暖”);简化成 SPRING(“春天”,”温暖”);，这里必须知道它调用的那个构造器</li><li>如果使用无参构造器  创建枚举对象，则实参列表和小括号可以省略</li><li>当有多个枚举对象时，使用逗号间隔，最后用分号结尾</li><li>枚举对象必须放在枚举类的首行</li></ol><p><strong>常用方法：</strong></p><p><strong>说明；</strong>使用关键字enum时，会隐式继承enum，这样我们就可以使用Enum类相关的方法</p><pre><code class="java">public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt;            implements Comparable&lt;E&gt;, Serializable&#123;   &#125;</code></pre><ul><li>toString :Enum类已经重写过，返回当前对象名，子类可以重写该方法，用于返回对象的属性信息</li><li>name：返回当前对象名，子类中不能重写</li><li>ordinal：返回当前对象的位置号，默认从0开始</li><li>values：返回当前枚举类中所有常量</li><li>valueOf：将字符串装换成枚举对象，要求字符串必须为已有的常量名，否则报异常</li><li>compareTo：比较两个枚举常量，比较的就是位置号</li></ul><pre><code class="java">Week[] values = Week.values();    for (Week week:values) &#123;//增强for循环        System.out.println(week);    &#125;&#125;</code></pre><p><strong>细节：</strong></p><ul><li>使用enum关键字后，就不能继承其他类，因为enum会隐式继承Enum，而java是单继承机制</li><li>枚举和普通类一样，可以实现接口：enum  类名   implements  接口1，接口2{}</li></ul><h1 id="三十一-注解"><a href="#三十一-注解" class="headerlink" title="三十一.注解"></a>三十一.注解</h1><blockquote><p>作用</p><pre><code>解释代码的代码,称为注解,又名元代码</code></pre><p>注释与注解的区别</p><pre><code>注释:不会影响代码注解:对代码有一定的约束作用</code></pre><p>常见的注解</p><pre><code>@Override    作用:说明当前方法为重写的方法@SuppressWarnings(&quot;all&quot;)    作用:忽略警告    元注解    概念:解释注解的注解@Target  作用:注解使用位置  值:  TYPE:类,接口,枚举上使用        FIELD:属性上使用        METHOD:方法使用        PARAMETER:参数上使用        CONSTRUCTOR:构造函数        LOCAL_VARIABLE:局部变量使用        ANNOTATION_TYPE:注解使用        PACKAGE:包使用        注意:没有写可以在任何地方使用        @Retention  作用:注解作用时机  值:      SOURCE:java源程序中存在            CLASS:字节码文件中存在            RUNTIME:运行时存在            @Documented  作用:可以生成API文档  @Inherited  作用:说明当前注解是否可以被子类继承,默认不能被子类继承</code></pre><p>自定义注解</p><pre><code>语法:    访问权限修饰符 @interface 注解名&#123;        数据类型 属性名1() [default 默认值];        数据类型 属性名2() [default 默认值];        ...    &#125;</code></pre><p>注解的使用</p><pre><code>@注解名(属性名 = 属性值,属性名 = 属性值,...);注意:    1,当注解中的属性有默认值,可以在使用注解时不用赋值    2,当注解中所有属性都有默认值或没有属性时,可以省略小括号不写        @注解名    3,当注解中只有一个属性,并且该属性的属性名为value,此时在使用注解时可以省略属性名不写        @注解名(属性值)</code></pre></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JAVA基础&quot;&gt;&lt;a href=&quot;#JAVA基础&quot; class=&quot;headerlink&quot; title=&quot;JAVA基础&quot;&gt;&lt;/a&gt;JAVA基础&lt;/h1&gt;&lt;h2 id=&quot;一、准备阶段W&quot;&gt;&lt;a href=&quot;#一、准备阶段W&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="java" scheme="http://example.com/categories/java/"/>
    
    
    <category term="java基础知识" scheme="http://example.com/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>第一篇博客</title>
    <link href="http://example.com/2023/05/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2023/05/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</id>
    <published>2023-05-01T08:09:13.000Z</published>
    <updated>2023-05-03T06:10:09.455Z</updated>
    
    <content type="html"><![CDATA[<p>hexo new “”</p><p>hexo g </p><p>hexo d</p><p>hexo s</p><h1 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h1><ol><li>删除<code>.deploy_git</code>文件夹;</li><li>输入<code>git config --global core.autocrlf false</code></li><li>然后，依次执行：<br><code>hexo clean</code><br><code>hexo g</code><br><code>hexo d</code></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;hexo new “”&lt;/p&gt;
&lt;p&gt;hexo g &lt;/p&gt;
&lt;p&gt;hexo d&lt;/p&gt;
&lt;p&gt;hexo s&lt;/p&gt;
&lt;h1 id=&quot;解决办法：&quot;&gt;&lt;a href=&quot;#解决办法：&quot; class=&quot;headerlink&quot; title=&quot;解决办法：&quot;&gt;&lt;/a&gt;解决办法：&lt;/h1</summary>
      
    
    
    
    <category term="默认" scheme="http://example.com/categories/%E9%BB%98%E8%AE%A4/"/>
    
    
  </entry>
  
</feed>
