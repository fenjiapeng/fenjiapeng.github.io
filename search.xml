<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java基础练习--图书管理系统</title>
      <link href="/2023/05/03/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/05/03/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="图书管理系统"><a href="#图书管理系统" class="headerlink" title="图书管理系统;"></a>图书管理系统;</h2><h3 id="1-功能"><a href="#1-功能" class="headerlink" title="1.功能:"></a>1.功能:</h3><blockquote><p>添加图书</p><p>删除图书</p><p>查找图书</p><p>​根据书名查找</p><p>​根据借阅状态查找</p><p>​查找全部</p><p>​退出</p><p>更新图书</p><p>借书</p><p>还书</p></blockquote><h3 id="2-准备"><a href="#2-准备" class="headerlink" title="2.准备:"></a>2.准备:</h3><h4 id="读取"><a href="#读取" class="headerlink" title="读取:"></a>读取:</h4><p>从文件中读取图书信息,完成持久化存储</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">     <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;book.txt&quot;</span>);</span><br><span class="line">         <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line">         books = (ArrayList&lt;Book&gt;) objectInputStream.readObject();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         books = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Book&gt;();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>将图书信息写入文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;book.txt&quot;</span>);</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream);</span><br><span class="line">    <span class="comment">//这里是将集合对象写入文件</span></span><br><span class="line">    objectOutputStream.writeObject(books);</span><br><span class="line">    objectOutputStream.flush();</span><br><span class="line">    objectOutputStream.close();</span><br><span class="line">    fileOutputStream.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-实体类-图书类"><a href="#3-实体类-图书类" class="headerlink" title="3.实体类(图书类)"></a>3.实体类(图书类)</h3><p>包括:id ,书名,作者,价格,类型,状态</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LibraryMessageSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * date: 2023/5/3 15:11</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fjp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">//书名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//作者</span></span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line">    <span class="comment">//价格</span></span><br><span class="line">    <span class="keyword">private</span> String price;</span><br><span class="line">    <span class="comment">//书本的风格</span></span><br><span class="line">    <span class="keyword">private</span> String style;</span><br><span class="line">    <span class="comment">//是否借出</span></span><br><span class="line">    <span class="keyword">private</span> String status;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Book</span><span class="params">(String id, String name,String author, String price, String style, String status)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.style = style;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(String price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStyle</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> style;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStyle</span><span class="params">(String style)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.style = style;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(String status)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getAuthor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAuthor</span><span class="params">(String author)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>  id+<span class="string">&quot;\t\t &quot;</span>+ name+<span class="string">&quot;\t\t&quot;</span>+author+<span class="string">&quot;\t\t&quot;</span>+price+<span class="string">&quot;\t\t &quot;</span>+style+<span class="string">&quot;\t    &quot;</span>+status+<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-添加图书"><a href="#4-添加图书" class="headerlink" title="4.添加图书"></a>4.添加图书</h3><p>从键盘输入添加的图书信息,添加到集合中,图书编号随机生成</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inputBooks</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span>(<span class="type">int</span>) Math.floor( Math.random()*<span class="number">1000</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">newid</span> <span class="operator">=</span> Integer.toString(id);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入图书名:&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入作者名:&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">author</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入图书价格:&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">price</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入图书种类:&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">style</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入图书状态:&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">status</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Book</span>();</span><br><span class="line">    book.setId(newid);</span><br><span class="line">    book.setName(name);</span><br><span class="line">    book.setAuthor(author);</span><br><span class="line">    book.setPrice(price);</span><br><span class="line">    book.setStyle(style);</span><br><span class="line">    book.setStatus(status);</span><br><span class="line">    books.add(book);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将集合写入文件</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addBook</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    inputBooks();</span><br><span class="line">    write();</span><br><span class="line">    System.out.println(<span class="string">&quot;添加成功&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-删除图书"><a href="#5-删除图书" class="headerlink" title="5.删除图书"></a>5.删除图书</h3><p>根据书名进行删除图书</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteBook</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入要删除图书的书名:&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    <span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">        <span class="keyword">if</span> (book.getName().equals(next))&#123;</span><br><span class="line">            books.remove(book);</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                write();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;未找到图书&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-查找图书"><a href="#6-查找图书" class="headerlink" title="6.查找图书"></a>6.查找图书</h3><p>根据书名查找</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findName</span><span class="params">()</span>&#123;</span><br><span class="line">   <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入要查找的书名&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    <span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">        <span class="keyword">if</span> (book.getName().equals(name))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;编号       书名          作者       价格      类型       状态&quot;</span>);</span><br><span class="line">            System.out.println(book);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;未找到图书,请重新输入&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据借阅状态查找</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findStatus</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入要查找的图书类别&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">style</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    <span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">        <span class="keyword">if</span> (book.getStatus().equals(<span class="string">&quot;未借&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;编号       书名          作者       价格      类型       状态&quot;</span>);</span><br><span class="line">            System.out.println(book);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(book.getStatus().equals(<span class="string">&quot;已借&quot;</span>))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;编号       书名          作者       价格      类型       状态&quot;</span>);</span><br><span class="line">            System.out.println(book);</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;状态输入有误,您可以输入未借/已借&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查找全部图书信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findBook</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;编号       书名          作者       价格      类型       状态&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">        System.out.println(book);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-更新图书信息"><a href="#7-更新图书信息" class="headerlink" title="7.更新图书信息"></a>7.更新图书信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyBook</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;请输入要更新图书的编号或书名:&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    <span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">        <span class="keyword">if</span> (book.getName().equals(next)||book.getId().equals(next))&#123;</span><br><span class="line">            System.out.println(book);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入要修改的内容:&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;书名&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;作者:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">author</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;价格&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">price</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;类别:&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">style</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            System.out.println(<span class="string">&quot;状态&quot;</span>);</span><br><span class="line">            <span class="type">String</span> <span class="variable">status</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">            book.setName(name);</span><br><span class="line">            book.setPrice(price);</span><br><span class="line">            book.setAuthor(author);</span><br><span class="line">            book.setStyle(style);</span><br><span class="line">            book.setStatus(status);</span><br><span class="line">            System.out.println(<span class="string">&quot;修改成功&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                write();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入正确的书名或编号&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-借书"><a href="#8-借书" class="headerlink" title="8.借书"></a>8.借书</h3><p>首先遍历看图书是否存在,存在接着判断图书状态,未借可借,更改图书状态,已借,不能借阅</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">borrow</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;输入要借阅的书名:&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    <span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">        <span class="keyword">if</span> (book.getName().equals(name)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (book.getStatus().equals(<span class="string">&quot;未借&quot;</span>)) &#123;</span><br><span class="line">                book.setStatus(<span class="string">&quot;已借&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;借阅成功,请爱惜图书&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    write();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (book.getStatus().equals(<span class="string">&quot;已借&quot;</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;已借出,换本书吧&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;图书不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-还书"><a href="#9-还书" class="headerlink" title="9.还书"></a>9.还书</h3><p>输入归还的书名,更改图书状态</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">returnBook</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    System.out.println(<span class="string">&quot;输入要归还的书名:&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">    <span class="keyword">for</span> (Book book : books) &#123;</span><br><span class="line">        book.setStatus(<span class="string">&quot;未借&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;归还成功&quot;</span>);</span><br><span class="line">        write();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="10-环境类"><a href="#10-环境类" class="headerlink" title="10.环境类"></a>10.环境类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> LibraryMessageSystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * date: 2023/5/3 15:11</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fjp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LibraryMessageSystem</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">tag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">       <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">           System.out.println(<span class="string">&quot; -------------------------------------------------------------&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;|                           图书管理系统                       |&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot;| 1.增加图书  2.删除图书  3.查找图书  4.更新图书  5.借书  6.还书 |&quot;</span>);</span><br><span class="line">           System.out.println(<span class="string">&quot; -------------------------------------------------------------&quot;</span>);</span><br><span class="line">           <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">           System.out.println(<span class="string">&quot;请选择你需要的操作:&quot;</span>);</span><br><span class="line">           <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">           <span class="keyword">switch</span> (i)&#123;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                   BookUtil.addBook();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                   BookUtil.deleteBook();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                   tag=<span class="literal">true</span>;</span><br><span class="line">                   <span class="keyword">while</span>(tag) &#123;</span><br><span class="line">                       System.out.println(<span class="string">&quot;1.书名查找    2.状态查找    3.查找全部    4.返回上一级&quot;</span>);</span><br><span class="line">                       System.out.println(<span class="string">&quot;请选择查询方式:&quot;</span>);</span><br><span class="line">                       <span class="type">int</span> <span class="variable">nextInt</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                       <span class="keyword">if</span> (nextInt == <span class="number">1</span>) &#123;</span><br><span class="line">                           BookUtil.findName();</span><br><span class="line"></span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (nextInt == <span class="number">2</span>) &#123;</span><br><span class="line">                           BookUtil.findStatus();</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (nextInt == <span class="number">3</span>) &#123;</span><br><span class="line">                           BookUtil.findBook();</span><br><span class="line"></span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (nextInt == <span class="number">4</span>) &#123;</span><br><span class="line">                           tag = <span class="literal">false</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                   BookUtil.modifyBook();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                   BookUtil.borrow();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                   BookUtil.returnBook();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图书管理系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java基础练习--学生管理系统</title>
      <link href="/2023/05/03/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/05/03/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>java基础学习结束,写一个学生信息管理系统,包括增加学生信息,删除学生信息,查找学生信息,更改学生信息.</p><blockquote><p>增加学生信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从键盘录入学生的基本信息,存入txt文件,达到持久化存储</span><br></pre></td></tr></table></figure><p>删除学生信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">遍历集合中存储的信息,根据学生的学号删除学生xinx</span><br></pre></td></tr></table></figure><p>查找学生信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查找学生信息</span><br><span class="line">查找全部</span><br><span class="line">根据学号查找</span><br></pre></td></tr></table></figure><p>修改学生信息</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">根据学号进行更改</span><br></pre></td></tr></table></figure></blockquote><p>代码:</p><p>​学生类(Student)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> studentmassagesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * date: 2023/5/3 8:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fjp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 学号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 性别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 电话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 班级</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String grade;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 学院</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String collage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String id ,String name, String sex, String phone, String grade, String collage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">        <span class="built_in">this</span>.grade = grade;</span><br><span class="line">        <span class="built_in">this</span>.collage = collage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSex</span><span class="params">(String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPhone</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPhone</span><span class="params">(String phone)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getGrade</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGrade</span><span class="params">(String grade)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCollage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> collage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCollage</span><span class="params">(String collage)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.collage = collage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id +<span class="string">&quot;\t    &quot;</span>+name+<span class="string">&quot;\t&quot;</span>+sex+<span class="string">&quot;\t    &quot;</span>+phone+<span class="string">&quot;\t    &quot;</span>+grade+<span class="string">&quot;\t    &quot;</span>+collage+<span class="string">&quot;\t&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>工具类(实现具体的增删查改,创建输入输出流)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> studentmassagesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * date: 2023/5/3 9:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fjp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * 学生管理系统的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;Student&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个输入流读取文件中的学生信息,完成持久化存储</span></span><br><span class="line"><span class="comment">     * 添加学生信息,存储到文件中</span></span><br><span class="line"><span class="comment">     * 静态代码块只执行一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建一个文件字节输入流,将student.txt的内容读取到程序,进行操作</span></span><br><span class="line">            <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;student.txt&quot;</span>);</span><br><span class="line">            <span class="comment">//将创建的输入流,转为对象输入流,这里要对Student进行操作</span></span><br><span class="line">            <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(fileInputStream);</span><br><span class="line">                <span class="comment">//读取对象</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> objectInputStream.readObject();</span><br><span class="line">                <span class="comment">//将读取到的对象赋值给Arraylist,这里是将内存地址给了list</span></span><br><span class="line">                list = (ArrayList&lt;Student&gt;) object;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">//list指向新的引用</span></span><br><span class="line">            list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addMessage</span><span class="params">()</span> &#123;</span><br><span class="line">       keyBoard();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;添加成功!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据学号删除学生信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">deleteMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要删除的学生学号:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (student.getId().equals(id))&#123;</span><br><span class="line">                list.remove(student);</span><br><span class="line">                System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    writeFile();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;未找到学号为&quot;</span>+id+<span class="string">&quot;的学生&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查找所有学生信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学号\t&quot;</span>+<span class="string">&quot;姓名\t&quot;</span> +<span class="string">&quot;性别\t&quot;</span>+<span class="string">&quot;电话\t&quot;</span>+<span class="string">&quot;班级\t&quot;</span>+<span class="string">&quot;学院\t&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showIdMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要查找的学生学号:&quot;</span>);</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (student.getId().equals(id))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;学号\t&quot;</span>+<span class="string">&quot;姓名\t&quot;</span> +<span class="string">&quot;性别\t&quot;</span>+<span class="string">&quot;电话\t&quot;</span>+<span class="string">&quot;班级\t&quot;</span>+<span class="string">&quot;学院\t&quot;</span>);</span><br><span class="line">                System.out.println(student);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;未找到学号为&quot;</span>+id+<span class="string">&quot;的学生&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据学号修改学信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">modifyMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入要修改的学生学号:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (student.getId().equals(id))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;输入修改后的内容:&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;姓名:&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">newName</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                System.out.println(<span class="string">&quot;性别:&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">newSex</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                System.out.println(<span class="string">&quot;电话:&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">newPhone</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                System.out.println(<span class="string">&quot;班级:&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">newGrade</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                System.out.println(<span class="string">&quot;学院:&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">newCollage</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">                student.setName(newName);</span><br><span class="line">                student.setSex(newSex);</span><br><span class="line">                student.setPhone(newPhone);</span><br><span class="line">                student.setGrade(newGrade);</span><br><span class="line">                student.setCollage(newCollage);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    writeFile();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;修改成功&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;未找到学号为&quot;</span>+id+<span class="string">&quot;的学生&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 键盘输入的方法,从键盘录入学生信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">keyBoard</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生学号:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="comment">//判断是否存在</span></span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (student.getId().equals(id))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;该学生已存在,请重新输入&quot;</span>);</span><br><span class="line">                keyBoard();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学生姓名:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入性别:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入联系方式:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入班级:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">grade</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入学院:&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">collage</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student1.setId(id);</span><br><span class="line">        student1.setName(name);</span><br><span class="line">        student1.setSex(sex);</span><br><span class="line">        student1.setPhone(phone);</span><br><span class="line">        student1.setGrade(grade);</span><br><span class="line">        student1.setCollage(collage);</span><br><span class="line">        list.add(student1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将list写入文本文件中</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//创建文件输出流,对象输出流</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//将内容写入到txt文件</span></span><br><span class="line">        fileOutputStream = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;student.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//文件输出流转对象输出流</span></span><br><span class="line">        objectOutputStream = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(fileOutputStream);</span><br><span class="line">        <span class="comment">//将list写入文件</span></span><br><span class="line">        objectOutputStream.writeObject(list);</span><br><span class="line">        <span class="comment">//冲刷</span></span><br><span class="line">        objectOutputStream.flush();</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动类(Application)</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> studentmassagesystem;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.org.apache.bcel.internal.generic.BREAKPOINT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Description:</span></span><br><span class="line"><span class="comment"> * date: 2023/5/3 10:26</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fjp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;|                 xxxxxx学生管理系统                                |\n&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;| 1.增加学生    2.删除学生   3.查找学生信息   4.修改学生信息   5.退出 |\n&quot;</span>);</span><br><span class="line">            System.out.print(<span class="string">&quot;-------------------------------------------------------------------\n&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;请输入要执行的操作(eg:1/2/3/4/5):&quot;</span>);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="type">int</span> <span class="variable">tag</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">            <span class="keyword">switch</span> (tag)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    StudentUtil.addMessage();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    StudentUtil.deleteMessage();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">tag1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">while</span> (tag1)&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;1.查找全部学生信息   2.根据学号查找  3.返回上一级&quot;</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">                        <span class="keyword">if</span> (i==<span class="number">1</span>)&#123;</span><br><span class="line">                            StudentUtil.showMessage();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (i==<span class="number">2</span>)&#123;</span><br><span class="line">                            StudentUtil.showIdMessage();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (i==<span class="number">3</span>)&#123;</span><br><span class="line">                            tag1=<span class="literal">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                    StudentUtil.modifyMessage();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学生管理系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础</title>
      <link href="/2023/05/01/JAVA%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/05/01/JAVA%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><h2 id="一、准备阶段W"><a href="#一、准备阶段W" class="headerlink" title="一、准备阶段W"></a>一、准备阶段W</h2><h2 id="1-JAVA的执行流程"><a href="#1-JAVA的执行流程" class="headerlink" title="1.JAVA的执行流程"></a>1.JAVA的执行流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.Java文件（源文件）——&gt;javac编译——&gt;.class文件（字节码文件）——&gt;java运行——&gt;结果</span><br></pre></td></tr></table></figure><h2 id="2-开发细节"><a href="#2-开发细节" class="headerlink" title="2.开发细节"></a>2.开发细节</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.区分大小写</span><br><span class="line">2.Java方法是一条语句，以分号结束</span><br><span class="line">3.大括号成对出现</span><br><span class="line">4.一个Java文件中只能有一个public类。其它类个数不限。</span><br><span class="line">5.如果源文件包含一个public类，则文件名必须按照该类名命名。</span><br><span class="line">6.一个源文件中最多只能有一个public类，其他类个数不限，也可以将main方法写在非public类中，然后指定运行非public类，这样入口方法就是非public的main方法。</span><br></pre></td></tr></table></figure><h2 id="3-命名规则"><a href="#3-命名规则" class="headerlink" title="3..命名规则"></a>3..命名规则</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.有字母数字下划线组成</span><br><span class="line">2.数字不能开头</span><br><span class="line">3.不能使用关键字和保留字，但可以包含关键字和保留字</span><br><span class="line">4.Java中严格区分大小写，长度无限制</span><br><span class="line">5.标识符不能包含空格</span><br><span class="line">6.不能使用特殊符号,除$和_</span><br></pre></td></tr></table></figure><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.包名，多单词组成时所有字母都小写。如aaa.bbb.ccc</span><br><span class="line">2.类名，接口名,注解名,枚举名:多单词组成时，所有单词首字母都大写。如：TalkBankGame</span><br><span class="line">3.变量名，方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写。如aaaBbbCcc</span><br><span class="line">4.常量名：所有的字母都大写，多单词时每个单词用下划线连接。XXX_YYY_ZZZ</span><br></pre></td></tr></table></figure><h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><h2 id="1-整型"><a href="#1-整型" class="headerlink" title="1.整型"></a>1.整型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int 整型 4字节</span><br><span class="line">short 短整型 2字节</span><br><span class="line">long  长整型 8字节，对于long需要加上L或l后缀区分</span><br><span class="line">byte  1字节</span><br></pre></td></tr></table></figure><h2 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2.浮点型"></a>2.浮点型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.float：单精度浮点型  4字节，后缀加f</span><br><span class="line">2.double：双精度浮点型   8字节</span><br></pre></td></tr></table></figure><h2 id="3-字符型"><a href="#3-字符型" class="headerlink" title="3.字符型"></a>3.字符型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char 字符型  2字节，用单引号括起来，仅有一个字符</span><br><span class="line">注意：</span><br><span class="line">1)字符常量用单引号‘ ’</span><br><span class="line">2）java中允许使用转义符‘\’来将其后的字符转换为特殊字符常量    例如：char a=‘\n’;表示换行符</span><br><span class="line">3）在java中，char的本质是一个整数，在输出时，是Unicode码对应的字符</span><br><span class="line">4）可以直接给char附一个整数，然后输出时，会按照对应的Unicode字符输出</span><br><span class="line">5)char‘类型是可以进行运算的，相当于一个整数，因为都有对应的Unicode码</span><br></pre></td></tr></table></figure><h2 id="4-Boolean"><a href="#4-Boolean" class="headerlink" title="4.Boolean"></a>4.Boolean</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">布尔型，值为true和false</span><br></pre></td></tr></table></figure><h2 id="5-引用数据类型"><a href="#5-引用数据类型" class="headerlink" title="5.引用数据类型"></a>5.引用数据类型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">除过上述的四种基本数据类型，其余都是引用数据类型</span><br><span class="line">常用的String用于定义字符串</span><br></pre></td></tr></table></figure><h2 id="6-基本数据类型转换"><a href="#6-基本数据类型转换" class="headerlink" title="6.基本数据类型转换"></a>6.基本数据类型转换</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">精度小的自动转换为精度大的数据类型：自动类型转换</span><br><span class="line">数据类型按照精度大小排序为(规则)：char ——&gt;int ——&gt;long ——&gt;float ——&gt;double </span><br><span class="line"></span><br><span class="line">byte ——&gt;short ——&gt;int ——&gt;long ——&gt;float ——&gt;double</span><br><span class="line"></span><br><span class="line">基本数据类型转字符串：将基本类型的值+“ ”即可</span><br><span class="line"></span><br><span class="line">String转基本数据类型：通过基本类型的包装类调用parseXX方法即可</span><br></pre></td></tr></table></figure><h2 id="三、运算符"><a href="#三、运算符" class="headerlink" title="三、运算符"></a>三、运算符</h2><h2 id="1-算数运算符"><a href="#1-算数运算符" class="headerlink" title="1.算数运算符"></a>1.算数运算符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加 +</span><br><span class="line">减 —</span><br><span class="line">乘 *</span><br><span class="line">除 /</span><br><span class="line">取余 %</span><br><span class="line">自增 ++</span><br><span class="line">自减 --</span><br></pre></td></tr></table></figure><h2 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2.关系运算符"></a>2.关系运算符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">instanceof：检查是否是类的对象</span><br><span class="line">&gt; 大于</span><br><span class="line">&lt; 小于</span><br><span class="line">= 赋值</span><br><span class="line">== 全等于</span><br><span class="line">基本数据类型判断值是否相同</span><br><span class="line">引用数据类型判断内存地址是否相同</span><br><span class="line">&gt;= 大于等于</span><br><span class="line">&lt;= 小于等于</span><br><span class="line">!= 不等于</span><br><span class="line">基本数据类型判断值是否不相同</span><br><span class="line">引用数据类型判断内存地址是否不相同</span><br></pre></td></tr></table></figure><h2 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3.逻辑运算符"></a>3.逻辑运算符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">短路与&amp;&amp;</span><br><span class="line">全真为真，有假为假（第一个为假，后面条件不再判断）</span><br><span class="line">短路或||</span><br><span class="line">有真为真，全假为假，（判断第一个条件为真，不再判断结果为真）</span><br><span class="line">逻辑与&amp;</span><br><span class="line">全真为真（第一个条件为false，后面的条件任然判断）</span><br><span class="line">逻辑或|</span><br><span class="line">有真为真（第一个第二个条件都要判断）</span><br><span class="line">^逻辑异或</span><br><span class="line">相同为假，不同为真</span><br><span class="line">！非运算</span><br><span class="line">取反</span><br></pre></td></tr></table></figure><h2 id="4-三元运算符"><a href="#4-三元运算符" class="headerlink" title="4.三元运算符"></a>4.三元运算符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件表达式？表达式1:表达式2;</span><br><span class="line">如果条件表达式为true，运算表达式1，如果条件表达式为false，运算表达式2.</span><br><span class="line">注意:赋值给变量时,表达式1和表达式2的类型必须相同.</span><br></pre></td></tr></table></figure><h2 id="四、自动拆装箱"><a href="#四、自动拆装箱" class="headerlink" title="四、自动拆装箱"></a>四、自动拆装箱</h2><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">装箱:将基本数据类型转换成包装类型的过程</span><br><span class="line">拆箱:将包装类型装换成基本数据类型的过程</span><br></pre></td></tr></table></figure><h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自动装箱都是通过包装类的valueOf()方法来实现,自动拆箱通过包装类对象的xxxValue()来实现.</span><br></pre></td></tr></table></figure><h2 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h2><h3 id="场景一-、将基本数据类型放入集合类"><a href="#场景一-、将基本数据类型放入集合类" class="headerlink" title="场景一 、将基本数据类型放入集合类"></a>场景一 、将基本数据类型放入集合类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">li.add(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反编译:</span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">li.add(Integer.valueOf(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="场景二、包装类和基本类型的大小比较"><a href="#场景二、包装类和基本类型的大小比较" class="headerlink" title="场景二、包装类和基本类型的大小比较"></a>场景二、包装类和基本类型的大小比较</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a=<span class="number">1</span>;</span><br><span class="line">System.out.println(a==<span class="number">1</span>?<span class="string">&quot;等于&quot;</span>:<span class="string">&quot;不等于&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> bool=<span class="literal">false</span>;</span><br><span class="line">System.out.println(bool?<span class="string">&quot;真&quot;</span>:<span class="string">&quot;假&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反编译:</span><br><span class="line">Integer a=<span class="number">1</span>;</span><br><span class="line">System.out.println(a.IntValue==<span class="number">1</span>?<span class="string">&quot;等于&quot;</span>:<span class="string">&quot;不等于&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> bool=<span class="literal">false</span>;</span><br><span class="line">System.out.println(bool.booleanValue?<span class="string">&quot;真&quot;</span>:<span class="string">&quot;假&quot;</span>);</span><br></pre></td></tr></table></figure><p>包装类与基本数据类型进行比较运算,先将包装类拆箱成基本数据类型,然后比较.</p><h3 id="场景三、包装类型的运算"><a href="#场景三、包装类型的运算" class="headerlink" title="场景三、包装类型的运算"></a>场景三、包装类型的运算</h3><p>对Integer对象进行四则运算</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">System.out.println(i+j);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反编译:</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> Integer.valueOf(<span class="number">20</span>);</span><br><span class="line">    System.out.println(i.intValue() + j.intValue());</span><br></pre></td></tr></table></figure><p>两个包装类型之间的运算,会被自动拆箱成基本类型.</p><h3 id="场景四、三目运算符的使用"><a href="#场景四、三目运算符的使用" class="headerlink" title="场景四、三目运算符的使用"></a>场景四、三目运算符的使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean flag = true;</span><br><span class="line">Integer i = 0;</span><br><span class="line">int j = 1;</span><br><span class="line">int k = flag ? i : j;</span><br><span class="line"></span><br><span class="line">在使用三目运算符时,会发生自动拆箱</span><br><span class="line">1.表达式1和表达式2的值只要有一个时基本数据类型</span><br><span class="line">2.表达式1和表达式2的值类型不一致,会强制拆箱升级成表示范围更大的那个类型</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反编译    </span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> flag ? i.intValue() : j;</span><br><span class="line">    System.out.println(k);</span><br></pre></td></tr></table></figure><p>如果三目运算符的表达式在自动拆箱的过程中为null.会发生自动拆箱导致的空指针异常.</p><h3 id="场景五、函数参数与返回值"><a href="#场景五、函数参数与返回值" class="headerlink" title="场景五、函数参数与返回值"></a>场景五、函数参数与返回值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(Integer num)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getNum</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、语句的分类"><a href="#五、语句的分类" class="headerlink" title="五、语句的分类"></a>五、语句的分类</h2><p>顺序语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码自上而下执行</span><br></pre></td></tr></table></figure><p>分支语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在多个分支选择执行其中一个</span><br></pre></td></tr></table></figure><p>循环语句</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">重复执行一段代码</span><br></pre></td></tr></table></figure><h2 id="六、分支语句"><a href="#六、分支语句" class="headerlink" title="六、分支语句"></a>六、分支语句</h2><h3 id="1-if-判断语句"><a href="#1-if-判断语句" class="headerlink" title="1.if 判断语句"></a>1.if 判断语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基础的if结构</span><br><span class="line">语法:</span><br><span class="line">if(条件表达式)&#123;</span><br><span class="line">当条件表达式值为true时,执行此处代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if else结构</span><br><span class="line">语法:</span><br><span class="line">if(条件表达式)&#123;</span><br><span class="line">当条件表达式值为true时,执行此处代码</span><br><span class="line">&#125;else&#123;</span><br><span class="line">当条件表达式值为false时,执行此处代码</span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">1,else可有可无</span><br><span class="line">2,else只能有一个</span><br><span class="line">3,else不能单独存在</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">else if结构</span><br><span class="line">语法:</span><br><span class="line">if(条件表达式1)&#123;</span><br><span class="line">当条件表达式1为true,执行此处代码</span><br><span class="line">&#125;else if(条件表达式2)&#123;</span><br><span class="line">当条件表达式2为true,执行此处代码</span><br><span class="line">&#125;else if(条件表达式3)&#123;</span><br><span class="line">当条件表达式3为true,执行此处代码</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">else if(条件表达式n)&#123;</span><br><span class="line">当条件表达式n为true,执行此处代码</span><br><span class="line">&#125;else&#123;</span><br><span class="line">当以上条件全为false,执行此处代码</span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">else if可以有多个</span><br><span class="line">当上面的条件,将不会判断下面的条件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">if的语法:</span><br><span class="line">if(条件表达式1)&#123;</span><br><span class="line">当条件表达式1为true,执行此处代码</span><br><span class="line">&#125;else if(条件表达式2)&#123;</span><br><span class="line">当条件表达式2为true,执行此处代码</span><br><span class="line">&#125;else if(条件表达式3)&#123;</span><br><span class="line">当条件表达式3为true,执行此处代码</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">else if(条件表达式n)&#123;</span><br><span class="line">当条件表达式n为true,执行此处代码</span><br><span class="line">&#125;else&#123;</span><br><span class="line">当以上条件全为false,执行此处代码</span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">1,else if可以有多个</span><br><span class="line">2,else if可以一个都没有</span><br><span class="line">3,else if不能独立存在</span><br><span class="line">4,else 可有可无,最多只能有一个</span><br><span class="line">5,当多个条件同时满足时,只会执行最上面的那个</span><br></pre></td></tr></table></figure><h3 id="2-switch"><a href="#2-switch" class="headerlink" title="2.switch"></a>2.switch</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">switch(变量名)&#123;</span><br><span class="line">case 常量1:</span><br><span class="line">当变量值等于常量1时,执行此处代码</span><br><span class="line">int a;</span><br><span class="line">break;</span><br><span class="line">case 常量2:</span><br><span class="line">当变量值等于常量2时,执行此处代码</span><br><span class="line">break;</span><br><span class="line">...</span><br><span class="line">case 常量n:</span><br><span class="line">当变量值等于常量n时,执行此处代码</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">当变量值不等于以上常量时,执行的代码</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">常量:代码在编译后无法修改的值或变量称为常量</span><br><span class="line">break:跳出当前代码块,case中可以没有break,但是如果没有会导致贯穿</span><br><span class="line">swicth中case后的常量不能相同</span><br><span class="line">JDK1.5以后switch可以判断字符串内容是否相同</span><br><span class="line">switch只能判断值相等,if可以判断区间,也可以判断值是否相同</span><br></pre></td></tr></table></figure><p>变量的作用域</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念:变量声明的代码块,为这个变量的作用域(就是这个变量可以使用的范围)</span><br></pre></td></tr></table></figure><h3 id="3-输入：Scanner"><a href="#3-输入：Scanner" class="headerlink" title="3.输入：Scanner"></a>3.输入：Scanner</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简介:由JDK提供的一个类</span><br><span class="line">作用:键盘录入</span><br><span class="line">使用:</span><br><span class="line">1,导包</span><br><span class="line">语法:import java.util.Scanner;</span><br><span class="line">书写位置:类上</span><br><span class="line">2,创建Scanner对象</span><br><span class="line">语法:</span><br><span class="line">Scanner 变量名 = new Scanner(System.in);</span><br><span class="line">3,等待用户输入</span><br><span class="line">输入字符串</span><br><span class="line">String 变量名2 = 变量名.next();</span><br><span class="line">变量名2:就是用户输入的内容</span><br><span class="line">输入整数</span><br><span class="line">int 变量名2 = 变量名.nextInt();</span><br><span class="line">变量名2:就是用户输入的内容</span><br><span class="line">练习:</span><br><span class="line">键盘录入成绩判断其得分的区间</span><br></pre></td></tr></table></figure><h2 id="七、循环语句"><a href="#七、循环语句" class="headerlink" title="七、循环语句"></a>七、循环语句</h2><h3 id="1-while"><a href="#1-while" class="headerlink" title="1.while"></a>1.while</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">while(条件表达式)&#123;</span><br><span class="line">当条件表达式为true，执行此处代码i</span><br><span class="line">此处代码执行完毕后，判断条件表达式是否为true，为true，执行此处代码</span><br><span class="line">为false，结束循环</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-do-while"><a href="#2-do-while" class="headerlink" title="2.do-while"></a>2.do-while</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">do&#123;</span><br><span class="line">先执行此处代码,在判断条件表达式是否为true</span><br><span class="line">如果为true,在此执行此处代码</span><br><span class="line">如果为false结束循环</span><br><span class="line">&#125;while(条件表达式);</span><br></pre></td></tr></table></figure><h3 id="3-for"><a href="#3-for" class="headerlink" title="3.for"></a>3.for</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">for(表达式1;表达式2;表达式3)&#123;</span><br><span class="line">循环体4</span><br><span class="line">&#125;</span><br><span class="line">表达式1:初始化变量</span><br><span class="line">表达式2:循环条件</span><br><span class="line">表达式3:修改变量</span><br><span class="line">循环体4:重复执行的代码</span><br><span class="line">执行流程:</span><br><span class="line">1,2,4,3,2,4,3,2,4,3....2</span><br><span class="line">注意:表达式1只执行一次</span><br></pre></td></tr></table></figure><p>名词解释：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">死循环；无法结束的循环</span><br><span class="line">循环嵌套：在循环语句中使用循环语句</span><br></pre></td></tr></table></figure><h3 id="4-转义字符"><a href="#4-转义字符" class="headerlink" title="4.转义字符"></a>4.转义字符</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念:有特殊含义的字符</span><br><span class="line"></span><br><span class="line">\t:制表</span><br><span class="line">\&quot;:双引号字符</span><br><span class="line">\&#x27;:单引号字符</span><br><span class="line">\n:换行</span><br><span class="line">\r\n:标准换行</span><br></pre></td></tr></table></figure><h3 id="5-流程控制语句"><a href="#5-流程控制语句" class="headerlink" title="5.流程控制语句"></a>5.流程控制语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break:跳出当前循环</span><br><span class="line"></span><br><span class="line">continue:跳过本次循环</span><br></pre></td></tr></table></figure><h2 id="八、方法（函数）"><a href="#八、方法（函数）" class="headerlink" title="八、方法（函数）"></a>八、方法（函数）</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">封装一段代码，使其便于使用</span><br></pre></td></tr></table></figure><h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2.优点"></a>2.优点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提高代码复用率</span><br><span class="line">降低代码耦合度</span><br><span class="line">提高代码编写效率</span><br><span class="line">方便使用</span><br></pre></td></tr></table></figure><h3 id="3-步骤"><a href="#3-步骤" class="headerlink" title="3.步骤"></a>3.步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.定义</span><br><span class="line">2.调用</span><br></pre></td></tr></table></figure><h3 id="4-定义"><a href="#4-定义" class="headerlink" title="4.定义"></a>4.定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">位置：</span><br><span class="line">类中，方法外</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">语法:</span><br><span class="line">访问权限修饰符 修饰符 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">访问权限修饰符:暂时使用public</span><br><span class="line">修饰符:暂时使用static</span><br><span class="line">返回值类型:就是返回值的数据类型.如果没有返回值,返回值类型为void.null表示为空</span><br><span class="line">方法名:自定义,见名知意,小驼峰.一个类中不能出现方法名相同,形参列表也相同的方法</span><br><span class="line">形参列表:可有可无</span><br><span class="line">本质:声明的多个变量,使用逗号隔开</span><br><span class="line">方法体:</span><br><span class="line">return:结束当前方法</span><br><span class="line">return xxx:结束当前方法,并返回xxx.注意此时返回值类型要与xxx的数据类型一致.只能返回一个</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-调用"><a href="#5-调用" class="headerlink" title="5.调用"></a>5.调用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">1,方法名(实参列表);</span><br><span class="line">2,数据类型 变量名 = 方法名(实参列表);</span><br><span class="line">注意:</span><br><span class="line">1,实参列表要与形参列表一致(长度一致,顺序一致,数据类型一致)</span><br><span class="line">2,调用无返回值的方法只能使用语法1</span><br><span class="line">3,调用有返回值的方法可以选择使用语法1也可以选择使用语法2</span><br></pre></td></tr></table></figure><h3 id="6-多重调用"><a href="#6-多重调用" class="headerlink" title="6.多重调用"></a>6.多重调用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法调用方法</span><br><span class="line">A,B,C三个方法</span><br><span class="line">A中调用B,在B中调用C</span><br></pre></td></tr></table></figure><h3 id="7-重载"><a href="#7-重载" class="headerlink" title="7.重载"></a>7.重载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要求:</span><br><span class="line">1,同一个类中</span><br><span class="line">2,方法名相同</span><br><span class="line">3,形参列表不同</span><br></pre></td></tr></table></figure><h3 id="8-递归"><a href="#8-递归" class="headerlink" title="8.递归"></a>8.递归</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法本身调用本身</span><br></pre></td></tr></table></figure><h2 id="九、数组"><a href="#九、数组" class="headerlink" title="九、数组"></a>九、数组</h2><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1.作用"></a>1.作用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存储一组数据类型相同的数据</span><br></pre></td></tr></table></figure><h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.长度不可变</span><br><span class="line">2.存储的数据类型一致</span><br></pre></td></tr></table></figure><h3 id="3-步骤-1"><a href="#3-步骤-1" class="headerlink" title="3.步骤"></a>3.步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">声明/创建/使用</span><br></pre></td></tr></table></figure><h3 id="4-声明"><a href="#4-声明" class="headerlink" title="4.声明:"></a>4.声明:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">数据类型[] 数组名;</span><br><span class="line">数据类型 数组名[];</span><br></pre></td></tr></table></figure><h3 id="5-创建"><a href="#5-创建" class="headerlink" title="5.创建"></a>5.创建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">静态创建:</span><br><span class="line">语法:</span><br><span class="line">数据类型[] 数组名 = &#123;值1,值2,值3,值4,...值n&#125;;</span><br><span class="line">注意事项:</span><br><span class="line">1,必须在声明时创建</span><br><span class="line">2,其长度就是创建时值的个数</span><br><span class="line">动态创建:</span><br><span class="line">语法:</span><br><span class="line">带值</span><br><span class="line">数组名 = new 数据类型[]&#123;值1,值2,值3,...&#125;;</span><br><span class="line">注意:</span><br><span class="line">其长度就是创建时值的个数</span><br><span class="line">不带值</span><br><span class="line">数组名 = new 数据类型[长度];</span><br><span class="line"></span><br><span class="line">动态创建与静态创建的区别:</span><br><span class="line">1,静态创建必须在声明时创建,动态创建可以将声明与创建分开,也可以同时进行</span><br><span class="line">2,内存上来说</span><br><span class="line">静态创建的内存在常量区</span><br><span class="line">动态创建的内容在堆内存</span><br><span class="line">3,静态创建是在代码加载时分配的内存空间,动态创建是在代码运行时分配的空间</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">堆内存中的数据有默认值</span><br><span class="line">基本数据类型默认为0</span><br><span class="line">引用数据类型默认为null</span><br></pre></td></tr></table></figure><h3 id="6-使用"><a href="#6-使用" class="headerlink" title="6.使用"></a>6.使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本使用</span><br><span class="line">改</span><br><span class="line">修改指定位置的数据</span><br><span class="line">语法:</span><br><span class="line">数组名[下标] = 值;</span><br><span class="line">查</span><br><span class="line">查询数组长度</span><br><span class="line">语法:</span><br><span class="line">数组名.length</span><br><span class="line">查询数组指定位置的数据</span><br><span class="line">语法:</span><br><span class="line">数组名[下标]</span><br><span class="line">注意:</span><br><span class="line">下标要在取值范围内,否则会产生数组下标越界异常</span><br><span class="line"></span><br><span class="line">扩展</span><br><span class="line">遍历:将数组或集合中的数据逐个取出</span><br><span class="line">方式1:普通for循环</span><br><span class="line">方式2:foreach(只能做遍历)</span><br><span class="line">foreach语法:</span><br><span class="line">for(数据类型 变量名:要遍历的数组或集合)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">数据类型:遍历出的数据的数据类型</span><br><span class="line">变量名:就是遍历出的数据</span><br><span class="line">注意:foreach(增强for循环)在遍历时的速度是普通for的3倍</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复制:</span><br><span class="line">将数组A中的数据,逐个复制到数组中</span><br><span class="line">思路:</span><br><span class="line">1,创建新数组</span><br><span class="line">注意:</span><br><span class="line">1,新数组长度等于老数组长度</span><br><span class="line">2,新数组的数据类型与老数组一致</span><br><span class="line">2,遍历老数组</span><br><span class="line">使用普通for循环</span><br><span class="line">3,将老数组的值取出,赋值给新数组对应的位置</span><br><span class="line"></span><br><span class="line">扩容:</span><br><span class="line">将数组变大</span><br><span class="line">思路:</span><br><span class="line">1,创建一个新数组</span><br><span class="line">注意:</span><br><span class="line">1,新数组长度大于老数组长度</span><br><span class="line">2,新数组的数据类型与老数组一致</span><br><span class="line">2,遍历老数组</span><br><span class="line">3,将老数组的值取出,赋值给新数组对应的位置</span><br><span class="line">4,将新数组赋值给老数组</span><br></pre></td></tr></table></figure><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念:将数组作为数据存储在数组中</span><br><span class="line">步骤:</span><br><span class="line">1,声明</span><br><span class="line">2,创建</span><br><span class="line">3,使用</span><br><span class="line">声明</span><br><span class="line">数据类型[][] 数组名;</span><br><span class="line">创建</span><br><span class="line">静态创建</span><br><span class="line">注意:声明与创建同时进行</span><br><span class="line">语法:</span><br><span class="line">数据类型[][] 数组名 = &#123;</span><br><span class="line">&#123;值1,值2,值3,...&#125;,</span><br><span class="line">&#123;值4,值5,..&#125;,</span><br><span class="line">&#123;值6,值7,值8,值9,...&#125;,</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">动态创建</span><br><span class="line">带值</span><br><span class="line">语法:</span><br><span class="line">数组名 = new 数据类型[][]&#123;</span><br><span class="line">&#123;值1,值2,值3,...&#125;,</span><br><span class="line">&#123;值4,值5,..&#125;,</span><br><span class="line">&#123;值6,值7,值8,值9,...&#125;,</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line">不带值</span><br><span class="line">语法:</span><br><span class="line">数组名 = new 数据类型[x][y];</span><br><span class="line">x:二维数组中可容纳的一维数组的个数,必须在创建时说明</span><br><span class="line">y:一维数组中可容纳的元素的个数,可以不写</span><br><span class="line">注意:</span><br><span class="line">二维数组的长度指的是其中存储的一维数组的个数</span><br><span class="line"></span><br><span class="line">使用:</span><br><span class="line">改</span><br><span class="line">修改二维数组中指定的一维数组</span><br><span class="line">数组名[下标] = 新数组;</span><br><span class="line">注意:不能使用静态创建</span><br><span class="line">修改二维数组中指定的位置的元素</span><br><span class="line">数组名[x][y] = 新值;</span><br><span class="line">x:元素所在的一维数组在二维数组中的位置</span><br><span class="line">y:元素在一维数组中的位置</span><br><span class="line">查</span><br><span class="line">查询数组长度</span><br><span class="line">数组名.length</span><br><span class="line">查询二维数组中指定位置的一维数组</span><br><span class="line">数组名[下标];</span><br><span class="line">查询二维数组中指定位置的元素</span><br><span class="line">数组名[x][y]</span><br><span class="line">x:元素所在的一维数组在二维数组中的位置</span><br><span class="line">y:元素在一维数组中的位置</span><br><span class="line">遍历:</span><br><span class="line">思路:</span><br><span class="line">1,遍历二维数组,获取一维数组</span><br><span class="line">2,遍历一维数组</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:解决实参的长度必须与形参一致的问题</span><br><span class="line"></span><br><span class="line">语法:数据类型... 变量名</span><br><span class="line"></span><br><span class="line">使用位置:形参末尾使用</span><br><span class="line"></span><br><span class="line">注意:一个方法只能使用一个可变参数</span><br></pre></td></tr></table></figure><h1 id="十、面向对象"><a href="#十、面向对象" class="headerlink" title="十、面向对象"></a>十、面向对象</h1><h2 id="1-面向过程"><a href="#1-面向过程" class="headerlink" title="1.面向过程"></a>1.面向过程</h2><blockquote><p>面向过程(Procedure Oriented)是一种以过程为中心的编程思想，是一种自顶而下的编程模式。最典型的面向过程的编程语言就是C语言。</p><p>简单来说，面向过程的开发范式中，程序员需要把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。</p><p>就是说，在进行面向过程编程的时候，不需要考虑那么多，上来先定义一个函数，然后使用各种诸如if-else、for-each等方式进行代码执行。最典型的用法就是实现一个简单的算法，比如实现冒泡排序。</p><p>面向过程进行的软件开发，其代码都是流程化的，很明确的可以看出第一步做什么、第二步做什么。这种方式的代码执行起来效率很高。</p><p>但是，面向过程同时存在着代码重用性低，扩展能力差，后期维护难度比较大等问题。</p></blockquote><h2 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2.面向对象"></a>2.面向对象</h2><blockquote><p>面向对象（Object Oriented）的雏形，最早在出现在1960年的Simula语言中，当时的程序设计领域正面临着一种危机：在软硬件环境逐渐复杂的情况下，软件如何得到良好的维护？</p><p>面向对象程序设计在某种程度上通过强调可重复性解决了这一问题。目前较为流行的面向对象语言主要有Java、C#、C++、Python、Ruby、PHP等。</p><p>简单来说，面向对象的开发范式中，程序员将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。</p><p>就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。比如:想要造一辆车，上来要先把车的各种属性定义出来，然后抽象成一个Car类。</p><p>面向对象的编程方法之所以更加受欢迎，是因为他更加符合人类的思维方式。这种方式编写出来的代码扩展性、可维护性都很高。</p><p>与其实面向对象是一种开发范式，倒不如说面向对象是一种对现实世界的理解和抽象的方法。通过对现实世界的理解和抽象，在运用封装、继承、多态等方法，通过抽象出对象的方式进行软件开发。</p></blockquote><h2 id="3-对象"><a href="#3-对象" class="headerlink" title="3.对象"></a>3.对象</h2><blockquote><p>对象就是类的具体实例<br>概念：万事万物皆对象<br>生活中：客观存在的事物皆为对象<br>代码中：在代码中存在的事物</p></blockquote><h2 id="4-类"><a href="#4-类" class="headerlink" title="4.类"></a>4.类</h2><blockquote><p>概念：多个对象抽象其共同点形成的概念</p><p>代码中：创建对象的模板</p></blockquote><h2 id="5-类和对象的关系"><a href="#5-类和对象的关系" class="headerlink" title="5.类和对象的关系"></a>5.类和对象的关系</h2><blockquote><p>类是抽象的，概念的，代表一类事物</p><p>对象时具体的，实际的，代表一个具体事物</p><p>类是对象的模板，对象是类的一个个体，对应一个实例</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">生活中:先有对象,后有类</span><br><span class="line">代码中:先有类,后有对象</span><br><span class="line">一个类可以有多个对象.多个对象可以属于同一个类</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-类的定义与组成"><a href="#6-类的定义与组成" class="headerlink" title="6.类的定义与组成"></a>6.类的定义与组成</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1).定义"></a>1).定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">访问权限修饰符 class 类名&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">访问权限修饰符:</span><br><span class="line">暂时使用public或不写</span><br><span class="line">类名:</span><br><span class="line">1,同一个文件夹下类名不能相同</span><br><span class="line">2,大驼峰</span><br></pre></td></tr></table></figure><h3 id="2-组成"><a href="#2-组成" class="headerlink" title="2).组成"></a>2).组成</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.属性（全局变量，成员变量）</span><br><span class="line">作用：描述事物的静态特征</span><br><span class="line">位置：方法外，类内</span><br><span class="line">格式：权限修饰符 数据类型 属性名；</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法：</span><br><span class="line">作用：描述事物的行为（静态特征）</span><br><span class="line">位置：类中，方法外</span><br><span class="line">格式：</span><br><span class="line">权限修饰符  返回值类型  方法名（新参列表）&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">本质：特殊的方法</span><br><span class="line">作用：创建该类的对象</span><br><span class="line">定义位置：类中。方法外</span><br><span class="line">语法：</span><br><span class="line">访问权限修饰符  构造函数名（形参列表）&#123;</span><br><span class="line">            方法体</span><br><span class="line">&#125;  </span><br><span class="line">注意：</span><br><span class="line">1.构造函数没有返回值类型</span><br><span class="line">2.构造函数没有返回值</span><br><span class="line">3.构造函数名和类名一致</span><br><span class="line">4.使用new关键字调用</span><br><span class="line">5.如果一个类中有多个构造函数，那么这些构造函数为重载关系</span><br><span class="line">6.一个类一定会有一个构造函数，如果没有定义构造函数，系统将会提供无参构造器</span><br><span class="line">7.构造函数不能形成递归</span><br></pre></td></tr></table></figure><h4 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">成员变量：</span><br><span class="line">声明在类中，方法外</span><br><span class="line">有默认值，基本数据类型默认为0，引用数据类型默认为null</span><br><span class="line">作用域：当前类中</span><br><span class="line">生命周期：随着对象的创建而创建，随着所属对象的销毁而销毁</span><br><span class="line">局部变量：</span><br><span class="line">方法中</span><br><span class="line">没有默认值</span><br><span class="line">作用域:当前代码块中</span><br><span class="line">生命周期:随着方法调用而生成随着方法执行完毕而销毁</span><br></pre></td></tr></table></figure><h2 id="7-对象的创建与使用"><a href="#7-对象的创建与使用" class="headerlink" title="7.对象的创建与使用"></a>7.对象的创建与使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建</span><br><span class="line">语法：</span><br><span class="line">数据类型 对象名 = new 构造函数（实参列表）；</span><br><span class="line">构造函数：即为该对象所属的类名</span><br></pre></td></tr></table></figure><p>面试题：</p><blockquote><p>Cat cat &#x3D; new Cat();</p><p>1.使用new关键字在堆内存中开辟一片空间</p><p>2.给属性赋初值</p><p>3.执行构造函数中的代码</p><p>4.将堆地址赋值给栈中的引用</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用：</span><br><span class="line">获取属性值：</span><br><span class="line">对象名.属性名</span><br><span class="line">修改属性值</span><br><span class="line">    对象名.属性名 = 值；</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用：</span><br><span class="line">对象名.方法名（实参列表）</span><br></pre></td></tr></table></figure><h2 id="8-this"><a href="#8-this" class="headerlink" title="8.this"></a>8.this</h2><blockquote><p>含义：谁调用this所在的方法this就表示谁</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">场景一：局部变量与成员变量名称相同时，使用this区分</span><br><span class="line">成员变量(属性)</span><br><span class="line">this.属性名</span><br><span class="line">局部变量</span><br><span class="line">变量名</span><br><span class="line"></span><br><span class="line">就近使用原则</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">场景二：在本类方法中使用本类的属性或方法，默认用this调用。此时this可以忽略</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">场景三：本类构造函数中，调用本类其他构造函数</span><br><span class="line">语法:</span><br><span class="line">this(实参列表);</span><br><span class="line">注意:</span><br><span class="line">必须在构造函数第一行使用</span><br></pre></td></tr></table></figure><h1 id="十一-三大特征"><a href="#十一-三大特征" class="headerlink" title="十一.三大特征"></a>十一.三大特征</h1><h2 id="1-访问权限修饰符"><a href="#1-访问权限修饰符" class="headerlink" title="1.访问权限修饰符"></a>1.访问权限修饰符</h2><blockquote><p>作用:限制其修饰的内容使用范围</p><p>关键字:</p><p>public    公共的    当前项目可访问</p><p>protected    受保护的   当前包下或继承关系下可用</p><p>默认的   当前包下</p><p>private  私有的     当前类中可用</p></blockquote><h2 id="2-封装"><a href="#2-封装" class="headerlink" title="2.封装"></a>2.封装</h2><p>​<strong>定义</strong>:包装;封装就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，</p><p><strong>优点:</strong></p><pre><code>&gt;1.方便使用&gt;&gt;2.保护内部&gt;&gt;3.降低耦合度&gt;&gt;4.提高复用率</code></pre><p><strong>体现</strong></p><blockquote><p>变量:封装值或内存地址</p><p>方法:封装一段代码</p><p>类:封装多个属性,方法与构造函数</p><p>java中封装无处不在</p></blockquote><p><strong>包:</strong></p><blockquote><p>**本质:**src下的文件夹</p><p>**作用:**对java文件进行分类存储,使其便于寻找</p><p><strong>创建</strong>:  选择src—鼠标右键—new —package—填写包名</p><p><strong>包名:</strong>   规则:全小写</p><p>​潜规则:com.公司名或项目名.分类名</p><p><strong>注意:</strong></p><p>​.下一级文件夹</p><p>关键字:package,说明当前java文件所在的包</p></blockquote><p><strong>导包</strong></p><blockquote><p>作用:在当前java文件中使用其他文件夹下的类,此时需要导包<br>语法:<br>import 包名.类名;</p><p>位置:类上</p><p>关键字:import</p><p>*:所有</p></blockquote><p><strong>步骤</strong></p><blockquote><p>1.属性私有化</p><p>2.提供公共的set方法,用于对属性的判断并赋值</p><p>3.提供一个公共的get方法,用于获取属性值</p></blockquote><h2 id="3-继承"><a href="#3-继承" class="headerlink" title="3.继承"></a>3.继承</h2><p><strong>概念</strong></p><blockquote><p>生活中:晚辈继承长辈遗留下的精神或物质遗产</p><p>代码中:多个类抽取其共同点形成的类,此时该类与这几个类形成继承关系</p></blockquote><p><strong>优点</strong></p><blockquote><p>子类将拥有父类的所有属性和方法,构造函数除外</p><p>提高代码复用率</p></blockquote><p><strong>语法</strong></p><blockquote><p>访问权限修饰符   class  子类名  extends 父类名{</p><p>​属性</p><p>​方法</p><p>​构造函数</p><p>}</p><p>注意:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1.一个父类可以有多个子类</span><br><span class="line">&gt;2.一个子类只能有一个父类,单继承</span><br><span class="line">&gt;3.子类构造函数中默认调用父类无参构造函数</span><br><span class="line">&gt;4.子类构造函数中必须调用父类的构造函数,默认先调用父类的构造函数</span><br><span class="line">&gt;5.Object是所有类的父类,如果一个没有明确的父类,默认继承Object</span><br><span class="line">&gt;6.开闭原则:</span><br><span class="line">对修改关闭</span><br><span class="line">对扩展打开</span><br></pre></td></tr></table></figure></blockquote><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a><strong>重写</strong></h4><blockquote><p>在继承关系中,子类中的方法与父类的方法,方法名相同,形参列表相同.</p><p>子类的方法访问权限修饰符不能小于父类的子类</p><p>该方法返回值类型与父类一致.</p></blockquote><h4 id="super"><a href="#super" class="headerlink" title="super"></a><strong>super</strong></h4><p>​含义:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">谁调用super所在的方法,super就表示谁的父类对象</span><br><span class="line">代表父类的引用，用于访问父类的属性，方法，构造器</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">1.访问父类的属性,但不能访问父类的private属性,super.属性名,在子类方法中访问</span><br><span class="line">2.访问父类的方法,但不能访问父类的private方法,super.方法名(参数列表),在子类方法中访问</span><br><span class="line">3.访问父类的构造器,super(参数列表)只能放在子类构造器的第一句</span><br></pre></td></tr></table></figure><p><strong>使用场景:</strong></p><blockquote><p><strong>场景1</strong>:当子类重写了父类的方法后,在子类中使用super区分,在子类重写的方法还是父类的方法</p><p>​super.方法名(实参列表)     ——-父类提供</p><p>​方法名(实参列表) ——–子类重写的方法</p></blockquote><blockquote><p><strong>场景2</strong>:当子类属性名与父类属性名重名时,使用super区分</p><p>​super.属性名      父类属性</p><p>​属性名               子类属性</p></blockquote><blockquote><p>**场景3:**调用构造函数</p><p>​super(实参列表);—–只能在子类构造器第一行调用</p></blockquote><p><strong>细节:</strong></p><blockquote><ol><li><p>调用父类构造器的好处，（分工明确，父类属性由父类初始化，子类属性由子类初始化）</p></li><li><p>当子类中又有和 父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super，如果没有重名，使用super，this，直接访问效果一样</p></li></ol><p> super.方法名：直接查找父类，跳过本类查找</p><ol start="3"><li>super的访问不限于直接父类，如果爷爷类和本类中有同名成员，也可以使用super去访问爷爷类的成员，如果多个基类中有同名的成员，使用super遵循就近原则，也需要遵守权限规则。</li></ol></blockquote><p><strong>this与super</strong></p><blockquote><p>this:调用该方法的对象</p><p>super:调用该方法的父类对象</p></blockquote><h2 id="4-多态"><a href="#4-多态" class="headerlink" title="4.多态"></a>4.多态</h2><p><strong>概念:</strong>  </p><blockquote><p>一个事物的多种形态(方法或对象具有多种形态，多态建立在封装和继承的基础之上)</p></blockquote><h4 id="对象的多态"><a href="#对象的多态" class="headerlink" title="对象的多态"></a><strong>对象的多态</strong></h4><blockquote><p>子类对象转换为父类对象</p><p>​自动转换</p><p>​语法:               父类名    对象名  &#x3D;  子类对象;</p><p>父类对象转换为子类对象</p><p>​强制转换</p><p>​语法:         子类名    对象名   &#x3D;   (子类名)父类对象;</p><p>​注意:有风险</p></blockquote><h4 id="方法的多态"><a href="#方法的多态" class="headerlink" title="方法的多态:"></a><strong>方法的多态:</strong></h4><blockquote><p>重载:在同一个类中,方法名相同,形参列表不同</p><p>重写:在继承关系中,子类方法与父类方法,方法名相同,形参列表相同,返回值类型相同,访问权限修饰符不能减小</p><p>注意:当子类对象转换为父类对象后,调查重写的方法,依据执行的是子类重写后的方法.</p></blockquote><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><strong>instanceof</strong></h4><blockquote><p>作用:判断该对象是否属于该类</p><p>注意:判断的对象与类之间要存在关系</p><p>语法:</p><p>​boolean   变量名  &#x3D;  对象名  instanceof   类名;</p><p>如果为true,表示该对象属于该类</p><p>如果为false,表示该对象不属于该类</p></blockquote><h1 id="十二-、三大修饰符"><a href="#十二-、三大修饰符" class="headerlink" title="十二 、三大修饰符"></a>十二 、三大修饰符</h1><h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><blockquote><p>含义:抽象的,不可描述的</p><p>可以修饰类和方法</p><h4 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类:"></a><strong>修饰类:</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点:不能直接创建对象</span><br><span class="line">语法:</span><br><span class="line">访问权限修饰符  abstract class 类名&#123;</span><br><span class="line">属性</span><br><span class="line">方法</span><br><span class="line">构造函数</span><br><span class="line">&#125;</span><br><span class="line">名称:抽象类</span><br><span class="line">注意:</span><br><span class="line">1.抽象类中不一定有抽象方法</span><br><span class="line">2.子类继承抽象类,要么重写父类所有抽象方法,要么自己也是抽象类</span><br><span class="line">3.抽象类不能被实例化</span><br><span class="line">4.一旦包含抽象方法,则这个类必须声明为抽象类</span><br><span class="line">5.抽象类可以有任意成员,如非抽象方法,构造器,静态属性</span><br></pre></td></tr></table></figure><h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点:没有方法体</span><br><span class="line">语法:</span><br><span class="line">访问权限修饰符  abstract 返回值类型 方法名(形参列表);</span><br><span class="line">注意:</span><br><span class="line">1.有抽象方法的类一定是抽象类</span><br><span class="line">2.抽象类中可以有多个抽象方法</span><br><span class="line">3.抽象方法不能有主体,即不能实现</span><br><span class="line">4.抽象方法不能使用private，final，static来修饰，因为这些关键字都是和重写相违背的，final是不能继承的，static关键字和方法重写无关，private不能重写</span><br></pre></td></tr></table></figure></blockquote><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><blockquote><p>含义:最终的,不可修改的</p><p>可以修饰:变量,方法,类</p><h4 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a><strong>修饰变量</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰局部变量</span><br><span class="line">语法:</span><br><span class="line">final 数据类型 变量名 = 值;</span><br><span class="line">注意:只能赋值一次</span><br><span class="line"> final修饰的变量就是常量</span><br><span class="line">修饰成员变量</span><br><span class="line">语法:</span><br><span class="line">访问权限修饰符 final 数据类型 属性名 = 值;</span><br><span class="line">注意:</span><br><span class="line">1.final 修饰的属性必须是声明赋值时</span><br><span class="line">2.final 修饰的属性值不能被修改</span><br></pre></td></tr></table></figure><h4 id="修饰方法-1"><a href="#修饰方法-1" class="headerlink" title="修饰方法"></a>修饰方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:不能被重写</span><br><span class="line">语法:</span><br><span class="line">访问修饰符 final 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="修饰类-1"><a href="#修饰类-1" class="headerlink" title="修饰类"></a>修饰类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:不能被继承,这种类被称为最终类</span><br><span class="line">语法: </span><br><span class="line">访问权限修饰符 final class 类名&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.不希望类被继承时,使用final修饰</span><br><span class="line">2.不希望父类的某个方法被子类覆盖/重写时可以使用final关键字</span><br><span class="line">3.当不希望类的某个属性的值被修改,就可以使用final修饰</span><br><span class="line">4.当不希望某个局部变量被修改,可以使用final修饰</span><br></pre></td></tr></table></figure><h4 id="细节"><a href="#细节" class="headerlink" title="细节:"></a>细节:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.final修饰的属性在定义时,必须赋初值,并且以后不能改变</span><br><span class="line">2.如果final修饰的属性是静态的,则初始化的位置只能是:在定义时,在静态代码块,不能在构造器中赋值</span><br><span class="line">3.final类不能继承,但可以实例化</span><br><span class="line">4.如果类不是final类,但是含有fianal方法,则该方法不能被重写,但可以被继承</span><br><span class="line">5.一般来说,一个类已经是final类了.则没必要讲方法修饰成final方法</span><br><span class="line">6.final不能修饰构造方法</span><br><span class="line">7.final 往往与static搭配使用,效率更高,底层编译做了优化处理,静态属性增加final后,调用静态属性,静态方法不再被调用.</span><br><span class="line">8.包装类,String也是final类</span><br></pre></td></tr></table></figure></blockquote><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><blockquote><p>含义:静态的,公共的</p><p>可以修饰:属性,方法,代码块,内部类</p><h4 id="修饰属性"><a href="#修饰属性" class="headerlink" title="修饰属性"></a>修饰属性</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点:该属性属于该类的所有对象,该类的一个对象对其进行修改,该类的所有对象的属性都会被修改</span><br><span class="line"></span><br><span class="line">可以使用类名直接调用.</span><br><span class="line">语法:</span><br><span class="line">访问权限修饰符  static 数据类型 属性名;</span><br></pre></td></tr></table></figure><h4 id="修饰方法-2"><a href="#修饰方法-2" class="headerlink" title="修饰方法"></a>修饰方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点:可以使用类名直接调用,也可以使用对象名调用</span><br><span class="line">语法:</span><br><span class="line">访问权限修饰符  static 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">1.不能使用this或super关键字</span><br><span class="line">2.不能直接使用本类中其他非静态属性或非静态方法</span><br><span class="line">3.可以直接使用本类的静态属性或静态方法</span><br><span class="line">4.非静态方法中可以直接使用静态属性或静态方法</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点:在类加载时被执行</span><br><span class="line">注意:一个类在程序运行时,只会被加载一次</span><br><span class="line">语法:</span><br><span class="line">static&#123;</span><br><span class="line">代码块</span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">1.静态代码快中可以使用静态属性与静态方法,不能直接使用非静态属性和非静态方法</span><br><span class="line">2.静态代码快与静态属性,谁在前,谁先执行,为了可以再静态代码快中使用静态属性,必须将静态属性声明在静态代码块之前</span><br><span class="line"></span><br><span class="line">类加载时机:该类第一次被执行使用时</span><br><span class="line">1.第一次创建该类对象时</span><br><span class="line">2.第一次使用该类调用属性时</span><br><span class="line">3.第一次使用该类调用方法时</span><br><span class="line">4.第一次使用反射机制加载该类时</span><br></pre></td></tr></table></figure><h4 id="继承关系中的执行流程"><a href="#继承关系中的执行流程" class="headerlink" title="继承关系中的执行流程"></a>继承关系中的执行流程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 父类的静态代码块和静态属性</span><br><span class="line">- 子类的静态代码快和静态属性</span><br><span class="line">- 父类的普通代码块和普通属性初始化</span><br><span class="line">- 父类的构造方法</span><br><span class="line">- 子类的普通代码块和普通属性初始化</span><br><span class="line">- 子类的构造方法</span><br></pre></td></tr></table></figure><h4 id="创建对象时-在一个类调用的顺序是"><a href="#创建对象时-在一个类调用的顺序是" class="headerlink" title="创建对象时,在一个类调用的顺序是:"></a>创建对象时,在一个类调用的顺序是:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）调用静态代码块和静态属性初始化（静态代码块和静态属性初始化的调用优先级一样，如果有多个静态代码块和多个静态变量初始化，则按照他们的顺序调用）</span><br><span class="line"></span><br><span class="line">2）调用普通代码块和普通属性的初始化（普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）</span><br><span class="line"></span><br><span class="line">3）调用构造方法</span><br></pre></td></tr></table></figure></blockquote><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><blockquote><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用:封装一段代码</p><p>使用位置:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类中方法外.每次创建该类对象时被调用</span><br><span class="line">注意:在构造函数之前执行</span><br><span class="line">普通属性与代码块按顺序执行</span><br></pre></td></tr></table></figure></blockquote><h1 id="十三-接口"><a href="#十三-接口" class="headerlink" title="十三.接口"></a>十三.接口</h1><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体的情况把这些方法写出来</p><h2 id="含义"><a href="#含义" class="headerlink" title="含义:"></a>含义:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">宏观:规则</span><br><span class="line">微观:功能</span><br></pre></td></tr></table></figure><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1.定义</span><br><span class="line">&gt;2.使用</span><br></pre></td></tr></table></figure></blockquote><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;语法:</span><br><span class="line">访问权限修饰符  interface 接口名&#123;</span><br><span class="line">方法体;</span><br><span class="line">&#125;</span><br><span class="line">&gt;组成:</span><br><span class="line">公共静态常量</span><br><span class="line">公共静态方法</span><br><span class="line">公共抽象方法</span><br><span class="line">default修饰的普通方法</span><br><span class="line">&gt;注意:公共静态方法和常量默认有public static final</span><br><span class="line">公共抽象方法包含:public abstract</span><br></pre></td></tr></table></figure></blockquote><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1.接口使用接口</span><br><span class="line">通过多继承实现接口使用接口</span><br><span class="line">语法:</span><br><span class="line">public interface 子接口名 extends  父接口名1,父接口名2....&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">注意:不能继承父接口的静态方法,其他的均可继承</span><br><span class="line"></span><br><span class="line">&gt;2.类使用接口</span><br><span class="line">&gt;多实现:一个类可以实现多个接口</span><br><span class="line">&gt;语法:</span><br><span class="line">访问权限修饰符 class 子类名 extends 父类名 implements 父接口名1,父接口名2...&#123;&#125;</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">1.一个类可以实现多个接口</span><br><span class="line">2.子类要么重写所有接口提供的抽象方法,要么子类也是抽象类</span><br><span class="line">3.子类对象可以转换为多个实现的接口对象</span><br><span class="line">4.一个接口可以被多个类实现,所以多个类的对象可以转换为同一个接口的对象</span><br></pre></td></tr></table></figure></blockquote><h2 id="接口的特殊使用"><a href="#接口的特殊使用" class="headerlink" title="接口的特殊使用"></a>接口的特殊使用</h2><blockquote><p><strong>常量接口</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念:只有常量的接口</span><br><span class="line">public interface 接口名&#123;</span><br><span class="line">数据类型 常量名1 = 值;</span><br><span class="line">数据类型 常量名2 = 值;</span><br><span class="line">数据类型 常量名3 = 值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口回调</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念:接口对象回来调用接口方法</span><br><span class="line"></span><br><span class="line">实例:点击按钮</span><br><span class="line">按钮类</span><br><span class="line">点击事件接口</span><br><span class="line">环境类</span><br><span class="line">创建点击事件接口对象</span><br><span class="line">创建按钮对象,传入接口对象</span><br><span class="line">按钮对象,点击方法</span><br></pre></td></tr></table></figure></blockquote><h2 id="细节-1"><a href="#细节-1" class="headerlink" title="细节:"></a>细节:</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1.接口使用implements实现</span><br><span class="line">&gt;2.接口不能继承其他类,但可以继承其他接口(多继承)</span><br><span class="line">&gt;3.接口不能实例化</span><br><span class="line">&gt;4.接口的所有方法是public方法,接口中的抽象方法可以不用abstract修饰</span><br><span class="line">&gt;5.一个普通类实现接口,必须将该接口的方法都实现,或将自己定义为抽象类</span><br><span class="line">&gt;6.一个类可以同时实现多个接口</span><br><span class="line">&gt;7.接口中的属性,只能是final的,而且是public static final修饰符</span><br><span class="line">&gt;8.接口中属性的访问形式:接口名.属性名</span><br><span class="line">&gt;9接口的修饰符只能是public和默认的</span><br></pre></td></tr></table></figure></blockquote><h2 id="接口的多态"><a href="#接口的多态" class="headerlink" title="接口的多态"></a>接口的多态</h2><blockquote><p>接口存在多态传递,如果接口1继承了接口2,为类1实现了接口1,就相当于类1实现了接口2</p></blockquote><h1 id="十四-内部类"><a href="#十四-内部类" class="headerlink" title="十四.内部类"></a>十四.内部类</h1><p>作用:补全外部类功能</p><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><blockquote><p>在类中定义的类称为内部类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class A&#123;</span><br><span class="line">public class B&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">A为外部类</span><br><span class="line">B为内部类</span><br></pre></td></tr></table></figure></blockquote><h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.成员内部类</span><br><span class="line">位置:类中.方法外</span><br><span class="line">未使用static修饰</span><br><span class="line">2.静态内部类</span><br><span class="line">定义位置:类中.方法外</span><br><span class="line">使用static修饰</span><br><span class="line">3.局部内部类</span><br><span class="line">定义位置:类中,方法中</span><br><span class="line">4.匿名内部类</span><br><span class="line">定义位置:定义在外部类的成员位置上,或实参中</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-成员内部类"><a href="#3-成员内部类" class="headerlink" title="3.成员内部类"></a>3.成员内部类</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;可以加访问任何的访问权限修饰符,因为他也是成员</span><br><span class="line"></span><br><span class="line">&gt;成员内部类内部可定义:除去静态成员以外的成员都可以定义</span><br><span class="line">&gt;创建对象:</span><br><span class="line">情况1:在所在的外部类中创建该内部类对象</span><br><span class="line">内部类类名 对象名 = new 内部类类名(实参列表);</span><br><span class="line">注意:只是省略this关键字,所以这种创建方式不能再静态方法中使用.</span><br><span class="line">情况2:在其他类中创建该内部类对象</span><br><span class="line">外部类类名.内部类类名 对象名 = 外部类对象.new 内部类名(实参列表);</span><br></pre></td></tr></table></figure></blockquote><h3 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4.静态内部类"></a>4.静态内部类</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;使用static修饰</span><br><span class="line">&gt;静态内部类所有的成员都可以定义</span><br><span class="line">&gt;创建对象:</span><br><span class="line">外部类类名.内部类类名 对象名 = new 外部类类名.内部类类名(实参列表);</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-局部内部类"><a href="#5-局部内部类" class="headerlink" title="5.局部内部类"></a>5.局部内部类</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;注意:</span><br><span class="line">此时不能使用访问权限修饰符</span><br><span class="line">只能在当前方法中使用</span><br><span class="line">&gt;可以定义什么:</span><br><span class="line">除去静态成员,其他成员都可以</span><br><span class="line">&gt;创建对象:</span><br><span class="line">内部类类名 对象名 = new 内部类类名(实参列表);</span><br></pre></td></tr></table></figure></blockquote><h3 id="6-匿名内部类"><a href="#6-匿名内部类" class="headerlink" title="6.匿名内部类"></a>6.匿名内部类</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;概念:没有类名的内部类称为匿名内部类</span><br><span class="line">&gt;定义位置:定义在外部类的成员位置上,或实参中</span><br><span class="line">&gt;语法:</span><br><span class="line">new 父类名或父接口名()&#123;</span><br><span class="line">属性</span><br><span class="line">方法</span><br><span class="line">&#125;;</span><br><span class="line">&gt;注意:</span><br><span class="line">1.一个类只能创建一个对象时,可以使用匿名内部类</span><br><span class="line">2.不能定义静态成员与抽象方法,没有构造函数</span><br><span class="line">&gt;优点:</span><br><span class="line">1.编写方便</span><br><span class="line">&gt;缺点:</span><br><span class="line">2.代码混乱,降低代码可读性</span><br></pre></td></tr></table></figure><p>细节:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1.可以直接访问外部类的所有成员,包含私有</span><br><span class="line">&gt;2.不能添加访问修饰符,他是一个局部变量</span><br><span class="line">&gt;3.作用域:定义他的方法或代码快</span><br><span class="line">&gt;4.如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类成员，则可以使用（外部类.this.成员）</span><br></pre></td></tr></table></figure></blockquote><h1 id="十五-包装类"><a href="#十五-包装类" class="headerlink" title="十五.包装类"></a>十五.包装类</h1><p>八个基本数据类型所对应的引用数据类型</p><p>包装类:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte ----Byte</span><br><span class="line">short----Short</span><br><span class="line">int------Integer</span><br><span class="line">long-----Long</span><br><span class="line">float----Float</span><br><span class="line">double---Double</span><br><span class="line">boolean--Booleab</span><br><span class="line">char-----Character</span><br></pre></td></tr></table></figure><p>提供的方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parsexxx();</span><br><span class="line">将相应的包装类转换成基本数据类型</span><br></pre></td></tr></table></figure><p>整数缓冲区</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-128~127</span><br><span class="line">原因:</span><br><span class="line">因为系统中已经创建了-128~127之间有数的对象,在使用自动装箱时,如果值是在该范围内,直接使用已经创建好的对象,如果超过这个返回需要重新创建对象</span><br></pre></td></tr></table></figure><h1 id="十六-System"><a href="#十六-System" class="headerlink" title="十六.System"></a>十六.System</h1><p>由JDK提供的类</p><p>提供属性或方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static native void arraycopy(Object src,int  srcPos,</span><br><span class="line">                          Object dest, int destPos,</span><br><span class="line">                          int length)</span><br><span class="line">作用:将原数组中的一段数据复制到新数组</span><br><span class="line">1参:原数组</span><br><span class="line">2参:复制开始的位置</span><br><span class="line">3参:新数组</span><br><span class="line"> 4参:新数组开始的位置</span><br><span class="line"> 5参:复制的长度</span><br><span class="line"> </span><br><span class="line">static native long currentTimeMillis()</span><br><span class="line">作用:获取当前时间与1970年1月1日00:00:00:000的时间差(格林威治时间)</span><br><span class="line"></span><br><span class="line">static void exit(int status)</span><br><span class="line">作用:结束当前程序</span><br><span class="line">1参:终止状态码</span><br><span class="line">0:正常退出</span><br><span class="line">1:异常退出</span><br><span class="line"></span><br><span class="line">static void gc()</span><br><span class="line">作用:手动调用垃圾回收机制</span><br></pre></td></tr></table></figure><h1 id="十七-Object"><a href="#十七-Object" class="headerlink" title="十七.Object"></a>十七.Object</h1><p>概念：所有类的父类</p><p>意味：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">该类提供的属性与方法是所有类的对象都可以使用</span><br></pre></td></tr></table></figure><p>提供的方法</p><h2 id="1-equals"><a href="#1-equals" class="headerlink" title="1.equals"></a>1.equals</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object obj)</span><br><span class="line">作用:判断调用该方法的对象与传入的对象的内存地址是否相同</span><br><span class="line">如果子类重写该方法,使用子类对象调用该方法执行的是重写的代码</span><br><span class="line">如果要比较子类的对象属性值是否相同,要重写equals方法</span><br><span class="line">重写步骤:</span><br><span class="line">1.判断内存地址是否相同</span><br><span class="line">2.判断传入的对象是否属于该类对象</span><br><span class="line">3.将传入的对象转换为该类对象(父类转子类对象)</span><br><span class="line">4.使用调用该方法的对象的属性与传入的对象属性一一比较</span><br></pre></td></tr></table></figure><h2 id="2-toString"><a href="#2-toString" class="headerlink" title="2.toString"></a>2.toString</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String toString()</span><br><span class="line">作用:获取对象的包名.类拼接@字符串,再拼接对象的内存地址的16进制</span><br><span class="line">注意:</span><br><span class="line">1.Object提供的toString方法返回的是对象的包名.类@对象内存地址的16进制,可以理解为是对象的信息,但是我们在观察对象时,想看到的是对象的属性值,所以我们可以在子类中重写toString方法,重写后对象在调用toString方法,执行的是重写后的toString方法.</span><br><span class="line">2.重写toString方法,打印对象或拼接对象时,都会自动调用该对象的toString方法</span><br><span class="line">3.直接输出一个对象时,toString方法会被默认调用</span><br></pre></td></tr></table></figure><h2 id="3-hashCode"><a href="#3-hashCode" class="headerlink" title="3.hashCode"></a>3.hashCode</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:获取对象的哈希码值,近似可以理解为对象的内存地址</span><br><span class="line">注意:</span><br><span class="line">1.提高具有哈希结构的容器的效率</span><br><span class="line">2.两个引用,如果指定的是同一个对象,则哈希值肯定是一样的</span><br><span class="line">3.两个引用,如果指向的是不同的对象,则哈希值是不一样的</span><br><span class="line">4.哈希值主要根据地址号来的,不能完全等价于地址</span><br></pre></td></tr></table></figure><h2 id="4-finalize"><a href="#4-finalize" class="headerlink" title="4.finalize"></a>4.finalize</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:系统回收该对象的内存时,才会被调用</span><br><span class="line">注意:</span><br><span class="line">1.当对象被回收时,系统自动调用该对象的finalize方法,子类可以重写该方法做一些释放资源的操作</span><br><span class="line">2.当某个对象没有任何引用时,则jvm就认为这个对象是一个垃圾对象,就会使用垃圾回收机制来销毁对象,在销毁前,就先调用finalize</span><br><span class="line">3.垃圾回收机制的调用,是由系统来决定的,也可以通过System.gc主动触发垃圾回收机制</span><br></pre></td></tr></table></figure><h2 id="5-Math"><a href="#5-Math" class="headerlink" title="5.Math"></a>5.Math</h2><p>作用:数学运算与随机数</p><p>提供的方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static double random();</span><br><span class="line">作用:随机获取0-1之间的数</span><br><span class="line">使用:要想获得特定区间的随机数,random*区间最大值+1;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int abs(int a);</span><br><span class="line">作用:获取其指定数据的绝对值</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static double floor(double a);</span><br><span class="line">作用:向下取整</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static double ceil(double a);</span><br><span class="line">作用:向上取整</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int max(int a , int b)</span><br><span class="line">作用:获取两数之间的最大值</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int min(int a , int b);</span><br><span class="line">作用:获取两束之间的最小值</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static double pow(double a,double b)</span><br><span class="line">作用:计算a的b次幂</span><br></pre></td></tr></table></figure><h2 id="6-字符串"><a href="#6-字符串" class="headerlink" title="6.字符串"></a>6.字符串</h2><h3 id="6-1String"><a href="#6-1String" class="headerlink" title="6.1String"></a>6.1String</h3><blockquote><p><strong>细节:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.String用于保存字符串,也是一组字符序列</span><br><span class="line">2.字符串常量对象是用双引号括起来的字符序列</span><br><span class="line">3.字符串的字符使用Unicode字符编码,一个字符占两个字节</span><br><span class="line">4.String 实现了很多构造器,构造器重载</span><br><span class="line">5.String是fianl类不能被继承</span><br><span class="line">6.Stirng保存字符串时保存在private final char value[];</span><br><span class="line">7.value是final类型,赋值后不能修改(地址不能修改,值可以修改),一个字符串对象一旦分配,其内容是不可变的,指向改变</span><br><span class="line">8.String 这个类实现了Serializable,说明String可以串行化,可以网络传播</span><br><span class="line">9.String这个类实现了Comparable,说明String对象可以比较</span><br></pre></td></tr></table></figure><p><strong>创建方式:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.直接赋值</span><br><span class="line">String s = &quot;hhhh&quot;;</span><br><span class="line">先从常量池查看是否有&quot;hhhhhh&quot;数据空间,如果有,直接指向:如果没有,则重新创建,然后指向,s最终指向的是常量池的地址空间</span><br><span class="line">2.调用构造器</span><br><span class="line">String s = new String(&quot;xxxx&quot;);</span><br><span class="line">先从堆中创建空间,里面维护了value属性,指向常量池的&quot;xxxx&quot;的空间,如果常量池没有&quot;xxxx&quot;重新创建,如果有,直接通过value指向,最终指向的是堆中的空间</span><br></pre></td></tr></table></figure><p><strong>常见方法:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replace</span><span class="params">(String old,String newStr)</span></span><br><span class="line">作用:替换</span><br><span class="line"><span class="number">1</span>参:要被替换的字符串</span><br><span class="line"><span class="number">2</span>参:替换后的字符串</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span></span><br><span class="line">作用:获取字符串长度</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">作用:获取字符串中指定位置的字符</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">char</span>[] toCharArray()</span><br><span class="line">作用:将字符串转换为字符数组</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span></span><br><span class="line">作用:比较字符串内容是否相同</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String anotherString)</span></span><br><span class="line">作用:忽略大小写比较字符串内容是否相同</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">trim</span><span class="params">()</span></span><br><span class="line">作用:忽略前后空白</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">(String suffix)</span></span><br><span class="line">作用:判断字符串是否以指定的字符串结束</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span></span><br><span class="line">作用:判断字符串以什么开始</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toUpperCase</span><span class="params">()</span></span><br><span class="line">作用:将字符串中的小写字母转换为大写字母</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toLowerCase</span><span class="params">()</span></span><br><span class="line">作用:将字符串中的大写字母转换为小写字母</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String s)</span></span><br><span class="line">作用:判断s是否在调用该方法的字符串中存在</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str)</span></span><br><span class="line">作用:获取指定的子字符串在字符串中最后一次出现的位置</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span></span><br><span class="line">作用:获取指定的子字符串在字符串中第一次出现的位置</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span></span><br><span class="line">作用:截取指定位置的字符串,从开始位置到字符串末尾</span><br><span class="line">beginIndex:开始位置</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex , <span class="type">int</span> endIndex)</span></span><br><span class="line">作用:截取指定位置的字符串</span><br><span class="line"><span class="number">1</span>参:开始位置</span><br><span class="line"><span class="number">2</span>参:结束位置</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex)</span><br><span class="line">作用:切割</span><br><span class="line"><span class="number">1</span>参:按什么字符串切割</span><br></pre></td></tr></table></figure><p>构造函数</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[])</span></span><br><span class="line">将传入的字符数组转换为字符串</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[],<span class="type">int</span> offset,<span class="type">int</span> count)</span></span><br><span class="line">在<span class="type">char</span>数组中,从offset开始截取count位字符</span><br></pre></td></tr></table></figure></blockquote><h3 id="6-2StringBuffer和StringBuilder"><a href="#6-2StringBuffer和StringBuilder" class="headerlink" title="6.2StringBuffer和StringBuilder"></a>6.2StringBuffer和StringBuilder</h3><p><strong>长度可变</strong></p><h4 id="1-StringBuffer"><a href="#1-StringBuffer" class="headerlink" title="1.StringBuffer"></a>1.StringBuffer</h4><p>​特点:jdk1.0出现,线程安全的,效率低</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuffer是一个容器</span><br><span class="line">1.StringBuffer的直接父类是AbstractStringBuilder</span><br><span class="line">2.StringBuffer实现了Serializable,即StringBuffer的对象可以串行化</span><br><span class="line">3.在父类中有一个属性char[] value,不是final</span><br><span class="line">4.该value数组中存放字符串内容,引出存放在堆中的StringBuffer是一个public final class,所以StringBuffer不能被继承</span><br><span class="line">5.因为StringBuffer字符内容是存在char[]value,所以增加和删除不用每次都更换地址,即每次都创建新的对象,故效率高于String</span><br></pre></td></tr></table></figure><h4 id="2-StringBuilder"><a href="#2-StringBuilder" class="headerlink" title="2.StringBuilder"></a>2.StringBuilder</h4><p>特性:JDK1.5出现,线程不安全,效率高</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.一个可变字符序列,此类提供了一个与StringBuffer兼容的API,但不保证同步(StringBuilder不是线程安全的),该类被设计用做StringBuffer的一个简易替换,用在字符串缓存区被单个线程使用的时候,如果可能,简易有先采用StringBuilder,在大多数实现中,他比StringBuffer要快</span><br><span class="line">2.在StringBuilder上主要操作的是append和insert方法,可重载这些方法,以便于接受任意类型的数据</span><br><span class="line">3.单线程的情况下使用StringBuilder</span><br></pre></td></tr></table></figure><h4 id="3-提供的方法"><a href="#3-提供的方法" class="headerlink" title="3.提供的方法"></a>3.提供的方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.StringBuilder append(Object obj)</span><br><span class="line">作用:给字符串尾部拼接字符串</span><br><span class="line">2.StringBuilder insert(int offset , String str)</span><br><span class="line">作用:插入</span><br><span class="line">1参:插入开始的位置</span><br><span class="line">2参.插入的数据</span><br><span class="line">3.StringBuilder delete(int start,int end)</span><br><span class="line">作用:删除指定区间的数据</span><br><span class="line">1参:开始位置,包含</span><br><span class="line">2餐:结束位置,不包含</span><br><span class="line">4.StringBuilder deleteCharAt(int index)</span><br><span class="line">作用:删除指定位置的字符</span><br><span class="line">1参:指定位置</span><br><span class="line">5.StringBuilder replace(int start ,int end,String str)</span><br><span class="line">作用:替换</span><br><span class="line">1.参:要替换的数据的开始位置,包含</span><br><span class="line">2.参:要替换的数据的结束位置,不包含</span><br><span class="line">3.替换后的字符串</span><br><span class="line">6.toString()</span><br><span class="line">作用:将可变字符转换为不可变字符</span><br><span class="line">StringBuffer str = new StringBuffer();</span><br><span class="line">String s = str.toString();</span><br><span class="line"></span><br><span class="line">不可变字符转可变字符</span><br><span class="line">String str = &quot;hello&quot;;</span><br><span class="line">StringBuffer s = new StringBuffer(str);</span><br></pre></td></tr></table></figure><h1 id="十八-BigDecimal和BigInteger"><a href="#十八-BigDecimal和BigInteger" class="headerlink" title="十八.BigDecimal和BigInteger"></a>十八.BigDecimal和BigInteger</h1><h2 id="1-BigDeciamal"><a href="#1-BigDeciamal" class="headerlink" title="1.BigDeciamal"></a>1.BigDeciamal</h2><p>适合保存精度更高的浮点型</p><p>构造函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BigDeciaml(Object obj);</span><br></pre></td></tr></table></figure><p>提供方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BigDecimal subtract(BigDecimal subtrahend)</span><br><span class="line">作用:减法,使用调用该方法的对象的值减去传入的对象的值,返回计算结果</span><br><span class="line">BigDecimal add(BigDecimal augend)</span><br><span class="line">作用:加法</span><br><span class="line">BigDeciamal multiply(BigDecimal multiplicand)</span><br><span class="line">作用:乘法</span><br><span class="line">BigDeciaml divide(BigDecimal divisor)</span><br><span class="line">作用:除法</span><br><span class="line">xxx xxxValue();</span><br><span class="line">作用:获取BigDeciaml的值</span><br></pre></td></tr></table></figure><h2 id="2-BigInterger"><a href="#2-BigInterger" class="headerlink" title="2.BigInterger"></a>2.BigInterger</h2><p>BigInteger适合保存比较大的整型</p><p>方法同上</p><h1 id="十九-时间相关类"><a href="#十九-时间相关类" class="headerlink" title="十九.时间相关类"></a>十九.时间相关类</h1><h2 id="1-Date"><a href="#1-Date" class="headerlink" title="1.Date"></a>1.Date</h2><p>概念:日期</p><p>创建</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public Date();获取当前系统时间</span></span><br><span class="line"><span class="comment">//public Date(long date);</span></span><br><span class="line"><span class="comment">//获取距离1970年1月1日00.00.00的时间,单位毫秒</span></span><br><span class="line"></span><br><span class="line"><span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(date1);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>()默认输出的格式为国外</span><br><span class="line">就需要格式转换,通过创建SimpleDateFormat对象可以指定格式: yyyy年MM月dd日  hh:mm:ss E</span><br><span class="line">E代表星期中的天数</span><br><span class="line"></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);</span><br></pre></td></tr></table></figure><p>​format:将时间对象转换为指定格式的字符串<br>​parse:将指定格式的字符串转换为时间</p><p>before,after</p><h2 id="2-Calendar"><a href="#2-Calendar" class="headerlink" title="2.Calendar"></a>2.Calendar</h2><p>概念:日历</p><p>创建</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static Calender getInstance()</span><br></pre></td></tr></table></figure><p>方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get</span><br><span class="line">System.out.println(&quot;年&quot;+instance.get(Calendar.YEAR));</span><br><span class="line">System.out.println(&quot;月&quot;+(instance.get(Calendar.MONTH)+1));//Calender&#x27;是按照0开始编号</span><br><span class="line">System.out.println(&quot;日&quot;+instance.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">System.out.println(&quot;小时&quot;+instance.get(Calendar.HOUR));</span><br><span class="line">System.out.println(&quot;分钟&quot;+instance.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(&quot;秒&quot;+instance.get(Calendar.SECOND));</span><br><span class="line">set</span><br><span class="line">add</span><br><span class="line">getTime</span><br></pre></td></tr></table></figure><h2 id="3-第三代时间"><a href="#3-第三代时间" class="headerlink" title="3.第三代时间"></a>3.第三代时间</h2><p>在JDK8中加入了LocalDate(日期)，LocalTime(时间)，LocalDateTime（日期时间）</p><ul><li><p>LocalDate只包含日期，可以获取日期字段</p></li><li><p>LocalTime只包含时间，可以获取时间字段</p></li><li><p>LocalDateTime包含日期+时间，可以获取日期和时间字段</p></li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用now返回表示当前时间的对象</span></span><br><span class="line">   <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">   System.out.println(now);</span><br><span class="line">   System.out.println(<span class="string">&quot;年:&quot;</span>+now.getYear());</span><br><span class="line">   System.out.println(<span class="string">&quot;月:&quot;</span>+now.getMonth());</span><br><span class="line">   System.out.println(<span class="string">&quot;月:&quot;</span>+now.getMonthValue());</span><br><span class="line">   System.out.println(<span class="string">&quot;日:&quot;</span>+now.getDayOfMonth());</span><br><span class="line">   System.out.println(<span class="string">&quot;时:&quot;</span>+now.getHour());</span><br><span class="line">   System.out.println(<span class="string">&quot;分:&quot;</span>+now.getMinute());</span><br><span class="line">   System.out.println(<span class="string">&quot;秒:&quot;</span>+now.getSecond());</span><br><span class="line"></span><br><span class="line"> <span class="comment">//可以获取年月日</span></span><br><span class="line">   <span class="type">LocalDate</span> <span class="variable">now1</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">   System.out.println(now1.getYear());</span><br><span class="line">   <span class="comment">//可以获取时分秒</span></span><br><span class="line">   <span class="type">LocalTime</span> <span class="variable">now2</span> <span class="operator">=</span> LocalTime.now();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//使用DateTimeFormatter  格式日期类</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now3</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日  HH时mm分ss秒&quot;</span>);</span><br><span class="line">String str=dateTimeFormatter.format(now3);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><h1 id="二十-泛型"><a href="#二十-泛型" class="headerlink" title="二十.泛型"></a>二十.泛型</h1><p>作用:将数据类型作为参数传递</p><p>语法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义:</span><br><span class="line">&lt;泛型1,泛型2...&gt;</span><br><span class="line">情况1:在方法上</span><br><span class="line">访问权限修饰符 修饰符 &lt;泛型1,泛型2...&gt; 返回值类型 方法名(形参列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">情况2:在类上定义</span><br><span class="line">    访问权限修饰符 class 类名&lt;泛型1,泛型2...&gt;&#123;&#125;</span><br><span class="line"> </span><br><span class="line"> 使用:</span><br><span class="line"> 泛型名</span><br><span class="line"> 情况1:在方法中使用</span><br><span class="line"> 在方法中任意使用数据类型的地方都可以使用该泛型作为数据类型</span><br><span class="line"> 情况2:在类中使用</span><br><span class="line">        在类中任意使用数据类型的地方都可以使用该泛型作为数据类型</span><br></pre></td></tr></table></figure><p>注意:<strong>泛型中只能使用引用数据类型</strong></p><h1 id="二十一-集合"><a href="#二十一-集合" class="headerlink" title="二十一.集合"></a>二十一.集合</h1><h3 id="1-作用-2"><a href="#1-作用-2" class="headerlink" title="1.作用"></a>1.作用</h3><blockquote><p>动态的存储一组数据类型相同的数据</p></blockquote><h3 id="2-特点-1"><a href="#2-特点-1" class="headerlink" title="2.特点"></a>2.特点</h3><blockquote><p>长度可变</p></blockquote><h3 id="3-名称"><a href="#3-名称" class="headerlink" title="3.名称"></a>3.名称</h3><blockquote><p>长度:集合中存在的元素个数</p><p>下标:元素在集合中的位置</p><p>元素:集合中存储的数据</p></blockquote><h3 id="4-体系结构"><a href="#4-体系结构" class="headerlink" title="4.体系结构"></a>4.体系结构</h3><blockquote><h2 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1.Collection"></a>1.Collection</h2><p>分类:List,Set</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;List</span><br><span class="line">特点:有序(存入和取出顺序一致),由下标,可以重复</span><br><span class="line">子类:</span><br><span class="line">ArrayList:</span><br><span class="line">特点:JDK1.2出现,线程不安全的</span><br><span class="line">数据结构:数组</span><br><span class="line">特点:查询效率高,增删效率低</span><br><span class="line">LinkedList</span><br><span class="line">      特点:查询效率低,增删效率高</span><br><span class="line">      数据结构:链表</span><br><span class="line">   Vector:</span><br><span class="line">      特点:JDK1.0出现,线程安全</span><br><span class="line">      数据结构:数组</span><br><span class="line">      </span><br><span class="line">&gt;Set</span><br><span class="line">特点:无序,无下标,元素不允许重复</span><br><span class="line">子类:</span><br><span class="line">HashSet</span><br><span class="line">底层:HashMap</span><br><span class="line">数据结构:</span><br><span class="line">JDK1.8以前数组+链表</span><br><span class="line">JDK1.8之后数组+链表+红黑树</span><br><span class="line">TreeSet</span><br><span class="line">      数据结构:红黑树</span><br><span class="line">      注意:指定比较规则</span><br><span class="line">  LinkedHashSet</span><br><span class="line">      特点:有序</span><br><span class="line">      数据结构:数组+双向链表</span><br></pre></td></tr></table></figure></blockquote><h2 id="Collection提供的方法"><a href="#Collection提供的方法" class="headerlink" title="Collection提供的方法"></a>Collection提供的方法</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;增:</span><br><span class="line">boolean add(E e)</span><br><span class="line">作用:一次添加一个数据</span><br><span class="line">参数:要添加的数据</span><br><span class="line">返回值:是否添加成功</span><br><span class="line">boolean addAll(Collection&lt;? extends E&gt; c);</span><br><span class="line">作用:一次添加一组数据</span><br><span class="line">参数:要添加的数据集合</span><br><span class="line">返回值:</span><br><span class="line">是否添加成功,哪怕只添加一个也算成功,全部失败才是失败</span><br><span class="line"></span><br><span class="line">&gt;删:</span><br><span class="line">boolean remove(Object o)</span><br><span class="line">作用:一次删除一个数据</span><br><span class="line">参数:要删除的数据</span><br><span class="line">返回值:是否删除成功</span><br><span class="line">注意:如果集合中有多个要删除的数据,智能删除第一个</span><br><span class="line">boolean removeAll(Collection&lt;?&gt; c)</span><br><span class="line">作用:一次删除一组数据</span><br><span class="line">参数:要删除的数据集合</span><br><span class="line">返回值:是否删除成功</span><br><span class="line">注意:如果原集合中多次出现删除集合中的数据,那么元集合中的该数据会全部被删除</span><br><span class="line">&gt;void clear()</span><br><span class="line">作用:清空集合中的数据</span><br><span class="line">&gt;查:</span><br><span class="line">int size()</span><br><span class="line">作用:查询集合长度</span><br><span class="line">boolean contains(Object o);</span><br><span class="line">作用:判断集合中是否包含指定元素</span><br><span class="line">&gt;boolean containsAll(Collection&lt;?&gt; C)</span><br><span class="line">作用:判断集合中是否全部包含指定的集合中的元素</span><br><span class="line">注意:判断的是是否全部包含</span><br><span class="line">&gt;boolean isEmpty();</span><br><span class="line">作用:判断集合是否为空集合</span><br><span class="line">注意:空集合表示集合中没有元素,而不是集合为null</span><br><span class="line">&gt;Iterator&lt;E&gt; Iterator()</span><br><span class="line">作用:获取当前集合的迭代器</span><br><span class="line">迭代器方法:</span><br><span class="line">boolean hasNext();判断下一个是否有值</span><br><span class="line">E next(); 移动游标,并返回指向的数据</span><br></pre></td></tr></table></figure><h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;遍历:</span><br><span class="line">迭代器</span><br><span class="line">foreach</span><br></pre></td></tr></table></figure></blockquote><h3 id="5-List提供的方法"><a href="#5-List提供的方法" class="headerlink" title="5.List提供的方法"></a>5.List提供的方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增:</span><br><span class="line">void add(int index, E element)</span><br><span class="line">作用:给指定位置插入一个数据</span><br><span class="line">    void addAll(int index,Collection&lt;E&gt; C)</span><br><span class="line">    作用:给指定位置插入一组数据</span><br><span class="line">    </span><br><span class="line">删:</span><br><span class="line">E remove(int index)</span><br><span class="line">作用:删除指定位置的数据</span><br><span class="line"></span><br><span class="line">改:</span><br><span class="line">E set(int index,E element)</span><br><span class="line">作用:修改指定位置的元素</span><br><span class="line">参数:1参,指定的位置;2参,修改后的元素</span><br><span class="line"></span><br><span class="line">查:</span><br><span class="line">E get(int index)</span><br><span class="line">作用:获取指定位置的元素</span><br></pre></td></tr></table></figure><h3 id="6-HashSet的剔重原理"><a href="#6-HashSet的剔重原理" class="headerlink" title="6.HashSet的剔重原理"></a>6.HashSet的剔重原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.存入对象先判断对象的hashCode值是否与已经存储的数据hashcode值是否相同</span><br><span class="line">2.如果相等,在使用本次存入的对象与集合中的对象使用equals方法一一比较</span><br><span class="line">3.如果equals也相同,认为对象已经存储,将不再存入该对象</span><br></pre></td></tr></table></figure><h3 id="7-TreeSet存储"><a href="#7-TreeSet存储" class="headerlink" title="7.TreeSet存储"></a>7.TreeSet存储</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeSet存储的数据</span><br><span class="line">要么拥有比较性(让存储的对象的类实现Comparable)</span><br><span class="line">要么指定比较器(创建TreeSet传入Comparator对象)</span><br></pre></td></tr></table></figure><h1 id="二十二-Map"><a href="#二十二-Map" class="headerlink" title="二十二.Map"></a>二十二.Map</h1><h3 id="1-作用-3"><a href="#1-作用-3" class="headerlink" title="1.作用:"></a>1.作用:</h3><p>​存储一组键值对应的数据类型的数据</p><h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h3><blockquote><p>名称</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">键:key</span><br><span class="line">值:value</span><br></pre></td></tr></table></figure><p>体系结构</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map</span><br><span class="line">HashMap</span><br><span class="line">特点:使用键值对的中键的hashcode值进行排序,允许空键空值,JDK1.2,线程不安全的</span><br><span class="line">Hashtable</span><br><span class="line">特点:使用键值对的中键的hashcode值进行排序,不允许空键空值,JDK1.0,线程安全的</span><br><span class="line">TreeMap</span><br><span class="line">特点:要求键要么拥有比较性,要么指定key的比较器</span><br><span class="line">Properties</span><br><span class="line">特点:HashMap的子类,可以加载读取文件中的内容,也可以向文件中写入内容</span><br><span class="line">注意:</span><br><span class="line">key值不能重复</span><br></pre></td></tr></table></figure><p>Map提供的方法</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增</span><br><span class="line">V put(K key, V value);</span><br><span class="line">作用:添加</span><br><span class="line">注意:</span><br><span class="line">如果map中不存在该key,返回值为null</span><br><span class="line">如果map中存在该key那么此时就是替换,返回被替换的值</span><br><span class="line">void putAll(Map&lt;? extends K, ? extends V&gt; m);</span><br><span class="line">作用:添加一组键值对</span><br><span class="line">删</span><br><span class="line">V remove(Object key);</span><br><span class="line">作用:通过key删除指定的键值对</span><br><span class="line">返回值:被删除的值</span><br><span class="line">void clear();</span><br><span class="line">作用:清空</span><br><span class="line">查</span><br><span class="line">int size();</span><br><span class="line">作用:查询map中键值对的个数</span><br><span class="line">boolean isEmpty();</span><br><span class="line">作用:判断是否为空map</span><br><span class="line">boolean containsKey(Object key);</span><br><span class="line">作用:判断是否包含指定的key</span><br><span class="line">boolean containsValue(Object value);</span><br><span class="line">作用:判断是否包含指定的value</span><br><span class="line">V get(Object key);</span><br><span class="line">作用:获取key指定的值</span><br><span class="line">Set&lt;K&gt; keySet();</span><br><span class="line">作用:获取所有key的集合</span><br><span class="line">Collection&lt;V&gt; values();</span><br><span class="line">作用:获取所有值的集合</span><br><span class="line">Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="line">作用:获取所有键值对的集合</span><br><span class="line">改</span><br><span class="line">V put(K key, V value);</span><br><span class="line">注意:如果存储数据时,key已经存在,此时就是修改**Map接口的遍历方式**</span><br></pre></td></tr></table></figure></blockquote><h3 id="3-特点"><a href="#3-特点" class="headerlink" title="3.特点:"></a>3.特点:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Map和collection并列存在,用于保存具有映射关系的数据Key-Value</span><br><span class="line">2.Map中的Key和Value可以是任何引用数据类型,会封装到HashMap&amp;$Node对象中</span><br><span class="line">3.Map中的Key不允许重复,有相同的key时,采用替换机制,新出现的替换已有的,原因和HashSet一样</span><br><span class="line">4.Map中value可重复</span><br><span class="line">5.Map的key可以为null,value也可以为null,key只能有一个null,value为null可以有多个</span><br><span class="line">6.常用的String类可作为Map的key</span><br><span class="line">7.key和value之间存在一对一关系，及通过指定可以总能找到对应的value。</span><br></pre></td></tr></table></figure><h3 id="4-Map接口的遍历方式"><a href="#4-Map接口的遍历方式" class="headerlink" title="4.Map接口的遍历方式"></a><strong>4.Map接口的遍历方式</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">     map.put(<span class="string">&quot;舒克&quot;</span>,<span class="string">&quot;贝塔&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;李大头&quot;</span>,<span class="string">&quot;李大脑袋&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;郭德纲&quot;</span>,<span class="string">&quot;于谦&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;岳云鹏&quot;</span>,<span class="string">&quot;孙越&quot;</span>);</span><br><span class="line">     map.put(<span class="literal">null</span>,<span class="string">&quot;kk&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;king&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;===========第一种遍历===========&quot;</span>);</span><br><span class="line">     <span class="comment">//第一种遍历，先取出所有的Key，再通过Key取出对应的value</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">keyset</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">    <span class="comment">//(1)增强for</span></span><br><span class="line"><span class="keyword">for</span> (Object key :keyset) &#123;</span><br><span class="line">    System.out.println(key+<span class="string">&quot;-&quot;</span>+map.get(key));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//（2）迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keyset.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;===========第二种遍历===========&quot;</span>);</span><br><span class="line"><span class="comment">//第二种，把所有的value取出</span></span><br><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="comment">//可以使用collection使用的所有遍历方式</span></span><br><span class="line"><span class="comment">//(1)迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> values.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator1.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span>  iterator1.next();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(2)for增强</span></span><br><span class="line"><span class="keyword">for</span> (Object o :values) &#123;</span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;============第三种遍历============&quot;</span>);</span><br><span class="line"><span class="comment">//第三种遍历方式，通过EntrySet获取</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">entryset</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line"><span class="comment">//（1）增强for</span></span><br><span class="line"><span class="keyword">for</span> (Object entryset1 :entryset) &#123;</span><br><span class="line">    <span class="comment">//将entryset1转成Map.entry</span></span><br><span class="line">    Map.Entry m=(Map.Entry) entryset1;</span><br><span class="line">    System.out.println(m.getKey()+<span class="string">&quot;-&quot;</span>+m.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//（2）迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> entryset.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator2.next();</span><br><span class="line">     <span class="comment">//将iterator2转成Map.entry</span></span><br><span class="line">    Map.Entry m1=(Map.Entry) next;</span><br><span class="line">    System.out.println(m1.getKey()+<span class="string">&quot;-&quot;</span>+m1.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-开发中如何选择集合实现类"><a href="#5-开发中如何选择集合实现类" class="headerlink" title="5.开发中如何选择集合实现类*"></a>5.<em>开发中如何选择集合实现类</em>*</h3><ol start="3"><li><pre><code>/*开发中如何选择集合实现类**  1. **先判断存储的类型（一组对象或一组键值对）**2. **一组对象（单列）：collection接口**   **允许重复：List**            **增删多：LinkedList   底层维护了一个双向链表**            **改查多：ArrayList    底层维护Object类型的可变数组**   **不允许重复  Set**            **无序:HashSet 底层是HashMap  维护了一个哈希表即数组+链表+红黑树**            **排序：TreeSet**            **插入和取出顺序一致：LinkedHashSet，维护数组+双向链表**3. **一对键值对（双列）：Map**   **键无序：HashMap  底层是：哈希表  jdk7：数组+链表   jdk8：数组+链表+红黑树**   **键排序：TreeMap   **键插入和取出顺序一致：LinkedHashMap      **读取文件：Properties   */<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 6.扩容机制</span><br><span class="line"></span><br></pre></td></tr></table></figure>**扩容机制：**1. HashMap底层维护了Node类型的数组table，默认为nll2. 当创建对象时，将加载因子（loadfactor）初始化为0.753. 当添加key-value时，通过key的哈希值得到table的索引，然后判断该索引处是否有元素，如果没有元素直接添加，如果该索引处有元素，判断钙元素的key是否和准备加入的key相等，如果相等，则直接替换val：如果不相等需要判断是树结构还是链表结构，做出相应的处理，如果添加时发现容量不够，则需要扩容4. 第一次添加，则需要扩容table容量为16，临界值为125. 以后再扩容，则需要扩容table容量为原来的2倍32，临界值为原来的2倍，即24，以此类推6. 在java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD(默认为8)，并且table的大小&gt;=MIN_TREEIFY_CAPACITY(默认64)就会进行树化<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 7.HashTable</span><br><span class="line"></span><br></pre></td></tr></table></figure>1. 存放的元素时键值对 k-v2. hashtable的键和值都不能为空3. hashtable使用方法和HashMap基本一样4. hashtable是线程安全的5. hashtable底层有数组hashtable$Entry[]初始值为11，threshold=86. 扩容按照自己的扩容机制进行7. 扩容时执行addEntry（hash，key，value，index）；添加一个k-v封装在Entry8. 当count&gt;=threshold时就进行扩容9. 新的扩容时  （旧容量&lt;&lt;1）+1<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   ### 8.Properties</span><br><span class="line"></span><br><span class="line">4. properties类继承自hashtable类并且实现了Map接口，也是使用一种键值对的形式保存数据</span><br><span class="line"></span><br><span class="line">5. 使用特点和hashtable类似，不能有空的键和空的值</span><br><span class="line"></span><br><span class="line">6. properties可以用于从  xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改</span><br><span class="line"></span><br><span class="line">7. 说明xxx.properties文件通常作为配置文件</span><br><span class="line"></span><br><span class="line">### 9.collection工具类</span><br><span class="line"></span><br><span class="line">1.  Collections是一个操作Set、List、Map等集合的工具类</span><br><span class="line">2.  Collections中提供了一系列静态的方法对集合元素进行排序、查询、修改等操作</span><br><span class="line">3.  排序操作：（均为static方法）</span><br><span class="line">    - resverse（List）：反转List中元素的顺序</span><br><span class="line">    - shuffle（List）：对List集合元素进行随机排序</span><br><span class="line">    - sort（List）：根据元素的自然顺序对指定的lisdt集合元素按升序排序</span><br><span class="line">    - sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序</span><br><span class="line">    - swap（List，int，int）：将指定list集合中i处元素和j处元素进行交换</span><br><span class="line"></span><br><span class="line">4.查找，替换</span><br><span class="line"></span><br><span class="line">- Object max（Collection）:根据元素的自然顺序，返回给的集合中最大的元素</span><br><span class="line">- Object  max（Collection，Comparator）根据Comparator指定的顺序，返回给定集合中最大的元素4</span><br><span class="line">- Object min（Collection）</span><br><span class="line">- Object  min（Collection，Comparator）</span><br><span class="line">- int  frequency（Collection，Object）将返回指定集合中指定元素出现的次数</span><br><span class="line">- void copy（List dest，List dest）将src中的内容复制到dest中</span><br><span class="line">- boolean  replaceAll（List list，Object oldVal，Object newVal）使用新值替换List对象的所有旧值</span><br><span class="line"></span><br><span class="line"># 二十三.异常</span><br><span class="line"></span><br><span class="line">### 1.概念:</span><br><span class="line"></span><br><span class="line">在java语言中,将程序执行中发生的不正常情况称为异常</span><br><span class="line"></span><br><span class="line">### 2.分类:</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre></li></ol><p>1.Error:java虚拟机无法解决的严重问题,如jvm系统内部错误,资源耗尽等</p><p>2.Exception:因编程错误,或偶然的外部因素导致的一般性问题,可以使用正对性的代码处理,例如空指针访问,网络中断等.</p><p>Exception分为两大类,运行时异常和编译时异常</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">检查时异常</span><br><span class="line">概念:因语法问题导致的错误</span><br><span class="line">解决:修改语法</span><br><span class="line">运行时异常</span><br><span class="line">概念:但是因为编写时思路问题,或传入的数据导致程序无法正常运行</span><br><span class="line">解决:更换思路,修改传入的数据,加入容错判断</span><br><span class="line"></span><br><span class="line">体系结构:</span><br><span class="line"></span><br><span class="line">​Throwable:</span><br><span class="line"></span><br><span class="line">​Error(错误)</span><br><span class="line"></span><br><span class="line">​Exception(异常):CheckedException(检查时异常),RuntimeException(运行时异常)</span><br><span class="line"></span><br><span class="line">### 3.五大运行异常</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol><li><p>NullPointerException 空指针异常</p><p>当应用程序试图在需要对象的地方使用null时，抛出该异常</p></li><li><p>ArithmeticException  数学运算异常</p><p>当出现异常的运算条件时，抛出此异常</p></li><li><p>ArrayIndexOutOfBoundsException数组下标越界异常</p><p>用非法索引访问数组时抛出异常，如果索引为负或大于等于数组，则为非法索引</p></li><li><p>ClassCastException类型转换异常</p><p>当时图将对象强制转换为不是实例的子类时，抛出该异常</p></li><li><p>NumberFormatException数字格式不正确异常</p><p>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常&#x3D;&gt;使用异常我们可以确保输入是满足条件数字</p></li></ol><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 4.编译异常</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SQLException    操作数据库时查询表可能发生异常</p><p>IOException   操作文件时发生异常</p><p>FileNotFoundException     当操作一个不存在的文件时，发生异常</p><p>ClassNotFoundException    加载类，而类不存在时，发生异常</p><p>EOFException    操作文件，到文件末尾，发生异常</p><p>IllegalArguementException    参数异常</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 5.异常处理方式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>try-catch<br>    语法:<br>    try{<br>        异常代码<br>    }catch(异常类型 变量名){<br>        处理方式<br>    }catch(异常类型 变量名){<br>        处理方式<br>    }…..<br>    catch(异常类型 变量名){<br>        处理方式<br>    }finally{<br>        必须执行的代码<br>    }<br>注意:<br>    1.如果发生异常,则异常后面的代码不再执行,直接进入catch<br>    2.如果没有异常发生,则顺序执行try的代码块,不会进入catch<br>    3.如果希望不管是否发生异常,都执行某段代码(关闭连接,释放资源)则使用finally<br>    4.可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求父类异常在后，子类异常在前，比如（Exception在后，NULLpointerException在前）如果发生异常，只会匹配一个catch<br>    5.也可以使用try-finally配合使用，<strong>这种用法相当于没有捕获异常</strong>，因此程序会崩。应用场景，就是执行一段代码，不管是否发生异常，都必须执行某个业务逻辑<br>    6.捕获异常后，有return时，执行return但不会返回return的后缀，  执行finally</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>throws:<br>    将发生的异常抛出,交给调用者自行处理,最顶尖的处理者是JVM<br>    语法:<br>        throws 异常类型1,异常类型2….<br>        使用位置方法的形参之后</p><p>基本介绍:<br>    1.如果一个方法中的语句执行时,可能生成某种异常,但是并不能确定如何处理这种异常,则此方法应显示声明抛出异常,表明该方法将不对异常进行处理,而是由方法的调用者处理<br>    2.在方法声明时,可以使用throws抛出异常,throws后面的异常类型可以是方法中产生的异常类型,也可以是它的父类.<br>    3.throws可以抛出多个异常</p><p>细节:<br>    1. 对于编译异常，程序中必须处理，比如：try-catch或者throws<br>    2. 对于运行时异常，程序中如果没有处理，默认就是throws的处理方式<br>    3. 子类重写父类方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出异常类型的子类<br>    4. 在throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必thows</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>throw<br>    声明异常<br>    语法:<br>        throw 异常对象;<br>    位置:方法中</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 6.自定义异常</span><br><span class="line"></span><br><span class="line">当程序中出现某些错误时,但是该错误信息并没有在Throwable子类中描述处理,这个时候可以自己设计异常类,用于描述错误信息.</span><br><span class="line"></span><br><span class="line">1.步骤:</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>1.定义类:自定义异常类,<br>2.异常类类名继承Exception或者RuntimeException<br>3.编写其构造函数</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 二十四.数据结构</span><br><span class="line"></span><br><span class="line">### 1.栈</span><br><span class="line"></span><br><span class="line">​先进后出</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Stack &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        stack01();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void  stack01()&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt;5; i++) &#123;</span><br><span class="line">            integers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        while (integers.size()&gt;0)&#123;</span><br><span class="line">            Integer remove = integers.remove(integers.size() - 1);</span><br><span class="line">            System.out.print(remove+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">            System.out.println(integers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2.队列"></a>2.队列</h3><p>​先进先出</p><p>代码示例:</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        queue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">queue</span><span class="params">()</span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (list.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">remove</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">            System.out.print(remove+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="3-单链表"><a href="#3-单链表" class="headerlink" title="3.单链表"></a>3.单链表</h3><p>​<img src="C:\Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230417193112848.png" alt="image-20230417193112848"></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;4&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;3&quot;</span>,node4);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;2&quot;</span>,node3);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;1&quot;</span>,node2);</span><br><span class="line"></span><br><span class="line">        System.out.print(node1.getData()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        System.out.print(node1.next().getData()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        System.out.print(node1.next().next().getData()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        System.out.print(node1.next().next().next().getData()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object data, Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">next</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="二十五-线程"><a href="#二十五-线程" class="headerlink" title="二十五.线程"></a>二十五.线程</h1><h3 id="1-作用-4"><a href="#1-作用-4" class="headerlink" title="1.作用:"></a>1.作用:</h3><p>​使代码可以同时执行多个事物</p><h3 id="2-名词"><a href="#2-名词" class="headerlink" title="2.名词"></a>2.名词</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进程:一个正在执行的程序</span><br><span class="line">进程是程序的一次执行过程,或是正在运行的一个程序.是动态过程:有他自身的产生,存在,消亡</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程: 一个执行路径</span><br><span class="line">线程是由进程创建的,是进程的一个实体,一个进程可以有多个线程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单线程:同一时刻,只允许执行一个线程</span><br><span class="line">多线程:同一时刻,可以执行多个线程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主线程:一个线程创建时自带的一条线程,称为主线程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子线程:除主线程外都是子线程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">守护线程(后台线程):</span><br><span class="line">特点:如果一个进程的前台线程全部被销毁,此时不管是否有守护线程正在执行,此时进程都将被回收</span><br><span class="line">前台线程:</span><br><span class="line">特点:如果一个进程中有前台线程存活,此时系统将不会回收进程</span><br></pre></td></tr></table></figure><h3 id="3-组成"><a href="#3-组成" class="headerlink" title="3.组成:"></a>3.组成:</h3><h3 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程抢夺CPU执行权后可执行的时间</span><br></pre></td></tr></table></figure><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个线程一个栈内存,多个线程共享一个堆内存</span><br></pre></td></tr></table></figure><h3 id="4-线程的创建"><a href="#4-线程的创建" class="headerlink" title="4.线程的创建"></a>4.线程的创建</h3><h3 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一:</span><br><span class="line">创建Thread的子类对象</span><br><span class="line">步骤:</span><br><span class="line">1.创建一个类</span><br><span class="line">2.使其继承Thread</span><br><span class="line">3.重写run方法</span><br><span class="line">注意:当前线程启动后,将执行如方法中的代码</span><br><span class="line">    4.创建该类对象</span><br><span class="line">    优点:可以创建无数个该类对象</span><br><span class="line">    </span><br><span class="line">  方式二:</span><br><span class="line">  使用匿名内部类的形式创建Thread的子类对象</span><br><span class="line">  步骤:</span><br><span class="line">  Thread 对象名 = new Thread()&#123;</span><br><span class="line">  重写run方法</span><br><span class="line">  &#125;</span><br><span class="line">  优点:便于书写</span><br><span class="line">        缺点:只能创建一个该线程对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一:普通方式创建Runnable的子类对象</span><br><span class="line">步骤:</span><br><span class="line">1.创建一个类</span><br><span class="line">2.使其实现Runnable接口</span><br><span class="line">3.重写run方法</span><br><span class="line">4.创建该类对象</span><br><span class="line">5.在创建线程对象时传入该类对象(线程任务对象)</span><br><span class="line"></span><br><span class="line">方式二:</span><br><span class="line">使用匿名内部类创建Runnable的子类对象</span><br><span class="line">步骤:</span><br><span class="line">1.Runnable 对象名 = new Runnable()&#123;</span><br><span class="line">重写run方法</span><br><span class="line">&#125;;</span><br><span class="line">2.创建线程对象时传入该类对象(线程任务对象)</span><br></pre></td></tr></table></figure><h3 id="5-线程使用"><a href="#5-线程使用" class="headerlink" title="5.线程使用"></a>5.线程使用</h3><h5 id="5-线程的启动"><a href="#5-线程的启动" class="headerlink" title="5.线程的启动"></a>5.线程的启动</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程对象.start();</span><br><span class="line">注意:</span><br><span class="line">1.当线程启动后会开启新的执行路径,执行run方法中的代码</span><br><span class="line">2.如果直接使用线程对象调用run方法,不会开启新的执行路径</span><br></pre></td></tr></table></figure><h5 id="6-线程的销毁"><a href="#6-线程的销毁" class="headerlink" title="6.线程的销毁"></a>6.线程的销毁</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程已经启动,无法控制,需要等待执行完run方法中的代码</span><br></pre></td></tr></table></figure><h5 id="7-获取当前线程对象"><a href="#7-获取当前线程对象" class="headerlink" title="7.获取当前线程对象"></a>7.获取当前线程对象</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread.currentThread();</span><br></pre></td></tr></table></figure><h5 id="8-线程名城"><a href="#8-线程名城" class="headerlink" title="8.线程名城"></a>8.线程名城</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取线程名称:</span><br><span class="line">线程对象.getName();</span><br><span class="line">修改线程名称</span><br><span class="line">线程对象.setName(name);</span><br><span class="line">注意:在启动前修改</span><br></pre></td></tr></table></figure><h5 id="9-线程优先级"><a href="#9-线程优先级" class="headerlink" title="9.线程优先级"></a>9.线程优先级</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:提高线程抢夺到CPU执行权的概率</span><br><span class="line"></span><br><span class="line">语法:</span><br><span class="line">线程对象.setPriority(int);</span><br><span class="line">注意:</span><br><span class="line">1.取值范围1-10;</span><br><span class="line">2.必须在线程启动前</span><br></pre></td></tr></table></figure><h5 id="10-线程休眠"><a href="#10-线程休眠" class="headerlink" title="10.线程休眠"></a>10.线程休眠</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:让线程暂时停止运行</span><br><span class="line">方法:</span><br><span class="line">static void sleep(休眠时间);</span><br><span class="line">注意:</span><br><span class="line">1.单位毫秒</span><br><span class="line">2.使用类调用,使当前线程休眠</span><br><span class="line">3.线程休眠期间不会抢夺CPU执行权</span><br></pre></td></tr></table></figure><h5 id="11-线程礼让"><a href="#11-线程礼让" class="headerlink" title="11.线程礼让"></a>11.线程礼让</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:将获取道德cpu执行权让出,重新参与抢夺</span><br><span class="line">方法:</span><br><span class="line">static native void yield();</span><br></pre></td></tr></table></figure><h5 id="12-线程合并"><a href="#12-线程合并" class="headerlink" title="12.线程合并"></a>12.线程合并</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:合并线程</span><br><span class="line">方法:</span><br><span class="line">public final void join();</span><br></pre></td></tr></table></figure><h5 id="13-守护线程"><a href="#13-守护线程" class="headerlink" title="13.守护线程"></a>13.守护线程</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有名:后台线程</span><br><span class="line">特点:当一个进程中有前台线程存活,此时该进程就不会被系统回收</span><br><span class="line">如果一个进程中只剩余后台线程,此时不管后台线程中的代码是否运行完毕,系统都将回收该进程</span><br><span class="line">方法:</span><br><span class="line">public final void setDaemon(boolean on);</span><br><span class="line">true:表示守护线程,默认为false,表示前台线程</span><br><span class="line">注意:</span><br><span class="line">1.创建线程对象与主线程默认为前台线程</span><br><span class="line">2.必须在线程启动前</span><br></pre></td></tr></table></figure><h3 id="6-线程的生命周期"><a href="#6-线程的生命周期" class="headerlink" title="6.线程的生命周期"></a>6.线程的生命周期</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程可以处于以下状态之一</span><br><span class="line"></span><br><span class="line">1. NEW: 尚未启动的线程处于此状态</span><br><span class="line">2. RUNNABLE:在java虚拟机中执行的线程处于此状态；内部会分为ready和running两部分，执行哪一个由调度器决定</span><br><span class="line">3. BLOCKED: 被阻塞等待监视器锁定的线程处于此状态</span><br><span class="line">4. WAITING ：正在等待另一个线程执行特定动作的线程处于此状态</span><br><span class="line">5. TIMED_WAITING :正在等待另一个线程执行动作达到指定等待时间的线程处于此状态（超时等待）</span><br><span class="line">6. TERMINATED:一退出的线程出于此状态</span><br></pre></td></tr></table></figure><p><img src="C:\Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230418171549456.png" alt="image-20230418171549456"></p><h3 id="7-Thread和Runnable的区别"><a href="#7-Thread和Runnable的区别" class="headerlink" title="7.Thread和Runnable的区别"></a>7.Thread和Runnable的区别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 从java设计来看，通过继承Thread或者实现Runnable接口来创建线程本质上没有区别，从jdk帮助文档我们可以见到Tread类本身就实现了Runnable接口</span><br><span class="line">2. 实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制</span><br></pre></td></tr></table></figure><h3 id="8-线程安全问题"><a href="#8-线程安全问题" class="headerlink" title="8.线程安全问题"></a>8.线程安全问题</h3><h5 id="原因"><a href="#原因" class="headerlink" title="原因:"></a>原因:</h5><p>多个线程操作同一数据,会导致线程安全问题</p><h5 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h5><p>保证同时只能有一个线程操作该数据</p><h5 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方案一:同步代码块</span><br><span class="line">语法:</span><br><span class="line">synchronized(锁对象)&#123;</span><br><span class="line">要同步的代码</span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">1.所有对象都可以作为锁对象</span><br><span class="line">    2.多个线程的锁对象要是同一个对象</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方案二:同步方法</span><br><span class="line">语法:</span><br><span class="line">访问权限修饰符 synchronized 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">    1.同步方法法人锁对象是this</span><br><span class="line">    2.多个线程的锁对象要是同一个对象</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方案三:同步静态方法</span><br><span class="line">语法:</span><br><span class="line">访问权限修饰符 synchronized static 返回值类型 方法名(形参列表)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">注意:</span><br><span class="line">    1.同步静态方法的锁对象是该类的对象</span><br><span class="line">    类对象:当JVM加载类时.会产生一个对象,该对象就是该类的类对象,一个类只有一个类对象</span><br><span class="line">    2.多个线程的锁对象要是同一个对象</span><br></pre></td></tr></table></figure><h3 id="9-死锁"><a href="#9-死锁" class="headerlink" title="9.死锁"></a>9.死锁</h3><h5 id="原因-1"><a href="#原因-1" class="headerlink" title="原因:"></a>原因:</h5><p>多个线程互相持有对方所需的锁资源</p><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">线程<span class="number">1</span>:</span><br><span class="line">xxx</span><br><span class="line"><span class="title function_">synchronized</span> <span class="params">(A)</span>&#123;</span><br><span class="line">xxx</span><br><span class="line"><span class="title function_">synchronized</span> <span class="params">(B)</span>&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">线程<span class="number">2</span>:</span><br><span class="line">xxx</span><br><span class="line"><span class="title function_">synchronized</span> <span class="params">(B)</span>&#123;</span><br><span class="line">xxx</span><br><span class="line"><span class="title function_">synchronized</span> <span class="params">(A)</span>&#123;</span><br><span class="line">xxx</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>避免思路</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不要在同步中使用</span><br></pre></td></tr></table></figure><h3 id="10-线程间通讯"><a href="#10-线程间通讯" class="headerlink" title="10.线程间通讯"></a>10.线程间通讯</h3><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.线程间通讯的方法是由Object提供的</span><br><span class="line">2.只能在同步中使用</span><br><span class="line">3.只能使用所在的同步的锁对象调用</span><br></pre></td></tr></table></figure><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">唤醒线程</span><br><span class="line">notify():随机唤醒一个</span><br><span class="line">notifyAll():唤醒所有</span><br><span class="line">注意:只能唤醒以同一个对象调用wait方法的线程</span><br><span class="line"></span><br><span class="line">线程休眠:</span><br><span class="line">wait() 无限休眠</span><br><span class="line">wait(int ms) 有限期休眠(休眠ms毫秒)</span><br><span class="line">wait(int ms,int ns)有限期休眠</span><br><span class="line">注意:</span><br><span class="line">ms为毫秒,ns为纳秒</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="11-wait和sleep的区别"><a href="#11-wait和sleep的区别" class="headerlink" title="11.wait和sleep的区别"></a>11.wait和sleep的区别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.wait在休眠期会释放所持有的锁资源,sleep不会</span><br><span class="line">2.wait必须在同步使用,sleep没有限制</span><br><span class="line">3.wait必须使用所在的同步锁对象调用,sleep使用Thread类或者Thread类的对象调用</span><br><span class="line">4.wait由Object提供,sleep由Thread类提供</span><br></pre></td></tr></table></figure><h3 id="13-线程池"><a href="#13-线程池" class="headerlink" title="13.线程池"></a>13.线程池</h3><h5 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h5><p>​优化线程</p><h5 id="原因-2"><a href="#原因-2" class="headerlink" title="原因:"></a>原因:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个线程大约占1MB的运行内存</span><br><span class="line">大量创建线程时可能会导致内存溢出</span><br><span class="line">大量的创建线程也导致需要对象线程频繁的创建与回收</span><br></pre></td></tr></table></figure><h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.使用空闲的线程执行新的任务(线程复用)</span><br><span class="line">2.使用一个容器来管理线程的创建,回收,复用等</span><br><span class="line">注意:java中提出线程池来完成以上操作</span><br></pre></td></tr></table></figure><h5 id="线程池的体系结构"><a href="#线程池的体系结构" class="headerlink" title="线程池的体系结构"></a>线程池的体系结构</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Executor(接口)</span><br><span class="line">提供的方法:</span><br><span class="line">void execute(Runnable command);</span><br><span class="line">作用:执行线程任务,子接口提供了submit优于该方法</span><br><span class="line">子类或子接口</span><br><span class="line">    ExecutorService(接口)</span><br><span class="line">    提供的方法:</span><br><span class="line">    void shutdown();</span><br><span class="line">    作用:关闭线程池</span><br><span class="line">    boolean isShutdown();</span><br><span class="line">    作用:判断线程池是否关闭</span><br><span class="line">    Future&lt;T&gt; submit(线程任务)</span><br><span class="line">    作用:提交线程任务</span><br><span class="line">    子类或子接口:</span><br><span class="line">            ScheduledExecutorService(接口)</span><br><span class="line">            ThreadPoolExecutor(类)</span><br><span class="line">            构造函数:</span><br><span class="line">            public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">            int maxmumPoolSize,</span><br><span class="line">            long keepAliveTime,</span><br><span class="line">            TimeUnit unit,</span><br><span class="line">            BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">            ThreadFactory threadFactory,</span><br><span class="line">            RejectedExecutionHandler handler)</span><br><span class="line">            </span><br><span class="line">            corePoolSize:h核心线程数,线程池中最少有几个线程</span><br><span class="line">                    maximumPoolSize:最大线程数,线程中最多可以容纳的线程数</span><br><span class="line">                    keepAliveTime:销毁时间,当线程执行完任务后,多久销毁</span><br><span class="line">                    until:时间单位</span><br><span class="line">                    workQueue:存储执行的线程任务的集合(队列形式)</span><br><span class="line">                    threadFactory:创建线程</span><br><span class="line">                    handler:优化线程,使其线程复用的算法</span><br></pre></td></tr></table></figure><h5 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:创建线程池</span><br><span class="line">原因:应为ThreadPoolExecutor过于麻烦,所以JDK提供该类帮助我们创建线程池提供的方法</span><br><span class="line"></span><br><span class="line">1.固定线程池</span><br><span class="line">特点:线程池中的线程数量恒定,当线程任务小于线程数量时,随机在线程池中挑选线程执行任务,当线程任务大于线程数量,会先执行前面的任务,后等前面任务执行完毕后,使用执行完毕的线程,执行剩余任务.</span><br><span class="line">    static ExecutorService newFixedThreadPool(int nThreads)</span><br><span class="line">    nThreads:线程池中线程的数量</span><br><span class="line">    </span><br><span class="line">    2.可变线程池</span><br><span class="line">    特点:线程池中的线程数量可变</span><br><span class="line">    static ExecutorService newCachedThreadPool()</span><br><span class="line">    </span><br><span class="line">    3.单例线程池</span><br><span class="line">    特点:一个线程池只有一个线程</span><br><span class="line">    static ExecutorService newSingleThreadExecutor()</span><br><span class="line">    </span><br><span class="line">    4.抢占线程池</span><br><span class="line">    static ExecutorService newWorkStealingPool()</span><br><span class="line">    </span><br><span class="line">    5.调度线程池</span><br><span class="line">    特点:该线程池执行任务可以延迟,也可以延迟重复执行</span><br><span class="line">    static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</span><br><span class="line">    corePoolSize:线程池中线程的数量</span><br><span class="line">    </span><br><span class="line">    6.单例调度线程池</span><br><span class="line">    特点:调度线程池中只有一个线程</span><br><span class="line">    static ScheduledExecutorService newSingleThreadScheduledExecutor();</span><br></pre></td></tr></table></figure><h5 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">步骤:</span><br><span class="line">1.创建线程池</span><br><span class="line">2.提交任务</span><br><span class="line">3.关闭线程池</span><br></pre></td></tr></table></figure><h5 id="调度线程池-ScheduledExecutorService"><a href="#调度线程池-ScheduledExecutorService" class="headerlink" title="调度线程池:ScheduledExecutorService"></a>调度线程池:ScheduledExecutorService</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提供的方法:</span><br><span class="line">public ScheduledFuture&lt;?&gt; schedule(线程任务,long delay,TimeUnit unit)</span><br><span class="line">作用:延迟执行   </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command</span><br><span class="line">long initialDelay</span><br><span class="line">long period</span><br><span class="line">TimeUnit unit);</span><br><span class="line">作用:延迟重复执行</span><br><span class="line">    1参,执行的任务</span><br><span class="line">    2参,延迟时间</span><br><span class="line">    3参,间隔时间 = 本次任务开始时间 - 上次任务开始时间</span><br><span class="line">    注意:如果上次任务执行时间&gt;间隔时间,那么当上次任务执行完毕后,本次任务直接开始</span><br><span class="line">   4参,时间单位</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ScheduledFuture&lt;?&gt; scheduleWithFixedDaley(Runnable command,</span><br><span class="line">long initialDelay</span><br><span class="line">long delay</span><br><span class="line">TimeUnit unit);</span><br><span class="line">作用:延迟重复执行</span><br><span class="line">    1参,执行任务</span><br><span class="line">    2参,延迟时间</span><br><span class="line">    3参,间隔时间= 本次任务开始时间-上次任务结束时间</span><br><span class="line">    4时间单位</span><br></pre></td></tr></table></figure><h3 id="14-Callable"><a href="#14-Callable" class="headerlink" title="14.Callable"></a>14.Callable</h3><p>作用:有返回值的线程任务对象</p><p>注意:无法在创建Thread对象时传入,必须配合线程池使用</p><h3 id="15-Lock"><a href="#15-Lock" class="headerlink" title="15.Lock"></a>15.Lock</h3><p>作用:简化同步</p><h5 id="同步"><a href="#同步" class="headerlink" title="同步:"></a>同步:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同步代码块</span><br><span class="line">synchronize(锁对象)&#123;</span><br><span class="line">//关锁</span><br><span class="line">代码</span><br><span class="line">//开锁</span><br><span class="line">&#125;</span><br><span class="line">同步方法</span><br><span class="line">访问权限修饰符 synchronize 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">//关锁</span><br><span class="line">方法</span><br><span class="line">//开锁</span><br><span class="line">&#125;</span><br><span class="line">同步静态方法</span><br><span class="line">访问权限修饰符 synchronize static 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">//关锁</span><br><span class="line">方法</span><br><span class="line">//开锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="lock体系"><a href="#lock体系" class="headerlink" title="lock体系"></a>lock体系</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lock</span><br><span class="line">提供的方法:</span><br><span class="line">void lock():关锁</span><br><span class="line">void unLock():开锁</span><br><span class="line"></span><br><span class="line">Condition newCondition():获取锁对象</span><br><span class="line">void await():无限期休眠</span><br><span class="line">void signal():随机唤醒一个</span><br><span class="line">void signalAll():唤醒所有</span><br><span class="line">子类:</span><br><span class="line">ReentrantLock</span><br><span class="line"></span><br><span class="line">ReadWriteLock</span><br><span class="line">提供的方法:</span><br><span class="line">Lock readLock():获取读锁</span><br><span class="line">Lock writeLock():获取写锁</span><br><span class="line">注意:</span><br><span class="line">读-写互斥</span><br><span class="line">读-读 不互斥</span><br><span class="line">写-写互斥</span><br><span class="line">子类</span><br><span class="line">ReentrantReadWriteLock</span><br></pre></td></tr></table></figure><h1 id="二十六-x2F-设计模式"><a href="#二十六-x2F-设计模式" class="headerlink" title="二十六&#x2F;设计模式"></a>二十六&#x2F;设计模式</h1><p>作用:解决特定问题的思路</p><h3 id="1-生成者与消费者"><a href="#1-生成者与消费者" class="headerlink" title="1.生成者与消费者"></a>1.生成者与消费者</h3><p>1.生产者消费者模式解决进销存业务</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">生产</span><br><span class="line">无限生产</span><br><span class="line">销售</span><br><span class="line">无限销售</span><br><span class="line">工厂</span><br><span class="line">生产的方法</span><br><span class="line">出货的方法</span><br><span class="line">库存数量</span><br><span class="line">商品数量上限:100</span><br><span class="line">商品数量下限:0</span><br></pre></td></tr></table></figure><h3 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2.单例模式"></a>2.单例模式</h3><p>解决的问题</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个类只能有一个对象</span><br></pre></td></tr></table></figure><p>分类</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">懒汉式</span><br><span class="line">步骤:</span><br><span class="line">1,私有化构造函数</span><br><span class="line">2,提供一个公共的属性,记录该类的唯一对象</span><br><span class="line">3,提供一个公共的静态方法返回该类创建好的对象</span><br><span class="line">优点:</span><br><span class="line">节省内存</span><br><span class="line">缺点:</span><br><span class="line">有线程安全问题</span><br><span class="line">饿汉式</span><br><span class="line">步骤:</span><br><span class="line">1,私有化构造函数</span><br><span class="line">2,提供一个公共的属性,记录该类的唯一对象,并创建该对象</span><br><span class="line">3,提供一个公共的静态方法返回该类创建好的对象</span><br><span class="line">优点:</span><br><span class="line">不存在线程安全问题</span><br><span class="line">缺点:</span><br><span class="line">浪费内存</span><br><span class="line"></span><br><span class="line">线程安全的懒汉式</span><br><span class="line">代码:</span><br><span class="line">public class C &#123;</span><br><span class="line">       private static C c;</span><br><span class="line">       private C()&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       public synchronized C getInstance()&#123;</span><br><span class="line">           if (c == null)&#123;</span><br><span class="line">               c = new C();</span><br><span class="line">           &#125;</span><br><span class="line">           return c;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">优点:</span><br><span class="line">线程安全</span><br><span class="line">缺点:</span><br><span class="line">效率慢</span><br><span class="line"></span><br><span class="line">内部类饿汉式</span><br><span class="line">代码:</span><br><span class="line">   public class D &#123;</span><br><span class="line">       private D()&#123;</span><br><span class="line">       &#125;</span><br><span class="line">       public static D getInstance()&#123;</span><br><span class="line">           return InClass.getD();</span><br><span class="line">       &#125;</span><br><span class="line">       static class InClass&#123;</span><br><span class="line">           private static D d = new D();</span><br><span class="line">           public static D getD()&#123;</span><br><span class="line">               return d;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="3-工程模式"><a href="#3-工程模式" class="headerlink" title="3.工程模式"></a>3.工程模式</h3><p><strong>解决问题</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特定编号生产特定商品</span><br></pre></td></tr></table></figure><pre><code>家具厂    沙发    椅子    床    衣柜    茶几    ...分析:    类        家具厂类            家具接口对象 生产的方法(编号)&#123;                switch(编号)&#123;                    case 1:            &#125;        &#125;    家具接口    沙发类 实现 家具接口    椅子类 实现 家具接口    床类 实现 家具接口    衣柜类 实现 家具接口    茶几类 实现 家具接口</code></pre><h1 id="二十七-IO流"><a href="#二十七-IO流" class="headerlink" title="二十七.IO流"></a>二十七.IO流</h1><h3 id="1-作用-5"><a href="#1-作用-5" class="headerlink" title="1.作用"></a>1.作用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传输数据</span><br></pre></td></tr></table></figure><h3 id="2-分类-1"><a href="#2-分类-1" class="headerlink" title="2.分类"></a>2.分类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按照流向分类</span><br><span class="line">输入流</span><br><span class="line">输出流</span><br><span class="line"></span><br><span class="line">按照传输的最小数据单位分类</span><br><span class="line">字节流</span><br><span class="line">最小单位:byte</span><br><span class="line">字符流</span><br><span class="line">    最小单位char</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   按照功能分类</span><br><span class="line">   节点流:</span><br><span class="line">   从数据源到程序,或从程序直接到数据源</span><br><span class="line">   包装流(过滤流)</span><br><span class="line">        在节点流的基础上增强功能</span><br><span class="line">        注意:所有的包装流都使用了装饰者模式</span><br></pre></td></tr></table></figure><h3 id="3-字节流"><a href="#3-字节流" class="headerlink" title="3.字节流"></a>3.字节流</h3><p>体系结构:</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InputStream(字节输入流顶级接口)</span><br><span class="line">方法:</span><br><span class="line">int read();一次读取一个字节,返回值为读取到的字节</span><br><span class="line">int read(byte b[]):一次读取一组字节数据到数组B中,返回值为读取到的字节长度,当返回值为-1时表示读取结束</span><br><span class="line">int read(byte[],int off,int len);一次读取一组字节数据到数组b中,从off位置开始存储,存储len个字节</span><br><span class="line">返回值为读取到的字节长度,当返回值为-1时表示读取结束</span><br><span class="line"></span><br><span class="line">void close(); 关闭流对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-1-OutputStream-字节输出流顶级接口"><a href="#3-1-OutputStream-字节输出流顶级接口" class="headerlink" title="3.1.OutputStream(字节输出流顶级接口)"></a>3.1.OutputStream(字节输出流顶级接口)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法:</span><br><span class="line">void write(int b);一次写入一个字节</span><br><span class="line">void write(byte b[]);一次写入一组字节</span><br><span class="line">void write(byte b[],int off,int len);一次写入一组字节,从off位置开始,写入len</span><br><span class="line">void flush():冲刷</span><br><span class="line">void close();关流</span><br></pre></td></tr></table></figure><h4 id="3-2文件字节流"><a href="#3-2文件字节流" class="headerlink" title="3.2文件字节流"></a>3.2文件字节流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FileInputStream</span><br><span class="line">分类:</span><br><span class="line">输入流:文件到程序</span><br><span class="line">节点流</span><br><span class="line">FileOutputStream</span><br><span class="line">分类:</span><br><span class="line">输出流:程序到文件</span><br><span class="line">节点流</span><br></pre></td></tr></table></figure><h4 id="3-3内存流"><a href="#3-3内存流" class="headerlink" title="3.3内存流"></a>3.3内存流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:在读取数据过程中,因数据不全导致的乱码问题</span><br><span class="line">ByteArrayInputStream</span><br><span class="line">ByteArrayOutputStream</span><br><span class="line">特有方法:</span><br><span class="line">byte toByteArray();将内存流中的数据获取出来</span><br></pre></td></tr></table></figure><h4 id="3-4缓冲流"><a href="#3-4缓冲流" class="headerlink" title="3.4缓冲流"></a>3.4缓冲流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:提高读写效率</span><br><span class="line">注意:</span><br><span class="line">包装流</span><br><span class="line">BufferedInputStream</span><br><span class="line">BufferedOutputStream</span><br><span class="line"></span><br><span class="line">注意:默认缓冲区大小为8kb</span><br></pre></td></tr></table></figure><h4 id="3-5对象流"><a href="#3-5对象流" class="headerlink" title="3.5对象流"></a>3.5对象流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:将对象写入到文件中,或从文件中读取对象</span><br><span class="line">注意:</span><br><span class="line">1.读写的对象所属的类要实现序列化接口</span><br><span class="line">2.一个对象流只能读写一个对象</span><br><span class="line">3.存储的所有数据都必须进行序列化</span><br><span class="line">4.static修饰的属性,transient修饰的属性不参与序列化</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ObjectInputStream</span><br><span class="line">readObject():读取对象,只读第一个</span><br><span class="line">ObjectOutputStream</span><br><span class="line">wirteObject();写入对象</span><br></pre></td></tr></table></figure><h3 id="4-字符流"><a href="#4-字符流" class="headerlink" title="4.字符流"></a>4.字符流</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传输的数据单位最小为字符(char)</span><br></pre></td></tr></table></figure><h4 id="字符流体系"><a href="#字符流体系" class="headerlink" title="字符流体系"></a>字符流体系</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reader</span><br><span class="line">概念:所有字符输入流的父类</span><br><span class="line">提供方法:</span><br><span class="line">int read(),一次获取一个字符,返回值为读取到的字符.</span><br><span class="line">int read(char c[]):一次去取一组字符到数组c中,返回值为读取到的字符长度,当为-1时表示读取结束</span><br><span class="line">int read(char c[],int off,int len)</span><br><span class="line">一次去取一组字符到数组c中,从off位置开始存储,存储len个,返回值为读取到的字符长度,当为-1时别是读取结束</span><br><span class="line">void close() 关闭</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wirter</span><br><span class="line">概念:所有字符输出流的父类</span><br><span class="line">提供的方法:</span><br><span class="line">void write(int c)</span><br><span class="line">void write(char cbuf[])</span><br><span class="line">void write(char cbuf[],int off,int len)</span><br><span class="line">void write(String str)</span><br><span class="line">void flush()</span><br><span class="line">void close()</span><br></pre></td></tr></table></figure><h4 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FileReader</span><br><span class="line">FileWriter</span><br></pre></td></tr></table></figure><h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BufferedReader</span><br><span class="line">readLine();读取一行</span><br><span class="line">BufferedWriter</span><br><span class="line">nextLine():写入下一行</span><br></pre></td></tr></table></figure><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InputStreamReader</span><br><span class="line">OutputStreamWriter</span><br></pre></td></tr></table></figure><h4 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PrintStream</span><br><span class="line">注意:字节流</span><br></pre></td></tr></table></figure><h3 id="5-File"><a href="#5-File" class="headerlink" title="5.File"></a>5.File</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念:文件或文件夹对应的类</span><br></pre></td></tr></table></figure><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建File类的对象</span><br><span class="line">2.调用属性或方法</span><br></pre></td></tr></table></figure><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">公共构造函数</span><br><span class="line">File(String pathname)</span><br><span class="line">pathname:文件或文件夹的路径</span><br><span class="line">File(String parent,String child)</span><br><span class="line">    parent:上级文件夹的路径</span><br><span class="line">    child:当前文件的名称.后缀名</span><br><span class="line">    File(File parent,String child)</span><br><span class="line">    parent:上级文件夹的file对象</span><br><span class="line">    child:当前文件的名称.后缀名</span><br><span class="line">    </span><br><span class="line">    File(URI uri)</span><br><span class="line">    uri:资源所在位置</span><br><span class="line">    如:</span><br><span class="line">    URI uri = URI.create(&quot;D:\\a.txt&quot;);</span><br><span class="line">    File file = new File(uri);</span><br><span class="line">  </span><br><span class="line">  注意:</span><br><span class="line">  路径分为绝对路径和相对路径</span><br><span class="line">  绝对路径:从盘符开始</span><br><span class="line">  相对路径:相对于项目路径下</span><br><span class="line">  注意:</span><br><span class="line">  . 当前路径</span><br><span class="line">  ..上级文件夹</span><br></pre></td></tr></table></figure><h4 id="属性"><a href="#属性" class="headerlink" title="属性:"></a>属性:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static separator:获取当前系统的路径分隔符</span><br></pre></td></tr></table></figure><h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir():创建一级文件夹</span><br><span class="line">mkdirs():创建多级文件夹</span><br><span class="line">createNewFile():创建一级文件</span><br><span class="line"></span><br><span class="line">delete():删除一级文件或一级文件夹</span><br><span class="line"></span><br><span class="line">getParent():获取上级文件夹路径</span><br><span class="line">getParentFile():获取上级文件夹的file对象</span><br><span class="line"></span><br><span class="line">getPath():获取当前路径</span><br><span class="line">getAbsolutePath():获取当前文件的绝对路径</span><br><span class="line">getAbsoluteFile():获取绝对路径文件</span><br><span class="line">isDirectory():判断是否为文件夹</span><br><span class="line">isFile()判断是否为文件</span><br><span class="line">exists():判断文件或文件夹是否存在</span><br><span class="line">length():获取文件大小,单位字节</span><br><span class="line">renameTo():修改文件名称</span><br><span class="line"></span><br><span class="line">File[] listFiles();</span><br><span class="line">File[] listFiles(FileFilter ff);</span><br><span class="line">File[] listFiles(FilenameFilter ff);</span><br><span class="line">获取当前文件夹下的文件或文件夹</span><br><span class="line">注意:</span><br><span class="line">FileFilter是文件过滤器</span><br><span class="line">重写的是boolean accept(File pathname)</span><br><span class="line">当返回值为true表示可以通过,反之false不通过</span><br><span class="line"></span><br><span class="line">FilenameFilter文件名称过滤器</span><br><span class="line">重写的是boolean accept(File f , String name)</span><br><span class="line">当返回值为true表示可以通过,反之false不通过</span><br><span class="line">f:父级文件对象</span><br><span class="line">name:当前文件名称</span><br></pre></td></tr></table></figure><h1 id="二十八-网络编程"><a href="#二十八-网络编程" class="headerlink" title="二十八.网络编程"></a>二十八.网络编程</h1><h3 id="1-网络相关概念"><a href="#1-网络相关概念" class="headerlink" title="1.网络相关概念"></a>1.网络相关概念</h3><p><strong>概念</strong>:两台设备之间通过网络实现数据通信</p><p><strong>网络通信</strong>:将数据通过网络从一台设备传输到另一台设备</p><p>java.net包提供了一系列的类或接口,供程序员使用,完成网络通信</p><h4 id="常用名词"><a href="#常用名词" class="headerlink" title="常用名词"></a>常用名词</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">互联网(Internet):点与点相连</span><br><span class="line">万维网(www):端与端相连</span><br><span class="line">物联网:物物互联</span><br><span class="line">网络编程:让计算机与计算机之间建立连接.</span><br></pre></td></tr></table></figure><h3 id="2-OSI网络架构"><a href="#2-OSI网络架构" class="headerlink" title="2.OSI网络架构"></a>2.OSI网络架构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简介</span><br><span class="line">open System Interconnect开放式系统互联</span><br><span class="line">存在于概念和理论上的一种模型,他的缺点是分层太多,增加了网络工作的复杂性,所以没有大规模应用</span><br></pre></td></tr></table></figure><p><img src="C:\Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230424171347594.png" alt="image-20230424171347594"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一层:物理层为设备之间的数据通信提供传输信号和物理介质(双绞线,光导纤维)</span><br><span class="line">作用:建立/维护/断开物理连接.</span><br><span class="line"></span><br><span class="line">第二层:链路层在物理层上,通过规程或协议(差错控制)来控制传输数据的正确性(MAC)</span><br><span class="line">作用:接受来自物理层的位流形式的数据,并封装成帧,传送到上一层,同样,也将来自上层的数据帧,拆装为位流形式的数据转发到物理层,并且还负责处理接收端发回的确认帧的信息,以便提供可靠的数据传输</span><br><span class="line"></span><br><span class="line">第三层:网络层负责定义了能够标识所有网络节点的逻辑地址(IP地址)</span><br><span class="line">作用:逻辑寻址,Ip地址,在下两层的基础上向资源子网提供服务</span><br><span class="line"></span><br><span class="line">第四层:传输层负责是否选择差错回复协议,数据流重用,错误顺序排序(tcp,udp)</span><br><span class="line">作用:提供可靠的和不可靠的传输机制TCP/UDP</span><br><span class="line"></span><br><span class="line">第五层:会话层负责使应用建立和维持会话,使通信在失败时继续恢复通信(断电续传)</span><br><span class="line">作用:建立/终止/管理实体间会话连接</span><br><span class="line"></span><br><span class="line">第六层:表示层负责定义转换数据格式及加密,允许选择以二进制或ASCII格式传输</span><br><span class="line">作用:分装数据格式(加密解密,压缩解压缩)</span><br><span class="line"></span><br><span class="line">第七层:应用层负责文件访问和管理/可靠运输服务,远程操作服务(HTTP/FTP/SMTP)</span><br><span class="line">作用:人与机器电脑交互的窗口</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-IP地址"><a href="#3-IP地址" class="headerlink" title="3.IP地址"></a>3.IP地址</h3><h4 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址:"></a>ip地址:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.概念:用于标识网络中的每台计算机/主机</span><br><span class="line">2.查看ip地址:ipconfig</span><br><span class="line">3.ip地址的表现形式:点分十进制  xx.xx.xx.xx</span><br><span class="line">4.每一个十进制的范围是0-255</span><br><span class="line">5.IP地址的组成= 网络地址+主机地址</span><br><span class="line">6.ipv6是互联网工程任务组设计的用于代替ipv4的下一代ip协议，其地址数量号称可以为全世界每一粒沙子编上一个地址</span><br><span class="line">7.由于ipv4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。ipv6的使用，不仅解决了网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍</span><br></pre></td></tr></table></figure><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.www.baidu.com</span><br><span class="line">2.好处:方便记忆,解决记忆ip的困难</span><br><span class="line">3.概念:将ip地址映射成域名</span><br></pre></td></tr></table></figure><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.概念:用于标识计算机上某个特定的网络程序</span><br><span class="line">2.表现形式:以整数形式,范围0-65535</span><br><span class="line">3.0-1024已经被占用,比如:ssh 22, ftp 21,smtp 25,http 80</span><br><span class="line">4.常见的网络端口号</span><br><span class="line">tomcat:8080</span><br><span class="line">musql:3306</span><br><span class="line">oracle:1521</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-通信协议"><a href="#4-通信协议" class="headerlink" title="4.通信协议"></a>4.通信协议</h3><h4 id="TCP-x2F-IP网络框架"><a href="#TCP-x2F-IP网络框架" class="headerlink" title="TCP&#x2F;IP网络框架"></a>TCP&#x2F;IP网络框架</h4><p><img src="C:\Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230424174928746.png" alt="image-20230424174928746"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP协议:传输控制协议</span><br><span class="line">是一种面向连接的/可靠的/基于字节流的传输层通信协议.数据大小无限制.建立连接的过程需要三次握手,断开连接的过程需要四次挥手,  在连接中可进行大数据量的传输；传输完毕，需释放已建立的连接，效率低。</span><br><span class="line"></span><br><span class="line">UDP协议:用户数据报协议</span><br><span class="line">是一种无连接的传输层协议,提供面向事物的简单不可靠信息传送服务,每个包的大小64kb,因无需连接，故是不可靠的；发送数据结束时无需释放资源（因为不是面向连接的），速度快；</span><br></pre></td></tr></table></figure><h3 id="5-InetAddress"><a href="#5-InetAddress" class="headerlink" title="5.InetAddress"></a>5.InetAddress</h3><p><strong>功能:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.获取本机InetAddress对象,getLocalHost</span><br><span class="line">2.根据指定主机名/域名获取IP地址对象,getByName</span><br><span class="line">3.获取InetAddress对象的主机名getHostNmae</span><br><span class="line">4.获取InetAddress对象的地址getHostAddress</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取主机名+ip地址</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">System.out.println(localHost);</span><br><span class="line"><span class="comment">//获取主机名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">hostName</span> <span class="operator">=</span> localHost.getHostName();</span><br><span class="line">System.out.println(hostName);</span><br><span class="line"></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">byName</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;DESKTOP-HT1OC9N&quot;</span>);</span><br><span class="line">System.out.println(byName);</span><br></pre></td></tr></table></figure><h3 id="6-Socket编程"><a href="#6-Socket编程" class="headerlink" title="6.Socket编程"></a>6.Socket编程</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socket:套接字,网络中的一个节点</span><br><span class="line">通讯要求:地址+端口号</span><br></pre></td></tr></table></figure><h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP:面向有连接,安全可靠的,速度慢</span><br><span class="line">特点:三次握手,四次挥手</span><br><span class="line"></span><br><span class="line">UDP:面向无连接,不安全,速度快</span><br></pre></td></tr></table></figure><h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简介:是一种面向连接的/可靠的/基于字节流的传输层通信协议,数据大小无限制,建立连接过程需要三次握手,断开连接的过程需要四次挥手</span><br><span class="line">注意:分为客户端Socket与服务器ServerSocket</span><br></pre></td></tr></table></figure><h4 id="服务端开发步骤"><a href="#服务端开发步骤" class="headerlink" title="服务端开发步骤"></a>服务端开发步骤</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建ServerSocket,指定端口</span><br><span class="line">2.调用accept等待客户端接入</span><br><span class="line">3.使用输入流,接收客户端请求中的数据</span><br><span class="line">4.使用输出流,给客户端回馈数据(可选)</span><br><span class="line">5.关闭释放资源</span><br></pre></td></tr></table></figure><h4 id="客户端开发步骤"><a href="#客户端开发步骤" class="headerlink" title="客户端开发步骤"></a>客户端开发步骤</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建Socket对象,指定服务器IP+端口</span><br><span class="line">2.使用输出流,发起请求,给服务器发送数据</span><br><span class="line">3.使用输入流,界海服务器返回的数据(可选)</span><br><span class="line">4.关闭释放资源</span><br></pre></td></tr></table></figure><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简介:UDP协议是一种不可靠的网络协议,提供面向事务的简单不可靠信息传送服务,每个包的大小64kb</span><br><span class="line">分为:接收端与发送端</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="发送端开发步骤"><a href="#发送端开发步骤" class="headerlink" title="发送端开发步骤"></a>发送端开发步骤</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建发送端的Socket对象(DatagramSocket)</span><br><span class="line">2.创建数据,并打包</span><br><span class="line">3.调用DatagramSocket对象的方法发送数据</span><br><span class="line">4.关闭发送端</span><br></pre></td></tr></table></figure><h4 id="接收端开发步骤"><a href="#接收端开发步骤" class="headerlink" title="接收端开发步骤"></a>接收端开发步骤</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建发送端Socket(DatagramSocket)</span><br><span class="line">2.创建一个数据包,用于接收数据</span><br><span class="line">3.调用DatagramSocket对象的方法接受数据</span><br><span class="line">4.解析数据包,在控制台显示</span><br><span class="line">5.关闭接收端</span><br></pre></td></tr></table></figure><h1 id="二十九-反射"><a href="#二十九-反射" class="headerlink" title="二十九.反射"></a>二十九.反射</h1><h3 id="1-反射机制"><a href="#1-反射机制" class="headerlink" title="1.反射机制"></a>1.反射机制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息(如成员变量,成员方法,构造器)并能操作对象的属性及方法,反射在设计模式和框架底层都会用到</span><br><span class="line">2.加载完类之后,在堆中就产生了一个class对象(一个类只有一个class对象)这个对象包含了类的完整结构信息,通过这个对象得到类的结构,这个对象就像一面镜子,透过这个镜子看到类的结构,所以称为反射</span><br></pre></td></tr></table></figure><h3 id="2-类对象"><a href="#2-类对象" class="headerlink" title="2.类对象"></a>2.类对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个类被加载时会产生一个对象,该对象称为该类的类对象,该对象属于Class类的对象</span><br><span class="line"></span><br><span class="line">类对象中包含该类的所有信息,如包,实现的接口,类名,属性,方法,构造函数,注解等内容</span><br><span class="line"></span><br><span class="line">注意:一个类只有一个类对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-java反射机制可完成的任务"><a href="#3-java反射机制可完成的任务" class="headerlink" title="3.java反射机制可完成的任务:"></a>3.java反射机制可完成的任务:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.在运算时判断任意一个对象所属的类</span><br><span class="line">2.在运行时构造任意一个类的对象</span><br><span class="line">3.在运行时得到任意一个类所具有的成员变量和方法</span><br><span class="line">4.在运行时调用任意一个对象的成员变量和方法&#x27;</span><br><span class="line">5.生成动态代理</span><br></pre></td></tr></table></figure><h3 id="4-反射相关的主要类"><a href="#4-反射相关的主要类" class="headerlink" title="4.反射相关的主要类"></a>4.反射相关的主要类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. java.lang.Class代表一个类,Class对象表示某个类加载后在堆中的对象</span><br><span class="line">2.java.lang.reflect.Field 代表类的成员变量,Filed对象表示某个类的成员变量//getFiled不能得到私有属性</span><br><span class="line">3.java.lang.reflect.Method 代表类方法,Method对象表示某个类的方法</span><br><span class="line">4.java.lang.reflect.Constructor 代表类的构造方法Constructor对象表示构造器(),括号内可以指定参数类型,String.class</span><br></pre></td></tr></table></figure><h3 id="5-反射的优缺点"><a href="#5-反射的优缺点" class="headerlink" title="5.反射的优缺点"></a>5.反射的优缺点</h3><p>​<strong>优点</strong></p><p>​可以动态的创建和使用对象,使用灵活,没有反射机制,框架技术就失去了底层支撑</p><p>​<strong>缺点</strong></p><p>​使用反射机制基本都是解释执行,对执行速度有影响</p><h3 id="6-如何获取类对象"><a href="#6-如何获取类对象" class="headerlink" title="6.如何获取类对象"></a>6.如何获取类对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式1:类名.class</span><br><span class="line">方式2.对象名.getClass()</span><br><span class="line">方式3:Class.forName(&quot;类的全路径&quot;)</span><br><span class="line">类的全路径:类所属的包名+类名</span><br></pre></td></tr></table></figure><h3 id="7-类对象-Class类"><a href="#7-类对象-Class类" class="headerlink" title="7.类对象(Class类)"></a>7.类对象(Class类)</h3><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Class也是类,因此也继承Object类</span><br><span class="line">2.Class类对象不是new出来的,而是系统创建的</span><br><span class="line">3.对于某个类的Class对象,在内存中只有一份,因为类只加载一次</span><br><span class="line">4.每个类的实例都会记得自己由那个Class实例所生成</span><br><span class="line">5.通过Class可以完整的得到一个类的完整结构,通过一系列API</span><br><span class="line">6.Class对象存放在堆中</span><br><span class="line">7.类的字节码二进制数据,是在方法区的,有的地方称为类的元数据(包括方法代码,变量名,方法名,访问权限)</span><br></pre></td></tr></table></figure><h5 id="提供的方法"><a href="#提供的方法" class="headerlink" title="提供的方法"></a>提供的方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类相关:</span><br><span class="line">包</span><br><span class="line">Pckage getPackage()</span><br><span class="line">类名</span><br><span class="line">    String getSimpleName()</span><br><span class="line">    类的全路径名</span><br><span class="line">    String getName()</span><br><span class="line">    父类的类对象</span><br><span class="line">    Class&lt;? super T&gt; getSuperclass()</span><br><span class="line">    接口的类对象</span><br><span class="line">    Class&lt;?&gt;[] getInterface()</span><br><span class="line">    调用缺省构造函数,返回该Class对象的一个实例</span><br><span class="line">     Object newInstance()</span><br><span class="line">    </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">属性相关</span><br><span class="line">获取所有的公共属性,包含父类提供的公共属性</span><br><span class="line">Field[] getFields();</span><br><span class="line">获取所有的属性,不包含父类提供的</span><br><span class="line">    Field[] getDeclaredField()</span><br><span class="line">    获取指定的公共属性</span><br><span class="line">    Field getField(String name)</span><br><span class="line">    获取指定的属性</span><br><span class="line">    Field getDeclaredField(String name)</span><br><span class="line">    Field提供的方法</span><br><span class="line">    Object get(Object obj);</span><br><span class="line">    作用:获取指定对象的该属性值</span><br><span class="line">    1参:指定对象</span><br><span class="line">    void set(Object obj,Object v)</span><br><span class="line">    作用:修改指定对象的改属性值</span><br><span class="line">    1参:指定的对象</span><br><span class="line">    2参:修改后的值</span><br><span class="line">    setAccessible(boolean flag) 是否略过访问权限修饰符</span><br><span class="line">        默认为false,表示不略过</span><br><span class="line">        当值为true表示略过</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法相关</span><br><span class="line">获取所有的公共方法,包含父类提供的</span><br><span class="line">Method[] getMethods()</span><br><span class="line"></span><br><span class="line">获取所有的方法,不包含父类</span><br><span class="line">Method[] getDeclaredMethods()</span><br><span class="line"></span><br><span class="line">获取单独一个公共的方法</span><br><span class="line">    Method getMethod(String name,Class&lt;?&gt;...parameterTypes)</span><br><span class="line">    1参:要获取的方法名</span><br><span class="line">    2参:该方法的形参列表对应的数据类型的对象</span><br><span class="line">    注意:按顺序书写,基本数据类型的类对象是数据类型.class,其包装类的类对象是类名.class</span><br><span class="line">    </span><br><span class="line">    获取单独一个方法</span><br><span class="line">    Method getDeclaredMethod(Stirng name,Class&lt;?&gt;...parameterTypes)</span><br><span class="line">    1参:要获取的方法名</span><br><span class="line">    2参:该方法的形参列表对应的数据类型的类对象</span><br><span class="line">    注意:按顺序书写,基本数据类型的类对象是数据类型.class,其包装类的类对象是类名.class</span><br><span class="line">    </span><br><span class="line">    Method提供的方法</span><br><span class="line">    Object invoke(Object obj,Object...args)</span><br><span class="line">    作用:执行该方法</span><br><span class="line">    1.执行该方法的对象</span><br><span class="line">    2参:执行该方法所需要的实参列表</span><br><span class="line">    返回值:执行该方法的返回值</span><br><span class="line">    </span><br><span class="line">    setAccessible(boolean flag) 是否略过访问权限修饰符</span><br><span class="line">        默认为false,表示不略过</span><br><span class="line">        当值为true表示略过</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造函数相关</span><br><span class="line">Constructor&lt;?&gt;[] getConstructors()</span><br><span class="line">作用:获取该类中所有的公共构造函数</span><br><span class="line"></span><br><span class="line">Constructor&lt;?&gt;[] getDeclaredConstructors()</span><br><span class="line">    作用:获取所有的构造函数</span><br><span class="line">    </span><br><span class="line">    Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;...parameterTypes)</span><br><span class="line">    作用:获取指定的一个构造函数</span><br><span class="line">    参数:构造函数对比的形参列表的数据类型的类对象</span><br><span class="line">    </span><br><span class="line">    Constructor提供的方法</span><br><span class="line">        Class&lt;?&gt;[] getInterface()</span><br><span class="line">    调用缺省构造函数,返回该Class对象的一个实例</span><br><span class="line">     Object newInstance()</span><br></pre></td></tr></table></figure><h1 id="三十-枚举"><a href="#三十-枚举" class="headerlink" title="三十.枚举"></a>三十.枚举</h1><h3 id="1-使用步骤"><a href="#1-使用步骤" class="headerlink" title="1.使用步骤"></a>1.使用步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.定义</span><br><span class="line">2.使用</span><br></pre></td></tr></table></figure><h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2.定义:"></a>2.定义:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">访问权限修饰符 enum 枚举名(</span><br><span class="line">属性名1,属性名2,属性名2,....属性名n</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">情况1:</span><br><span class="line">使用枚举的属性</span><br><span class="line">语法:枚举名.属性名</span><br><span class="line"></span><br><span class="line">情况2:</span><br><span class="line">枚举作为形参</span><br><span class="line">传递实参时必须传入枚举的属性</span><br></pre></td></tr></table></figure><h3 id="4-自定义枚举"><a href="#4-自定义枚举" class="headerlink" title="4.自定义枚举"></a>4.自定义枚举</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1不需要提供set方法,枚举对象值通常为只读</span><br><span class="line">2.对枚举对象/属性使用final static共同修饰,实现底层优化</span><br><span class="line">3.枚举对象名通常全部大写,常量的命名规范</span><br><span class="line">4.枚举对象根据需要,也可以有多个属性]</span><br></pre></td></tr></table></figure><h4 id="5-特点"><a href="#5-特点" class="headerlink" title="5.特点"></a>5.特点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.构造器私有化</span><br><span class="line">2.本类内创建一组对象 public static final 类型名</span><br><span class="line">3.对外暴露对象(通过为对象添加public static final修饰符)</span><br><span class="line">4.可以提供get方法,不提供set方法</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong>：</p><ol><li>当我们使用enum关键字开发一个枚举时，默认会继承Enum类，而且是一个final类</li><li>传统的public final static  Season01 SPRING&#x3D;new Season01(“春天”,”温暖”);简化成 SPRING(“春天”,”温暖”);，这里必须知道它调用的那个构造器</li><li>如果使用无参构造器  创建枚举对象，则实参列表和小括号可以省略</li><li>当有多个枚举对象时，使用逗号间隔，最后用分号结尾</li><li>枚举对象必须放在枚举类的首行</li></ol><p><strong>常用方法：</strong></p><p><strong>说明；</strong>使用关键字enum时，会隐式继承enum，这样我们就可以使用Enum类相关的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Enum</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt;</span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;E&gt;, Serializable&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>toString :Enum类已经重写过，返回当前对象名，子类可以重写该方法，用于返回对象的属性信息</li><li>name：返回当前对象名，子类中不能重写</li><li>ordinal：返回当前对象的位置号，默认从0开始</li><li>values：返回当前枚举类中所有常量</li><li>valueOf：将字符串装换成枚举对象，要求字符串必须为已有的常量名，否则报异常</li><li>compareTo：比较两个枚举常量，比较的就是位置号</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Week[] values = Week.values();</span><br><span class="line">    <span class="keyword">for</span> (Week week:values) &#123;<span class="comment">//增强for循环</span></span><br><span class="line">        System.out.println(week);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>细节：</strong></p><ul><li>使用enum关键字后，就不能继承其他类，因为enum会隐式继承Enum，而java是单继承机制</li><li>枚举和普通类一样，可以实现接口：enum  类名   implements  接口1，接口2{}</li></ul><h1 id="三十一-注解"><a href="#三十一-注解" class="headerlink" title="三十一.注解"></a>三十一.注解</h1><blockquote><p>作用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解释代码的代码,称为注解,又名元代码</span><br></pre></td></tr></table></figure><p>注释与注解的区别</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注释:不会影响代码</span><br><span class="line">注解:对代码有一定的约束作用</span><br></pre></td></tr></table></figure><p>常见的注解</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">作用:说明当前方法为重写的方法</span><br><span class="line">@SuppressWarnings(&quot;all&quot;)</span><br><span class="line">作用:忽略警告</span><br><span class="line"></span><br><span class="line">元注解</span><br><span class="line">概念:解释注解的注解</span><br><span class="line">@Target</span><br><span class="line">  作用:注解使用位置</span><br><span class="line">  值:</span><br><span class="line">  TYPE:类,接口,枚举上使用</span><br><span class="line">FIELD:属性上使用</span><br><span class="line">METHOD:方法使用</span><br><span class="line">PARAMETER:参数上使用</span><br><span class="line">CONSTRUCTOR:构造函数</span><br><span class="line">LOCAL_VARIABLE:局部变量使用</span><br><span class="line">ANNOTATION_TYPE:注解使用</span><br><span class="line">PACKAGE:包使用</span><br><span class="line">注意:没有写可以在任何地方使用</span><br><span class="line"></span><br><span class="line">@Retention</span><br><span class="line">  作用:注解作用时机</span><br><span class="line">  值:</span><br><span class="line">  SOURCE:java源程序中存在</span><br><span class="line">CLASS:字节码文件中存在</span><br><span class="line">RUNTIME:运行时存在</span><br><span class="line"></span><br><span class="line">@Documented</span><br><span class="line">  作用:可以生成API文档</span><br><span class="line">  </span><br><span class="line">@Inherited</span><br><span class="line">  作用:说明当前注解是否可以被子类继承,默认不能被子类继承</span><br></pre></td></tr></table></figure><p>自定义注解</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">访问权限修饰符 @interface 注解名&#123;</span><br><span class="line">数据类型 属性名1() [default 默认值];</span><br><span class="line">数据类型 属性名2() [default 默认值];</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解的使用</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@注解名(属性名 = 属性值,属性名 = 属性值,...);</span><br><span class="line">注意:</span><br><span class="line">1,当注解中的属性有默认值,可以在使用注解时不用赋值</span><br><span class="line">2,当注解中所有属性都有默认值或没有属性时,可以省略小括号不写</span><br><span class="line">@注解名</span><br><span class="line">3,当注解中只有一个属性,并且该属性的属性名为value,此时在使用注解时可以省略属性名不写</span><br><span class="line">@注解名(属性值)</span><br></pre></td></tr></table></figure></blockquote><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2023/05/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/05/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>hexo new “”</p><p>hexo g </p><p>hexo d</p><p>hexo s</p><h1 id="解决办法："><a href="#解决办法：" class="headerlink" title="解决办法："></a>解决办法：</h1><ol><li>删除<code>.deploy_git</code>文件夹;</li><li>输入<code>git config --global core.autocrlf false</code></li><li>然后，依次执行：<br><code>hexo clean</code><br><code>hexo g</code><br><code>hexo d</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 默认 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
