<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JAVA基础 | 半糖</title><meta name="author" content="冯家鹏"><meta name="copyright" content="冯家鹏"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JAVA基础一、准备阶段W1.JAVA的执行流程.Java文件（源文件）——&gt;javac编译——&gt;.class文件（字节码文件）——&gt;java运行——&gt;结果  2.开发细节1.区分大小写2.Java方法是一条语句，以分号结束3.大括号成对出现4.一个Java文件中只能有一个public类。其它类个数不限。5.如果源文件包含一个public类，则文件名必须按照该类名命名。6.">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA基础">
<meta property="og:url" content="http://example.com/2023/05/01/JAVA%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="半糖">
<meta property="og:description" content="JAVA基础一、准备阶段W1.JAVA的执行流程.Java文件（源文件）——&gt;javac编译——&gt;.class文件（字节码文件）——&gt;java运行——&gt;结果  2.开发细节1.区分大小写2.Java方法是一条语句，以分号结束3.大括号成对出现4.一个Java文件中只能有一个public类。其它类个数不限。5.如果源文件包含一个public类，则文件名必须按照该类名命名。6.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://b.zhutix.com/bizhi/Flunt_Emoji/05.jpg">
<meta property="article:published_time" content="2023-05-01T12:08:37.000Z">
<meta property="article:modified_time" content="2023-05-01T12:09:49.136Z">
<meta property="article:author" content="冯家鹏">
<meta property="article:tag" content="java基础知识">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://b.zhutix.com/bizhi/Flunt_Emoji/05.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/05/01/JAVA%E5%9F%BA%E7%A1%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JAVA基础',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-01 20:09:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/backgound.css"><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="半糖" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/toux.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tag/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://b.zhutix.com/bizhi/Flunt_Emoji/05.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="半糖"><span class="site-name">半糖</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tag/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JAVA基础</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-01T12:08:37.000Z" title="发表于 2023-05-01 20:08:37">2023-05-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-01T12:09:49.136Z" title="更新于 2023-05-01 20:09:49">2023-05-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JAVA基础"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><h2 id="一、准备阶段W"><a href="#一、准备阶段W" class="headerlink" title="一、准备阶段W"></a>一、准备阶段W</h2><h2 id="1-JAVA的执行流程"><a href="#1-JAVA的执行流程" class="headerlink" title="1.JAVA的执行流程"></a>1.JAVA的执行流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.Java文件（源文件）——&gt;javac编译——&gt;.class文件（字节码文件）——&gt;java运行——&gt;结果</span><br></pre></td></tr></table></figure>

<h2 id="2-开发细节"><a href="#2-开发细节" class="headerlink" title="2.开发细节"></a>2.开发细节</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.区分大小写</span><br><span class="line">2.Java方法是一条语句，以分号结束</span><br><span class="line">3.大括号成对出现</span><br><span class="line">4.一个Java文件中只能有一个public类。其它类个数不限。</span><br><span class="line">5.如果源文件包含一个public类，则文件名必须按照该类名命名。</span><br><span class="line">6.一个源文件中最多只能有一个public类，其他类个数不限，也可以将main方法写在非public类中，然后指定运行非public类，这样入口方法就是非public的main方法。</span><br></pre></td></tr></table></figure>

<h2 id="3-命名规则"><a href="#3-命名规则" class="headerlink" title="3..命名规则"></a>3..命名规则</h2><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.有字母数字下划线组成</span><br><span class="line">2.数字不能开头</span><br><span class="line">3.不能使用关键字和保留字，但可以包含关键字和保留字</span><br><span class="line">4.Java中严格区分大小写，长度无限制</span><br><span class="line">5.标识符不能包含空格</span><br><span class="line">6.不能使用特殊符号,除$和_</span><br></pre></td></tr></table></figure>

<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.包名，多单词组成时所有字母都小写。如aaa.bbb.ccc</span><br><span class="line">2.类名，接口名,注解名,枚举名:多单词组成时，所有单词首字母都大写。如：TalkBankGame</span><br><span class="line">3.变量名，方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写。如aaaBbbCcc</span><br><span class="line">4.常量名：所有的字母都大写，多单词时每个单词用下划线连接。XXX_YYY_ZZZ</span><br></pre></td></tr></table></figure>

<h2 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h2><h2 id="1-整型"><a href="#1-整型" class="headerlink" title="1.整型"></a>1.整型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int 整型 4字节</span><br><span class="line">short 短整型 2字节</span><br><span class="line">long  长整型 8字节，对于long需要加上L或l后缀区分</span><br><span class="line">byte  1字节</span><br></pre></td></tr></table></figure>

<h2 id="2-浮点型"><a href="#2-浮点型" class="headerlink" title="2.浮点型"></a>2.浮点型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.float：单精度浮点型  4字节，后缀加f</span><br><span class="line">2.double：双精度浮点型   8字节</span><br></pre></td></tr></table></figure>

<h2 id="3-字符型"><a href="#3-字符型" class="headerlink" title="3.字符型"></a>3.字符型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char 字符型  2字节，用单引号括起来，仅有一个字符</span><br><span class="line">注意：</span><br><span class="line">1)字符常量用单引号‘ ’</span><br><span class="line">2）java中允许使用转义符‘\’来将其后的字符转换为特殊字符常量    例如：char a=‘\n’;表示换行符</span><br><span class="line">3）在java中，char的本质是一个整数，在输出时，是Unicode码对应的字符</span><br><span class="line">4）可以直接给char附一个整数，然后输出时，会按照对应的Unicode字符输出</span><br><span class="line">5)char‘类型是可以进行运算的，相当于一个整数，因为都有对应的Unicode码</span><br></pre></td></tr></table></figure>

<h2 id="4-Boolean"><a href="#4-Boolean" class="headerlink" title="4.Boolean"></a>4.Boolean</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">布尔型，值为true和false</span><br></pre></td></tr></table></figure>

<h2 id="5-引用数据类型"><a href="#5-引用数据类型" class="headerlink" title="5.引用数据类型"></a>5.引用数据类型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">除过上述的四种基本数据类型，其余都是引用数据类型</span><br><span class="line">常用的String用于定义字符串</span><br></pre></td></tr></table></figure>

<h2 id="6-基本数据类型转换"><a href="#6-基本数据类型转换" class="headerlink" title="6.基本数据类型转换"></a>6.基本数据类型转换</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">精度小的自动转换为精度大的数据类型：自动类型转换</span><br><span class="line">数据类型按照精度大小排序为(规则)：char ——&gt;int ——&gt;long ——&gt;float ——&gt;double </span><br><span class="line"></span><br><span class="line">byte ——&gt;short ——&gt;int ——&gt;long ——&gt;float ——&gt;double</span><br><span class="line"></span><br><span class="line">基本数据类型转字符串：将基本类型的值+“ ”即可</span><br><span class="line"></span><br><span class="line">String转基本数据类型：通过基本类型的包装类调用parseXX方法即可</span><br></pre></td></tr></table></figure>

<h2 id="三、运算符"><a href="#三、运算符" class="headerlink" title="三、运算符"></a>三、运算符</h2><h2 id="1-算数运算符"><a href="#1-算数运算符" class="headerlink" title="1.算数运算符"></a>1.算数运算符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加 +</span><br><span class="line">减 —</span><br><span class="line">乘 *</span><br><span class="line">除 /</span><br><span class="line">取余 %</span><br><span class="line">自增 ++</span><br><span class="line">自减 --</span><br></pre></td></tr></table></figure>

<h2 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2.关系运算符"></a>2.关系运算符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">instanceof：检查是否是类的对象</span><br><span class="line">&gt; 大于</span><br><span class="line">&lt; 小于</span><br><span class="line">= 赋值</span><br><span class="line">== 全等于</span><br><span class="line">基本数据类型判断值是否相同</span><br><span class="line">引用数据类型判断内存地址是否相同</span><br><span class="line">&gt;= 大于等于</span><br><span class="line">&lt;= 小于等于</span><br><span class="line">!= 不等于</span><br><span class="line">基本数据类型判断值是否不相同</span><br><span class="line">引用数据类型判断内存地址是否不相同</span><br></pre></td></tr></table></figure>

<h2 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3.逻辑运算符"></a>3.逻辑运算符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">短路与&amp;&amp;</span><br><span class="line">	全真为真，有假为假（第一个为假，后面条件不再判断）</span><br><span class="line">短路或||</span><br><span class="line">	有真为真，全假为假，（判断第一个条件为真，不再判断结果为真）</span><br><span class="line">逻辑与&amp;</span><br><span class="line">	全真为真（第一个条件为false，后面的条件任然判断）</span><br><span class="line">逻辑或|</span><br><span class="line">	有真为真（第一个第二个条件都要判断）</span><br><span class="line">^逻辑异或</span><br><span class="line">	相同为假，不同为真</span><br><span class="line">！非运算</span><br><span class="line">	取反</span><br></pre></td></tr></table></figure>

<h2 id="4-三元运算符"><a href="#4-三元运算符" class="headerlink" title="4.三元运算符"></a>4.三元运算符</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">条件表达式？表达式1:表达式2;</span><br><span class="line">	如果条件表达式为true，运算表达式1，如果条件表达式为false，运算表达式2.</span><br><span class="line">注意:赋值给变量时,表达式1和表达式2的类型必须相同.</span><br></pre></td></tr></table></figure>

<h2 id="四、自动拆装箱"><a href="#四、自动拆装箱" class="headerlink" title="四、自动拆装箱"></a>四、自动拆装箱</h2><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">装箱:将基本数据类型转换成包装类型的过程</span><br><span class="line">拆箱:将包装类型装换成基本数据类型的过程</span><br></pre></td></tr></table></figure>

<h2 id="2-原理"><a href="#2-原理" class="headerlink" title="2.原理"></a>2.原理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">自动装箱都是通过包装类的valueOf()方法来实现,自动拆箱通过包装类对象的xxxValue()来实现.</span><br></pre></td></tr></table></figure>

<h2 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3.应用场景"></a>3.应用场景</h2><h3 id="场景一-、将基本数据类型放入集合类"><a href="#场景一-、将基本数据类型放入集合类" class="headerlink" title="场景一 、将基本数据类型放入集合类"></a>场景一 、将基本数据类型放入集合类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">li.add(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反编译:</span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">	li.add(Integer.valueOf(i));</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<h3 id="场景二、包装类和基本类型的大小比较"><a href="#场景二、包装类和基本类型的大小比较" class="headerlink" title="场景二、包装类和基本类型的大小比较"></a>场景二、包装类和基本类型的大小比较</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer a=<span class="number">1</span>;</span><br><span class="line">System.out.println(a==<span class="number">1</span>?<span class="string">&quot;等于&quot;</span>:<span class="string">&quot;不等于&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> bool=<span class="literal">false</span>;</span><br><span class="line">System.out.println(bool?<span class="string">&quot;真&quot;</span>:<span class="string">&quot;假&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反编译:</span><br><span class="line">Integer a=<span class="number">1</span>;</span><br><span class="line">System.out.println(a.IntValue==<span class="number">1</span>?<span class="string">&quot;等于&quot;</span>:<span class="string">&quot;不等于&quot;</span>);</span><br><span class="line"><span class="type">boolean</span> bool=<span class="literal">false</span>;</span><br><span class="line">System.out.println(bool.booleanValue?<span class="string">&quot;真&quot;</span>:<span class="string">&quot;假&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>包装类与基本数据类型进行比较运算,先将包装类拆箱成基本数据类型,然后比较.</p>
<h3 id="场景三、包装类型的运算"><a href="#场景三、包装类型的运算" class="headerlink" title="场景三、包装类型的运算"></a>场景三、包装类型的运算</h3><p>对Integer对象进行四则运算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">System.out.println(i+j);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反编译:</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> Integer.valueOf(<span class="number">20</span>);</span><br><span class="line">    System.out.println(i.intValue() + j.intValue());</span><br></pre></td></tr></table></figure>

<p>两个包装类型之间的运算,会被自动拆箱成基本类型.</p>
<h3 id="场景四、三目运算符的使用"><a href="#场景四、三目运算符的使用" class="headerlink" title="场景四、三目运算符的使用"></a>场景四、三目运算符的使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean flag = true;</span><br><span class="line">Integer i = 0;</span><br><span class="line">int j = 1;</span><br><span class="line">int k = flag ? i : j;</span><br><span class="line"></span><br><span class="line">在使用三目运算符时,会发生自动拆箱</span><br><span class="line">1.表达式1和表达式2的值只要有一个时基本数据类型</span><br><span class="line">2.表达式1和表达式2的值类型不一致,会强制拆箱升级成表示范围更大的那个类型</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反编译    </span><br><span class="line"><span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> flag ? i.intValue() : j;</span><br><span class="line">    System.out.println(k);</span><br></pre></td></tr></table></figure>

<p>如果三目运算符的表达式在自动拆箱的过程中为null.会发生自动拆箱导致的空指针异常.</p>
<h3 id="场景五、函数参数与返回值"><a href="#场景五、函数参数与返回值" class="headerlink" title="场景五、函数参数与返回值"></a>场景五、函数参数与返回值</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">(Integer num)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getNum</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、语句的分类"><a href="#五、语句的分类" class="headerlink" title="五、语句的分类"></a>五、语句的分类</h2><p>顺序语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">代码自上而下执行</span><br></pre></td></tr></table></figure>

<p>分支语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在多个分支选择执行其中一个</span><br></pre></td></tr></table></figure>

<p>循环语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">重复执行一段代码</span><br></pre></td></tr></table></figure>



<h2 id="六、分支语句"><a href="#六、分支语句" class="headerlink" title="六、分支语句"></a>六、分支语句</h2><h3 id="1-if-判断语句"><a href="#1-if-判断语句" class="headerlink" title="1.if 判断语句"></a>1.if 判断语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基础的if结构</span><br><span class="line">	语法:</span><br><span class="line">		if(条件表达式)&#123;</span><br><span class="line">			当条件表达式值为true时,执行此处代码</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">if else结构</span><br><span class="line">	语法:</span><br><span class="line">		if(条件表达式)&#123;</span><br><span class="line">			当条件表达式值为true时,执行此处代码</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			当条件表达式值为false时,执行此处代码</span><br><span class="line">		&#125;</span><br><span class="line">	注意:</span><br><span class="line">		1,else可有可无</span><br><span class="line">		2,else只能有一个</span><br><span class="line">		3,else不能单独存在</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line">else if结构</span><br><span class="line">	语法:</span><br><span class="line">		if(条件表达式1)&#123;</span><br><span class="line">			当条件表达式1为true,执行此处代码</span><br><span class="line">		&#125;else if(条件表达式2)&#123;</span><br><span class="line">			当条件表达式2为true,执行此处代码</span><br><span class="line">		&#125;else if(条件表达式3)&#123;</span><br><span class="line">			当条件表达式3为true,执行此处代码</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		else if(条件表达式n)&#123;</span><br><span class="line">			当条件表达式n为true,执行此处代码</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			当以上条件全为false,执行此处代码</span><br><span class="line">		&#125;</span><br><span class="line">	注意:</span><br><span class="line">		else if可以有多个</span><br><span class="line">		当上面的条件,将不会判断下面的条件		</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总结</span><br><span class="line">	if的语法:</span><br><span class="line">		if(条件表达式1)&#123;</span><br><span class="line">			当条件表达式1为true,执行此处代码</span><br><span class="line">		&#125;else if(条件表达式2)&#123;</span><br><span class="line">			当条件表达式2为true,执行此处代码</span><br><span class="line">		&#125;else if(条件表达式3)&#123;</span><br><span class="line">			当条件表达式3为true,执行此处代码</span><br><span class="line">		&#125;</span><br><span class="line">		...</span><br><span class="line">		else if(条件表达式n)&#123;</span><br><span class="line">			当条件表达式n为true,执行此处代码</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			当以上条件全为false,执行此处代码</span><br><span class="line">		&#125;</span><br><span class="line">	注意:</span><br><span class="line">		1,else if可以有多个</span><br><span class="line">		2,else if可以一个都没有</span><br><span class="line">		3,else if不能独立存在</span><br><span class="line">		4,else 可有可无,最多只能有一个</span><br><span class="line">		5,当多个条件同时满足时,只会执行最上面的那个</span><br></pre></td></tr></table></figure>

<h3 id="2-switch"><a href="#2-switch" class="headerlink" title="2.switch"></a>2.switch</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">	switch(变量名)&#123;</span><br><span class="line">		case 常量1:</span><br><span class="line">			当变量值等于常量1时,执行此处代码</span><br><span class="line">			int a;</span><br><span class="line">		break;</span><br><span class="line">		case 常量2:</span><br><span class="line">			当变量值等于常量2时,执行此处代码</span><br><span class="line">		break;</span><br><span class="line">		...</span><br><span class="line">		case 常量n:</span><br><span class="line">			当变量值等于常量n时,执行此处代码</span><br><span class="line">		break;</span><br><span class="line">		default:</span><br><span class="line">			当变量值不等于以上常量时,执行的代码</span><br><span class="line">		break;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	常量:代码在编译后无法修改的值或变量称为常量</span><br><span class="line">	break:跳出当前代码块,case中可以没有break,但是如果没有会导致贯穿</span><br><span class="line">	swicth中case后的常量不能相同</span><br><span class="line">	JDK1.5以后switch可以判断字符串内容是否相同</span><br><span class="line">	switch只能判断值相等,if可以判断区间,也可以判断值是否相同</span><br></pre></td></tr></table></figure>

<p>变量的作用域</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念:变量声明的代码块,为这个变量的作用域(就是这个变量可以使用的范围)</span><br></pre></td></tr></table></figure>

<h3 id="3-输入：Scanner"><a href="#3-输入：Scanner" class="headerlink" title="3.输入：Scanner"></a>3.输入：Scanner</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简介:由JDK提供的一个类</span><br><span class="line">作用:键盘录入</span><br><span class="line">使用:</span><br><span class="line">	1,导包</span><br><span class="line">		语法:import java.util.Scanner;</span><br><span class="line">		书写位置:类上</span><br><span class="line">	2,创建Scanner对象</span><br><span class="line">		语法:</span><br><span class="line">			Scanner 变量名 = new Scanner(System.in);</span><br><span class="line">	3,等待用户输入</span><br><span class="line">		输入字符串</span><br><span class="line">			String 变量名2 = 变量名.next();</span><br><span class="line">			变量名2:就是用户输入的内容</span><br><span class="line">		输入整数</span><br><span class="line">			int 变量名2 = 变量名.nextInt();</span><br><span class="line">			变量名2:就是用户输入的内容</span><br><span class="line">练习:</span><br><span class="line">	键盘录入成绩判断其得分的区间</span><br></pre></td></tr></table></figure>

<h2 id="七、循环语句"><a href="#七、循环语句" class="headerlink" title="七、循环语句"></a>七、循环语句</h2><h3 id="1-while"><a href="#1-while" class="headerlink" title="1.while"></a>1.while</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">while(条件表达式)&#123;</span><br><span class="line">	当条件表达式为true，执行此处代码i</span><br><span class="line">	此处代码执行完毕后，判断条件表达式是否为true，为true，执行此处代码</span><br><span class="line">	为false，结束循环</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-do-while"><a href="#2-do-while" class="headerlink" title="2.do-while"></a>2.do-while</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法：</span><br><span class="line">do&#123;</span><br><span class="line">		先执行此处代码,在判断条件表达式是否为true</span><br><span class="line">		如果为true,在此执行此处代码</span><br><span class="line">		如果为false结束循环</span><br><span class="line">&#125;while(条件表达式);</span><br></pre></td></tr></table></figure>

<h3 id="3-for"><a href="#3-for" class="headerlink" title="3.for"></a>3.for</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">	for(表达式1;表达式2;表达式3)&#123;</span><br><span class="line">		循环体4</span><br><span class="line">	&#125;</span><br><span class="line">	表达式1:初始化变量</span><br><span class="line">	表达式2:循环条件</span><br><span class="line">	表达式3:修改变量</span><br><span class="line">	循环体4:重复执行的代码</span><br><span class="line">执行流程:</span><br><span class="line">	1,2,4,3,2,4,3,2,4,3....2</span><br><span class="line">	注意:表达式1只执行一次</span><br></pre></td></tr></table></figure>

<p>名词解释：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">死循环；无法结束的循环</span><br><span class="line">循环嵌套：在循环语句中使用循环语句</span><br></pre></td></tr></table></figure>

<h3 id="4-转义字符"><a href="#4-转义字符" class="headerlink" title="4.转义字符"></a>4.转义字符</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念:有特殊含义的字符</span><br><span class="line"></span><br><span class="line">\t:制表</span><br><span class="line">\&quot;:双引号字符</span><br><span class="line">\&#x27;:单引号字符</span><br><span class="line">\n:换行</span><br><span class="line">\r\n:标准换行</span><br></pre></td></tr></table></figure>

<h3 id="5-流程控制语句"><a href="#5-流程控制语句" class="headerlink" title="5.流程控制语句"></a>5.流程控制语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break:跳出当前循环</span><br><span class="line"></span><br><span class="line">continue:跳过本次循环</span><br></pre></td></tr></table></figure>

<h2 id="八、方法（函数）"><a href="#八、方法（函数）" class="headerlink" title="八、方法（函数）"></a>八、方法（函数）</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1.作用"></a>1.作用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">封装一段代码，使其便于使用</span><br></pre></td></tr></table></figure>

<h3 id="2-优点"><a href="#2-优点" class="headerlink" title="2.优点"></a>2.优点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提高代码复用率</span><br><span class="line">降低代码耦合度</span><br><span class="line">提高代码编写效率</span><br><span class="line">方便使用</span><br></pre></td></tr></table></figure>

<h3 id="3-步骤"><a href="#3-步骤" class="headerlink" title="3.步骤"></a>3.步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.定义</span><br><span class="line">2.调用</span><br></pre></td></tr></table></figure>

<h3 id="4-定义"><a href="#4-定义" class="headerlink" title="4.定义"></a>4.定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">位置：</span><br><span class="line">	类中，方法外</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">语法:</span><br><span class="line">		访问权限修饰符 修饰符 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">			方法体</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">注意：		</span><br><span class="line">		访问权限修饰符:暂时使用public</span><br><span class="line">		修饰符:暂时使用static</span><br><span class="line">		返回值类型:就是返回值的数据类型.如果没有返回值,返回值类型为void.null表示为空</span><br><span class="line">		方法名:自定义,见名知意,小驼峰.一个类中不能出现方法名相同,形参列表也相同的方法</span><br><span class="line">		形参列表:可有可无</span><br><span class="line">			本质:声明的多个变量,使用逗号隔开</span><br><span class="line">		方法体:</span><br><span class="line">			return:结束当前方法</span><br><span class="line">			return xxx:结束当前方法,并返回xxx.注意此时返回值类型要与xxx的数据类型一致.只能返回一个</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="5-调用"><a href="#5-调用" class="headerlink" title="5.调用"></a>5.调用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">		1,方法名(实参列表);</span><br><span class="line">		2,数据类型 变量名 = 方法名(实参列表);</span><br><span class="line">	注意:</span><br><span class="line">		1,实参列表要与形参列表一致(长度一致,顺序一致,数据类型一致)</span><br><span class="line">		2,调用无返回值的方法只能使用语法1</span><br><span class="line">		3,调用有返回值的方法可以选择使用语法1也可以选择使用语法2</span><br></pre></td></tr></table></figure>

<h3 id="6-多重调用"><a href="#6-多重调用" class="headerlink" title="6.多重调用"></a>6.多重调用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法调用方法</span><br><span class="line">A,B,C三个方法</span><br><span class="line">	A中调用B,在B中调用C</span><br></pre></td></tr></table></figure>

<h3 id="7-重载"><a href="#7-重载" class="headerlink" title="7.重载"></a>7.重载</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">要求:</span><br><span class="line">	1,同一个类中</span><br><span class="line">	2,方法名相同</span><br><span class="line">	3,形参列表不同</span><br></pre></td></tr></table></figure>

<h3 id="8-递归"><a href="#8-递归" class="headerlink" title="8.递归"></a>8.递归</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法本身调用本身</span><br></pre></td></tr></table></figure>

<h2 id="九、数组"><a href="#九、数组" class="headerlink" title="九、数组"></a>九、数组</h2><h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><h3 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1.作用"></a>1.作用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存储一组数据类型相同的数据</span><br></pre></td></tr></table></figure>

<h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.长度不可变</span><br><span class="line">2.存储的数据类型一致</span><br></pre></td></tr></table></figure>

<h3 id="3-步骤-1"><a href="#3-步骤-1" class="headerlink" title="3.步骤"></a>3.步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">声明/创建/使用</span><br></pre></td></tr></table></figure>

<h3 id="4-声明"><a href="#4-声明" class="headerlink" title="4.声明:"></a>4.声明:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">	数据类型[] 数组名;</span><br><span class="line">	数据类型 数组名[];</span><br></pre></td></tr></table></figure>

<h3 id="5-创建"><a href="#5-创建" class="headerlink" title="5.创建"></a>5.创建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">静态创建:</span><br><span class="line">	语法:</span><br><span class="line">		数据类型[] 数组名 = &#123;值1,值2,值3,值4,...值n&#125;;</span><br><span class="line">	注意事项:</span><br><span class="line">		1,必须在声明时创建</span><br><span class="line">		2,其长度就是创建时值的个数</span><br><span class="line">动态创建:</span><br><span class="line">	语法:</span><br><span class="line">		带值</span><br><span class="line">			数组名 = new 数据类型[]&#123;值1,值2,值3,...&#125;;</span><br><span class="line">			注意:</span><br><span class="line">				其长度就是创建时值的个数</span><br><span class="line">		不带值</span><br><span class="line">			数组名 = new 数据类型[长度];</span><br><span class="line">			</span><br><span class="line">动态创建与静态创建的区别:</span><br><span class="line">	1,静态创建必须在声明时创建,动态创建可以将声明与创建分开,也可以同时进行</span><br><span class="line">	2,内存上来说</span><br><span class="line">		静态创建的内存在常量区</span><br><span class="line">		动态创建的内容在堆内存</span><br><span class="line">	3,静态创建是在代码加载时分配的内存空间,动态创建是在代码运行时分配的空间</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">	堆内存中的数据有默认值</span><br><span class="line">		基本数据类型默认为0</span><br><span class="line">		引用数据类型默认为null</span><br></pre></td></tr></table></figure>

<h3 id="6-使用"><a href="#6-使用" class="headerlink" title="6.使用"></a>6.使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基本使用</span><br><span class="line">	改</span><br><span class="line">		修改指定位置的数据</span><br><span class="line">			语法:</span><br><span class="line">				数组名[下标] = 值;</span><br><span class="line">	查</span><br><span class="line">		查询数组长度</span><br><span class="line">			语法:</span><br><span class="line">				数组名.length</span><br><span class="line">		查询数组指定位置的数据</span><br><span class="line">			语法:</span><br><span class="line">				数组名[下标]</span><br><span class="line">			注意:</span><br><span class="line">				下标要在取值范围内,否则会产生数组下标越界异常</span><br><span class="line"></span><br><span class="line">扩展</span><br><span class="line">	遍历:将数组或集合中的数据逐个取出</span><br><span class="line">		方式1:普通for循环</span><br><span class="line">		方式2:foreach(只能做遍历)</span><br><span class="line">			foreach语法:</span><br><span class="line">				for(数据类型 变量名:要遍历的数组或集合)&#123;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">				数据类型:遍历出的数据的数据类型</span><br><span class="line">				变量名:就是遍历出的数据</span><br><span class="line">		注意:foreach(增强for循环)在遍历时的速度是普通for的3倍</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">	复制:</span><br><span class="line">	将数组A中的数据,逐个复制到数组中</span><br><span class="line">		思路:</span><br><span class="line">			1,创建新数组</span><br><span class="line">				注意:</span><br><span class="line">					1,新数组长度等于老数组长度</span><br><span class="line">					2,新数组的数据类型与老数组一致</span><br><span class="line">			2,遍历老数组</span><br><span class="line">				使用普通for循环</span><br><span class="line">			3,将老数组的值取出,赋值给新数组对应的位置</span><br><span class="line">		</span><br><span class="line">	扩容:</span><br><span class="line">	将数组变大</span><br><span class="line">		思路:</span><br><span class="line">			1,创建一个新数组</span><br><span class="line">				注意:</span><br><span class="line">					1,新数组长度大于老数组长度</span><br><span class="line">					2,新数组的数据类型与老数组一致</span><br><span class="line">			2,遍历老数组</span><br><span class="line">			3,将老数组的值取出,赋值给新数组对应的位置</span><br><span class="line">			4,将新数组赋值给老数组</span><br></pre></td></tr></table></figure>

<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念:将数组作为数据存储在数组中</span><br><span class="line">步骤:</span><br><span class="line">	1,声明</span><br><span class="line">	2,创建</span><br><span class="line">	3,使用</span><br><span class="line">声明</span><br><span class="line">	数据类型[][] 数组名;</span><br><span class="line">创建</span><br><span class="line">	静态创建</span><br><span class="line">		注意:声明与创建同时进行</span><br><span class="line">		语法:</span><br><span class="line">			数据类型[][] 数组名 = &#123;</span><br><span class="line">				&#123;值1,值2,值3,...&#125;,</span><br><span class="line">				&#123;值4,值5,..&#125;,</span><br><span class="line">				&#123;值6,值7,值8,值9,...&#125;,</span><br><span class="line">				...</span><br><span class="line">			&#125;;</span><br><span class="line">	动态创建</span><br><span class="line">		带值</span><br><span class="line">			语法:</span><br><span class="line">				数组名 = new 数据类型[][]&#123;</span><br><span class="line">					&#123;值1,值2,值3,...&#125;,</span><br><span class="line">					&#123;值4,值5,..&#125;,</span><br><span class="line">					&#123;值6,值7,值8,值9,...&#125;,</span><br><span class="line">					...</span><br><span class="line">				&#125;;</span><br><span class="line">		不带值</span><br><span class="line">			语法:</span><br><span class="line">				数组名 = new 数据类型[x][y];</span><br><span class="line">				x:二维数组中可容纳的一维数组的个数,必须在创建时说明</span><br><span class="line">				y:一维数组中可容纳的元素的个数,可以不写</span><br><span class="line">注意:</span><br><span class="line">	二维数组的长度指的是其中存储的一维数组的个数</span><br><span class="line">	</span><br><span class="line">使用:</span><br><span class="line">	改</span><br><span class="line">		修改二维数组中指定的一维数组</span><br><span class="line">			数组名[下标] = 新数组;</span><br><span class="line">			注意:不能使用静态创建</span><br><span class="line">		修改二维数组中指定的位置的元素</span><br><span class="line">			数组名[x][y] = 新值;</span><br><span class="line">			x:元素所在的一维数组在二维数组中的位置</span><br><span class="line">			y:元素在一维数组中的位置</span><br><span class="line">	查</span><br><span class="line">		查询数组长度</span><br><span class="line">			数组名.length</span><br><span class="line">		查询二维数组中指定位置的一维数组</span><br><span class="line">			数组名[下标];</span><br><span class="line">		查询二维数组中指定位置的元素</span><br><span class="line">			数组名[x][y]</span><br><span class="line">			x:元素所在的一维数组在二维数组中的位置</span><br><span class="line">			y:元素在一维数组中的位置</span><br><span class="line">遍历:</span><br><span class="line">	思路:</span><br><span class="line">		1,遍历二维数组,获取一维数组</span><br><span class="line">		2,遍历一维数组</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:解决实参的长度必须与形参一致的问题</span><br><span class="line"></span><br><span class="line">语法:数据类型... 变量名</span><br><span class="line"></span><br><span class="line">使用位置:形参末尾使用</span><br><span class="line"></span><br><span class="line">注意:一个方法只能使用一个可变参数</span><br></pre></td></tr></table></figure>

<h1 id="十、面向对象"><a href="#十、面向对象" class="headerlink" title="十、面向对象"></a>十、面向对象</h1><h2 id="1-面向过程"><a href="#1-面向过程" class="headerlink" title="1.面向过程"></a>1.面向过程</h2><blockquote>
<p>面向过程(Procedure Oriented)是一种以过程为中心的编程思想，是一种自顶而下的编程模式。最典型的面向过程的编程语言就是C语言。</p>
<p>简单来说，面向过程的开发范式中，程序员需要把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。</p>
<p>就是说，在进行面向过程编程的时候，不需要考虑那么多，上来先定义一个函数，然后使用各种诸如if-else、for-each等方式进行代码执行。最典型的用法就是实现一个简单的算法，比如实现冒泡排序。</p>
<p>面向过程进行的软件开发，其代码都是流程化的，很明确的可以看出第一步做什么、第二步做什么。这种方式的代码执行起来效率很高。</p>
<p>但是，面向过程同时存在着代码重用性低，扩展能力差，后期维护难度比较大等问题。</p>
</blockquote>
<h2 id="2-面向对象"><a href="#2-面向对象" class="headerlink" title="2.面向对象"></a>2.面向对象</h2><blockquote>
<p>面向对象（Object Oriented）的雏形，最早在出现在1960年的Simula语言中，当时的程序设计领域正面临着一种危机：在软硬件环境逐渐复杂的情况下，软件如何得到良好的维护？</p>
<p>面向对象程序设计在某种程度上通过强调可重复性解决了这一问题。目前较为流行的面向对象语言主要有Java、C#、C++、Python、Ruby、PHP等。</p>
<p>简单来说，面向对象的开发范式中，程序员将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。</p>
<p>就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。比如:想要造一辆车，上来要先把车的各种属性定义出来，然后抽象成一个Car类。</p>
<p>面向对象的编程方法之所以更加受欢迎，是因为他更加符合人类的思维方式。这种方式编写出来的代码扩展性、可维护性都很高。</p>
<p>与其实面向对象是一种开发范式，倒不如说面向对象是一种对现实世界的理解和抽象的方法。通过对现实世界的理解和抽象，在运用封装、继承、多态等方法，通过抽象出对象的方式进行软件开发。</p>
</blockquote>
<h2 id="3-对象"><a href="#3-对象" class="headerlink" title="3.对象"></a>3.对象</h2><blockquote>
<p>对象就是类的具体实例<br>概念：万事万物皆对象<br>生活中：客观存在的事物皆为对象<br>代码中：在代码中存在的事物</p>
</blockquote>
<h2 id="4-类"><a href="#4-类" class="headerlink" title="4.类"></a>4.类</h2><blockquote>
<p>概念：多个对象抽象其共同点形成的概念</p>
<p>代码中：创建对象的模板</p>
</blockquote>
<h2 id="5-类和对象的关系"><a href="#5-类和对象的关系" class="headerlink" title="5.类和对象的关系"></a>5.类和对象的关系</h2><blockquote>
<p>类是抽象的，概念的，代表一类事物</p>
<p>对象时具体的，实际的，代表一个具体事物</p>
<p>类是对象的模板，对象是类的一个个体，对应一个实例</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">生活中:先有对象,后有类</span><br><span class="line">代码中:先有类,后有对象</span><br><span class="line">	一个类可以有多个对象.多个对象可以属于同一个类</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-类的定义与组成"><a href="#6-类的定义与组成" class="headerlink" title="6.类的定义与组成"></a>6.类的定义与组成</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1).定义"></a>1).定义</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">	访问权限修饰符 class 类名&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	访问权限修饰符:</span><br><span class="line">		暂时使用public或不写</span><br><span class="line">	类名:</span><br><span class="line">		1,同一个文件夹下类名不能相同</span><br><span class="line">		2,大驼峰</span><br></pre></td></tr></table></figure>

<h3 id="2-组成"><a href="#2-组成" class="headerlink" title="2).组成"></a>2).组成</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.属性（全局变量，成员变量）</span><br><span class="line">	作用：描述事物的静态特征</span><br><span class="line">	位置：方法外，类内</span><br><span class="line">	格式：权限修饰符 数据类型 属性名；</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法：</span><br><span class="line">	作用：描述事物的行为（静态特征）</span><br><span class="line">	位置：类中，方法外</span><br><span class="line">	格式：</span><br><span class="line">		权限修饰符  返回值类型  方法名（新参列表）&#123;</span><br><span class="line">		方法体</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造函数</span><br><span class="line">	本质：特殊的方法</span><br><span class="line">	作用：创建该类的对象</span><br><span class="line">	定义位置：类中。方法外</span><br><span class="line">	语法：</span><br><span class="line">	访问权限修饰符  构造函数名（形参列表）&#123;</span><br><span class="line">            方法体</span><br><span class="line">	&#125;  </span><br><span class="line">	注意：</span><br><span class="line">		1.构造函数没有返回值类型</span><br><span class="line">		2.构造函数没有返回值</span><br><span class="line">		3.构造函数名和类名一致</span><br><span class="line">		4.使用new关键字调用</span><br><span class="line">		5.如果一个类中有多个构造函数，那么这些构造函数为重载关系</span><br><span class="line">		6.一个类一定会有一个构造函数，如果没有定义构造函数，系统将会提供无参构造器</span><br><span class="line">		7.构造函数不能形成递归</span><br></pre></td></tr></table></figure>



<h4 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">成员变量：</span><br><span class="line">	声明在类中，方法外</span><br><span class="line">	有默认值，基本数据类型默认为0，引用数据类型默认为null</span><br><span class="line">	作用域：当前类中</span><br><span class="line">	生命周期：随着对象的创建而创建，随着所属对象的销毁而销毁</span><br><span class="line">局部变量：</span><br><span class="line">	方法中</span><br><span class="line">	没有默认值</span><br><span class="line">	作用域:当前代码块中</span><br><span class="line">	生命周期:随着方法调用而生成随着方法执行完毕而销毁</span><br></pre></td></tr></table></figure>

<h2 id="7-对象的创建与使用"><a href="#7-对象的创建与使用" class="headerlink" title="7.对象的创建与使用"></a>7.对象的创建与使用</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建</span><br><span class="line">	语法：</span><br><span class="line">		数据类型 对象名 = new 构造函数（实参列表）；</span><br><span class="line">		构造函数：即为该对象所属的类名</span><br></pre></td></tr></table></figure>

<p>面试题：</p>
<blockquote>
<p>Cat cat &#x3D; new Cat();</p>
<p>1.使用new关键字在堆内存中开辟一片空间</p>
<p>2.给属性赋初值</p>
<p>3.执行构造函数中的代码</p>
<p>4.将堆地址赋值给栈中的引用</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">使用：</span><br><span class="line">	获取属性值：</span><br><span class="line">		对象名.属性名</span><br><span class="line">	修改属性值</span><br><span class="line">    	对象名.属性名 = 值；</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">调用：</span><br><span class="line">	对象名.方法名（实参列表）</span><br></pre></td></tr></table></figure>

<h2 id="8-this"><a href="#8-this" class="headerlink" title="8.this"></a>8.this</h2><blockquote>
<p>含义：谁调用this所在的方法this就表示谁</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">场景一：局部变量与成员变量名称相同时，使用this区分</span><br><span class="line">	成员变量(属性)</span><br><span class="line">	this.属性名</span><br><span class="line">	局部变量</span><br><span class="line">	变量名</span><br><span class="line"></span><br><span class="line">	就近使用原则</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">场景二：在本类方法中使用本类的属性或方法，默认用this调用。此时this可以忽略</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">场景三：本类构造函数中，调用本类其他构造函数</span><br><span class="line">语法:</span><br><span class="line">	this(实参列表);</span><br><span class="line">注意:</span><br><span class="line">	必须在构造函数第一行使用</span><br></pre></td></tr></table></figure>

<h1 id="十一-三大特征"><a href="#十一-三大特征" class="headerlink" title="十一.三大特征"></a>十一.三大特征</h1><h2 id="1-访问权限修饰符"><a href="#1-访问权限修饰符" class="headerlink" title="1.访问权限修饰符"></a>1.访问权限修饰符</h2><blockquote>
<p>作用:限制其修饰的内容使用范围</p>
<p>关键字:</p>
<p>public    公共的    当前项目可访问</p>
<p>protected    受保护的   当前包下或继承关系下可用</p>
<p>默认的   当前包下</p>
<p>private  私有的     当前类中可用</p>
</blockquote>
<h2 id="2-封装"><a href="#2-封装" class="headerlink" title="2.封装"></a>2.封装</h2><p>​	<strong>定义</strong>:包装;封装就是把抽象出的数据【属性】和对数据的操作【方法】封装在一起，数据被保护在内部，</p>
<p><strong>优点:</strong></p>
<pre><code>&gt;1.方便使用
&gt;
&gt;2.保护内部
&gt;
&gt;3.降低耦合度
&gt;
&gt;4.提高复用率
</code></pre>
<p><strong>体现</strong></p>
<blockquote>
<p>变量:封装值或内存地址</p>
<p>方法:封装一段代码</p>
<p>类:封装多个属性,方法与构造函数</p>
<p>java中封装无处不在</p>
</blockquote>
<p><strong>包:</strong></p>
<blockquote>
<p>**本质:**src下的文件夹</p>
<p>**作用:**对java文件进行分类存储,使其便于寻找</p>
<p><strong>创建</strong>:  选择src—鼠标右键—new —package—填写包名</p>
<p><strong>包名:</strong>   规则:全小写</p>
<p>​			潜规则:com.公司名或项目名.分类名</p>
<p><strong>注意:</strong></p>
<p>​		.下一级文件夹</p>
<p>关键字:package,说明当前java文件所在的包</p>
</blockquote>
<p><strong>导包</strong></p>
<blockquote>
<p>作用:在当前java文件中使用其他文件夹下的类,此时需要导包<br>语法:<br>import 包名.类名;</p>
<p>位置:类上</p>
<p>关键字:import</p>
<p>*:所有</p>
</blockquote>
<p><strong>步骤</strong></p>
<blockquote>
<p>1.属性私有化</p>
<p>2.提供公共的set方法,用于对属性的判断并赋值</p>
<p>3.提供一个公共的get方法,用于获取属性值</p>
</blockquote>
<h2 id="3-继承"><a href="#3-继承" class="headerlink" title="3.继承"></a>3.继承</h2><p><strong>概念</strong></p>
<blockquote>
<p>生活中:晚辈继承长辈遗留下的精神或物质遗产</p>
<p>代码中:多个类抽取其共同点形成的类,此时该类与这几个类形成继承关系</p>
</blockquote>
<p><strong>优点</strong></p>
<blockquote>
<p>子类将拥有父类的所有属性和方法,构造函数除外</p>
<p>提高代码复用率</p>
</blockquote>
<p><strong>语法</strong></p>
<blockquote>
<p>访问权限修饰符   class  子类名  extends 父类名{</p>
<p>​	属性</p>
<p>​	方法</p>
<p>​	构造函数</p>
<p>}</p>
<p>注意:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1.一个父类可以有多个子类</span><br><span class="line">&gt;2.一个子类只能有一个父类,单继承</span><br><span class="line">&gt;3.子类构造函数中默认调用父类无参构造函数</span><br><span class="line">&gt;4.子类构造函数中必须调用父类的构造函数,默认先调用父类的构造函数</span><br><span class="line">&gt;5.Object是所有类的父类,如果一个没有明确的父类,默认继承Object</span><br><span class="line">&gt;6.开闭原则:</span><br><span class="line">对修改关闭</span><br><span class="line">对扩展打开</span><br></pre></td></tr></table></figure>


</blockquote>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a><strong>重写</strong></h4><blockquote>
<p>在继承关系中,子类中的方法与父类的方法,方法名相同,形参列表相同.</p>
<p>子类的方法访问权限修饰符不能小于父类的子类</p>
<p>该方法返回值类型与父类一致.</p>
</blockquote>
<h4 id="super"><a href="#super" class="headerlink" title="super"></a><strong>super</strong></h4><p>​		含义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">谁调用super所在的方法,super就表示谁的父类对象</span><br><span class="line">代表父类的引用，用于访问父类的属性，方法，构造器</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">	1.访问父类的属性,但不能访问父类的private属性,super.属性名,在子类方法中访问</span><br><span class="line">	2.访问父类的方法,但不能访问父类的private方法,super.方法名(参数列表),在子类方法中访问</span><br><span class="line">	3.访问父类的构造器,super(参数列表)只能放在子类构造器的第一句</span><br></pre></td></tr></table></figure>

<p><strong>使用场景:</strong></p>
<blockquote>
<p><strong>场景1</strong>:当子类重写了父类的方法后,在子类中使用super区分,在子类重写的方法还是父类的方法</p>
<p>​	super.方法名(实参列表)     ——-父类提供</p>
<p>​	方法名(实参列表) ——–子类重写的方法</p>
</blockquote>
<blockquote>
<p><strong>场景2</strong>:当子类属性名与父类属性名重名时,使用super区分</p>
<p>​		super.属性名      父类属性</p>
<p>​		属性名               子类属性</p>
</blockquote>
<blockquote>
<p>**场景3:**调用构造函数</p>
<p>​	super(实参列表);—–只能在子类构造器第一行调用</p>
</blockquote>
<p><strong>细节:</strong></p>
<blockquote>
<ol>
<li><p>调用父类构造器的好处，（分工明确，父类属性由父类初始化，子类属性由子类初始化）</p>
</li>
<li><p>当子类中又有和 父类中的成员（属性和方法）重名时，为了访问父类的成员，必须通过super，如果没有重名，使用super，this，直接访问效果一样</p>
</li>
</ol>
<p> super.方法名：直接查找父类，跳过本类查找</p>
<ol start="3">
<li>super的访问不限于直接父类，如果爷爷类和本类中有同名成员，也可以使用super去访问爷爷类的成员，如果多个基类中有同名的成员，使用super遵循就近原则，也需要遵守权限规则。</li>
</ol>
</blockquote>
<p><strong>this与super</strong></p>
<blockquote>
<p>this:调用该方法的对象</p>
<p>super:调用该方法的父类对象</p>
</blockquote>
<h2 id="4-多态"><a href="#4-多态" class="headerlink" title="4.多态"></a>4.多态</h2><p><strong>概念:</strong>  </p>
<blockquote>
<p>一个事物的多种形态(方法或对象具有多种形态，多态建立在封装和继承的基础之上)</p>
</blockquote>
<h4 id="对象的多态"><a href="#对象的多态" class="headerlink" title="对象的多态"></a><strong>对象的多态</strong></h4><blockquote>
<p>子类对象转换为父类对象</p>
<p>​		自动转换</p>
<p>​		语法:               父类名    对象名  &#x3D;  子类对象;</p>
<p>父类对象转换为子类对象</p>
<p>​		强制转换</p>
<p>​			语法:         子类名    对象名   &#x3D;   (子类名)父类对象;</p>
<p>​			注意:有风险</p>
</blockquote>
<h4 id="方法的多态"><a href="#方法的多态" class="headerlink" title="方法的多态:"></a><strong>方法的多态:</strong></h4><blockquote>
<p>重载:在同一个类中,方法名相同,形参列表不同</p>
<p>重写:在继承关系中,子类方法与父类方法,方法名相同,形参列表相同,返回值类型相同,访问权限修饰符不能减小</p>
<p>注意:当子类对象转换为父类对象后,调查重写的方法,依据执行的是子类重写后的方法.</p>
</blockquote>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><strong>instanceof</strong></h4><blockquote>
<p>作用:判断该对象是否属于该类</p>
<p>注意:判断的对象与类之间要存在关系</p>
<p>语法:</p>
<p>​	boolean   变量名  &#x3D;  对象名  instanceof   类名;</p>
<p>如果为true,表示该对象属于该类</p>
<p>如果为false,表示该对象不属于该类</p>
</blockquote>
<h1 id="十二-、三大修饰符"><a href="#十二-、三大修饰符" class="headerlink" title="十二 、三大修饰符"></a>十二 、三大修饰符</h1><h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><blockquote>
<p>含义:抽象的,不可描述的</p>
<p>可以修饰类和方法</p>
<h4 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类:"></a><strong>修饰类:</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点:不能直接创建对象</span><br><span class="line">语法:</span><br><span class="line">	访问权限修饰符  abstract class 类名&#123;</span><br><span class="line">		属性</span><br><span class="line">		方法</span><br><span class="line">		构造函数</span><br><span class="line">	&#125;</span><br><span class="line">名称:抽象类</span><br><span class="line">注意:</span><br><span class="line">	1.抽象类中不一定有抽象方法</span><br><span class="line">	2.子类继承抽象类,要么重写父类所有抽象方法,要么自己也是抽象类</span><br><span class="line">	3.抽象类不能被实例化</span><br><span class="line">	4.一旦包含抽象方法,则这个类必须声明为抽象类</span><br><span class="line">	5.抽象类可以有任意成员,如非抽象方法,构造器,静态属性</span><br></pre></td></tr></table></figure>

<h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点:没有方法体</span><br><span class="line">语法:</span><br><span class="line">	访问权限修饰符  abstract 返回值类型 方法名(形参列表);</span><br><span class="line">	注意:</span><br><span class="line">	1.有抽象方法的类一定是抽象类</span><br><span class="line">	2.抽象类中可以有多个抽象方法</span><br><span class="line">	3.抽象方法不能有主体,即不能实现</span><br><span class="line">	4.抽象方法不能使用private，final，static来修饰，因为这些关键字都是和重写相违背的，final是不能继承的，static关键字和方法重写无关，private不能重写</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><blockquote>
<p>含义:最终的,不可修改的</p>
<p>可以修饰:变量,方法,类</p>
<h4 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a><strong>修饰变量</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修饰局部变量</span><br><span class="line">	语法:</span><br><span class="line">		final 数据类型 变量名 = 值;</span><br><span class="line">	注意:只能赋值一次</span><br><span class="line"> 	final修饰的变量就是常量</span><br><span class="line">修饰成员变量</span><br><span class="line">		语法:</span><br><span class="line">			访问权限修饰符 final 数据类型 属性名 = 值;</span><br><span class="line">		注意:</span><br><span class="line">			1.final 修饰的属性必须是声明赋值时</span><br><span class="line">			2.final 修饰的属性值不能被修改</span><br></pre></td></tr></table></figure>

<h4 id="修饰方法-1"><a href="#修饰方法-1" class="headerlink" title="修饰方法"></a>修饰方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:不能被重写</span><br><span class="line">语法:</span><br><span class="line">	访问修饰符 final 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">		方法体</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修饰类-1"><a href="#修饰类-1" class="headerlink" title="修饰类"></a>修饰类</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:不能被继承,这种类被称为最终类</span><br><span class="line">语法: 	</span><br><span class="line">	访问权限修饰符 final class 类名&#123;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景:"></a>使用场景:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.不希望类被继承时,使用final修饰</span><br><span class="line">2.不希望父类的某个方法被子类覆盖/重写时可以使用final关键字</span><br><span class="line">3.当不希望类的某个属性的值被修改,就可以使用final修饰</span><br><span class="line">4.当不希望某个局部变量被修改,可以使用final修饰</span><br></pre></td></tr></table></figure>

<h4 id="细节"><a href="#细节" class="headerlink" title="细节:"></a>细节:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.final修饰的属性在定义时,必须赋初值,并且以后不能改变</span><br><span class="line">2.如果final修饰的属性是静态的,则初始化的位置只能是:在定义时,在静态代码块,不能在构造器中赋值</span><br><span class="line">3.final类不能继承,但可以实例化</span><br><span class="line">4.如果类不是final类,但是含有fianal方法,则该方法不能被重写,但可以被继承</span><br><span class="line">5.一般来说,一个类已经是final类了.则没必要讲方法修饰成final方法</span><br><span class="line">6.final不能修饰构造方法</span><br><span class="line">7.final 往往与static搭配使用,效率更高,底层编译做了优化处理,静态属性增加final后,调用静态属性,静态方法不再被调用.</span><br><span class="line">8.包装类,String也是final类</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><blockquote>
<p>含义:静态的,公共的</p>
<p>可以修饰:属性,方法,代码块,内部类</p>
<h4 id="修饰属性"><a href="#修饰属性" class="headerlink" title="修饰属性"></a>修饰属性</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点:该属性属于该类的所有对象,该类的一个对象对其进行修改,该类的所有对象的属性都会被修改</span><br><span class="line"></span><br><span class="line">可以使用类名直接调用.</span><br><span class="line">语法:	</span><br><span class="line">	访问权限修饰符  static 数据类型 属性名;</span><br></pre></td></tr></table></figure>

<h4 id="修饰方法-2"><a href="#修饰方法-2" class="headerlink" title="修饰方法"></a>修饰方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点:可以使用类名直接调用,也可以使用对象名调用</span><br><span class="line">语法:</span><br><span class="line">	访问权限修饰符  static 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">		方法体</span><br><span class="line">	&#125;</span><br><span class="line">注意:</span><br><span class="line">	1.不能使用this或super关键字</span><br><span class="line">	2.不能直接使用本类中其他非静态属性或非静态方法</span><br><span class="line">	3.可以直接使用本类的静态属性或静态方法</span><br><span class="line">	4.非静态方法中可以直接使用静态属性或静态方法</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h4 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特点:在类加载时被执行</span><br><span class="line">	注意:一个类在程序运行时,只会被加载一次</span><br><span class="line">语法:</span><br><span class="line">	static&#123;</span><br><span class="line">		代码块</span><br><span class="line">	&#125;</span><br><span class="line">注意:</span><br><span class="line">	1.静态代码快中可以使用静态属性与静态方法,不能直接使用非静态属性和非静态方法</span><br><span class="line">	2.静态代码快与静态属性,谁在前,谁先执行,为了可以再静态代码快中使用静态属性,必须将静态属性声明在静态代码块之前</span><br><span class="line">	</span><br><span class="line">	类加载时机:该类第一次被执行使用时</span><br><span class="line">		1.第一次创建该类对象时</span><br><span class="line">		2.第一次使用该类调用属性时</span><br><span class="line">		3.第一次使用该类调用方法时</span><br><span class="line">		4.第一次使用反射机制加载该类时</span><br></pre></td></tr></table></figure>

<h4 id="继承关系中的执行流程"><a href="#继承关系中的执行流程" class="headerlink" title="继承关系中的执行流程"></a>继承关系中的执行流程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 父类的静态代码块和静态属性</span><br><span class="line">- 子类的静态代码快和静态属性</span><br><span class="line">- 父类的普通代码块和普通属性初始化</span><br><span class="line">- 父类的构造方法</span><br><span class="line">- 子类的普通代码块和普通属性初始化</span><br><span class="line">- 子类的构造方法</span><br></pre></td></tr></table></figure>

<h4 id="创建对象时-在一个类调用的顺序是"><a href="#创建对象时-在一个类调用的顺序是" class="headerlink" title="创建对象时,在一个类调用的顺序是:"></a>创建对象时,在一个类调用的顺序是:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1）调用静态代码块和静态属性初始化（静态代码块和静态属性初始化的调用优先级一样，如果有多个静态代码块和多个静态变量初始化，则按照他们的顺序调用）</span><br><span class="line"></span><br><span class="line">2）调用普通代码块和普通属性的初始化（普通代码块和普通属性初始化调用的优先级一样，如果有多个普通代码块和多个普通属性初始化，则按定义顺序调用）</span><br><span class="line"></span><br><span class="line">3）调用构造方法</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><blockquote>
<p>语法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用:封装一段代码</p>
<p>使用位置:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类中方法外.每次创建该类对象时被调用</span><br><span class="line">	注意:在构造函数之前执行</span><br><span class="line">	普通属性与代码块按顺序执行</span><br></pre></td></tr></table></figure>


</blockquote>
<h1 id="十三-接口"><a href="#十三-接口" class="headerlink" title="十三.接口"></a>十三.接口</h1><p>接口就是给出一些没有实现的方法，封装到一起，到某个类要使用的时候，在根据具体的情况把这些方法写出来</p>
<h2 id="含义"><a href="#含义" class="headerlink" title="含义:"></a>含义:</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">宏观:规则</span><br><span class="line">微观:功能</span><br></pre></td></tr></table></figure>

<h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤:"></a>使用步骤:</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1.定义</span><br><span class="line">&gt;2.使用</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;语法:</span><br><span class="line">	访问权限修饰符  interface 接口名&#123;</span><br><span class="line">		方法体;</span><br><span class="line">	&#125;	</span><br><span class="line">&gt;组成:</span><br><span class="line">公共静态常量</span><br><span class="line">公共静态方法</span><br><span class="line">公共抽象方法</span><br><span class="line">default修饰的普通方法</span><br><span class="line">&gt;注意:公共静态方法和常量默认有public static final</span><br><span class="line">公共抽象方法包含:public abstract</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1.接口使用接口</span><br><span class="line">通过多继承实现接口使用接口</span><br><span class="line">语法:</span><br><span class="line">	public interface 子接口名 extends  父接口名1,父接口名2....&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">注意:不能继承父接口的静态方法,其他的均可继承	</span><br><span class="line">	</span><br><span class="line">&gt;2.类使用接口</span><br><span class="line">&gt;多实现:一个类可以实现多个接口</span><br><span class="line">&gt;语法:</span><br><span class="line">访问权限修饰符 class 子类名 extends 父类名 implements 父接口名1,父接口名2...&#123;&#125;</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">1.一个类可以实现多个接口</span><br><span class="line">2.子类要么重写所有接口提供的抽象方法,要么子类也是抽象类</span><br><span class="line">3.子类对象可以转换为多个实现的接口对象</span><br><span class="line">4.一个接口可以被多个类实现,所以多个类的对象可以转换为同一个接口的对象</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="接口的特殊使用"><a href="#接口的特殊使用" class="headerlink" title="接口的特殊使用"></a>接口的特殊使用</h2><blockquote>
<p><strong>常量接口</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念:只有常量的接口</span><br><span class="line">public interface 接口名&#123;</span><br><span class="line">	数据类型 常量名1 = 值;</span><br><span class="line">	数据类型 常量名2 = 值;</span><br><span class="line">	数据类型 常量名3 = 值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接口回调</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念:接口对象回来调用接口方法</span><br><span class="line"></span><br><span class="line">实例:点击按钮</span><br><span class="line">按钮类</span><br><span class="line">点击事件接口</span><br><span class="line">环境类</span><br><span class="line">	创建点击事件接口对象</span><br><span class="line">	创建按钮对象,传入接口对象</span><br><span class="line">	按钮对象,点击方法</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="细节-1"><a href="#细节-1" class="headerlink" title="细节:"></a>细节:</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1.接口使用implements实现</span><br><span class="line">&gt;2.接口不能继承其他类,但可以继承其他接口(多继承)</span><br><span class="line">&gt;3.接口不能实例化</span><br><span class="line">&gt;4.接口的所有方法是public方法,接口中的抽象方法可以不用abstract修饰</span><br><span class="line">&gt;5.一个普通类实现接口,必须将该接口的方法都实现,或将自己定义为抽象类</span><br><span class="line">&gt;6.一个类可以同时实现多个接口</span><br><span class="line">&gt;7.接口中的属性,只能是final的,而且是public static final修饰符</span><br><span class="line">&gt;8.接口中属性的访问形式:接口名.属性名</span><br><span class="line">&gt;9接口的修饰符只能是public和默认的</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="接口的多态"><a href="#接口的多态" class="headerlink" title="接口的多态"></a>接口的多态</h2><blockquote>
<p>接口存在多态传递,如果接口1继承了接口2,为类1实现了接口1,就相当于类1实现了接口2</p>
</blockquote>
<h1 id="十四-内部类"><a href="#十四-内部类" class="headerlink" title="十四.内部类"></a>十四.内部类</h1><p>作用:补全外部类功能</p>
<h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><blockquote>
<p>在类中定义的类称为内部类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class A&#123;</span><br><span class="line">	public class B&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">A为外部类</span><br><span class="line">B为内部类</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.成员内部类</span><br><span class="line">	位置:类中.方法外</span><br><span class="line">	未使用static修饰</span><br><span class="line">2.静态内部类</span><br><span class="line">	定义位置:类中.方法外</span><br><span class="line">	使用static修饰</span><br><span class="line">3.局部内部类</span><br><span class="line">	定义位置:类中,方法中</span><br><span class="line">4.匿名内部类</span><br><span class="line">	定义位置:定义在外部类的成员位置上,或实参中</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-成员内部类"><a href="#3-成员内部类" class="headerlink" title="3.成员内部类"></a>3.成员内部类</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;可以加访问任何的访问权限修饰符,因为他也是成员</span><br><span class="line"></span><br><span class="line">&gt;成员内部类内部可定义:除去静态成员以外的成员都可以定义</span><br><span class="line">&gt;创建对象:</span><br><span class="line">情况1:在所在的外部类中创建该内部类对象</span><br><span class="line">	内部类类名 对象名 = new 内部类类名(实参列表);</span><br><span class="line">	注意:只是省略this关键字,所以这种创建方式不能再静态方法中使用.</span><br><span class="line">情况2:在其他类中创建该内部类对象</span><br><span class="line">	外部类类名.内部类类名 对象名 = 外部类对象.new 内部类名(实参列表);</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="4-静态内部类"><a href="#4-静态内部类" class="headerlink" title="4.静态内部类"></a>4.静态内部类</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;使用static修饰</span><br><span class="line">&gt;静态内部类所有的成员都可以定义</span><br><span class="line">&gt;创建对象:</span><br><span class="line">外部类类名.内部类类名 对象名 = new 外部类类名.内部类类名(实参列表);</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="5-局部内部类"><a href="#5-局部内部类" class="headerlink" title="5.局部内部类"></a>5.局部内部类</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;注意:</span><br><span class="line">此时不能使用访问权限修饰符</span><br><span class="line">只能在当前方法中使用</span><br><span class="line">&gt;可以定义什么:</span><br><span class="line">除去静态成员,其他成员都可以</span><br><span class="line">&gt;创建对象:</span><br><span class="line">内部类类名 对象名 = new 内部类类名(实参列表);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="6-匿名内部类"><a href="#6-匿名内部类" class="headerlink" title="6.匿名内部类"></a>6.匿名内部类</h3><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;概念:没有类名的内部类称为匿名内部类</span><br><span class="line">&gt;定义位置:定义在外部类的成员位置上,或实参中</span><br><span class="line">&gt;语法:</span><br><span class="line">new 父类名或父接口名()&#123;</span><br><span class="line">	属性</span><br><span class="line">	方法</span><br><span class="line">&#125;;</span><br><span class="line">&gt;注意:</span><br><span class="line">1.一个类只能创建一个对象时,可以使用匿名内部类</span><br><span class="line">2.不能定义静态成员与抽象方法,没有构造函数</span><br><span class="line">&gt;优点:</span><br><span class="line">1.编写方便</span><br><span class="line">&gt;缺点:</span><br><span class="line">2.代码混乱,降低代码可读性</span><br></pre></td></tr></table></figure>

<p>细节:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;1.可以直接访问外部类的所有成员,包含私有</span><br><span class="line">&gt;2.不能添加访问修饰符,他是一个局部变量</span><br><span class="line">&gt;3.作用域:定义他的方法或代码快</span><br><span class="line">&gt;4.如果外部类和内部类的成员重名时，内部类访问的话，默认遵循就近原则，如果想访问外部类成员，则可以使用（外部类.this.成员）</span><br></pre></td></tr></table></figure>


</blockquote>
<h1 id="十五-包装类"><a href="#十五-包装类" class="headerlink" title="十五.包装类"></a>十五.包装类</h1><p>八个基本数据类型所对应的引用数据类型</p>
<p>包装类:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte ----Byte</span><br><span class="line">short----Short</span><br><span class="line">int------Integer</span><br><span class="line">long-----Long</span><br><span class="line">float----Float</span><br><span class="line">double---Double</span><br><span class="line">boolean--Booleab</span><br><span class="line">char-----Character</span><br></pre></td></tr></table></figure>

<p>提供的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">parsexxx();</span><br><span class="line">将相应的包装类转换成基本数据类型</span><br></pre></td></tr></table></figure>

<p>整数缓冲区</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-128~127</span><br><span class="line">原因:</span><br><span class="line">	因为系统中已经创建了-128~127之间有数的对象,在使用自动装箱时,如果值是在该范围内,直接使用已经创建好的对象,如果超过这个返回需要重新创建对象</span><br></pre></td></tr></table></figure>

<h1 id="十六-System"><a href="#十六-System" class="headerlink" title="十六.System"></a>十六.System</h1><p>由JDK提供的类</p>
<p>提供属性或方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static native void arraycopy(Object src,int  srcPos,</span><br><span class="line">                          Object dest, int destPos,</span><br><span class="line">                          int length)</span><br><span class="line">作用:将原数组中的一段数据复制到新数组</span><br><span class="line">	1参:原数组</span><br><span class="line">	2参:复制开始的位置</span><br><span class="line">	3参:新数组</span><br><span class="line"> 4参:新数组开始的位置</span><br><span class="line"> 5参:复制的长度</span><br><span class="line"> </span><br><span class="line">static native long currentTimeMillis()</span><br><span class="line">作用:获取当前时间与1970年1月1日00:00:00:000的时间差(格林威治时间)</span><br><span class="line"></span><br><span class="line">static void exit(int status)</span><br><span class="line">作用:结束当前程序</span><br><span class="line">	1参:终止状态码</span><br><span class="line">		0:正常退出</span><br><span class="line">		1:异常退出</span><br><span class="line"></span><br><span class="line">static void gc()</span><br><span class="line">作用:手动调用垃圾回收机制</span><br></pre></td></tr></table></figure>

<h1 id="十七-Object"><a href="#十七-Object" class="headerlink" title="十七.Object"></a>十七.Object</h1><p>概念：所有类的父类</p>
<p>意味：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">该类提供的属性与方法是所有类的对象都可以使用</span><br></pre></td></tr></table></figure>

<p>提供的方法</p>
<h2 id="1-equals"><a href="#1-equals" class="headerlink" title="1.equals"></a>1.equals</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean equals(Object obj)</span><br><span class="line">	作用:判断调用该方法的对象与传入的对象的内存地址是否相同</span><br><span class="line">	如果子类重写该方法,使用子类对象调用该方法执行的是重写的代码</span><br><span class="line">	如果要比较子类的对象属性值是否相同,要重写equals方法</span><br><span class="line">重写步骤:</span><br><span class="line">	1.判断内存地址是否相同</span><br><span class="line">	2.判断传入的对象是否属于该类对象</span><br><span class="line">	3.将传入的对象转换为该类对象(父类转子类对象)</span><br><span class="line">	4.使用调用该方法的对象的属性与传入的对象属性一一比较</span><br></pre></td></tr></table></figure>

<h2 id="2-toString"><a href="#2-toString" class="headerlink" title="2.toString"></a>2.toString</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public String toString()</span><br><span class="line">作用:获取对象的包名.类拼接@字符串,再拼接对象的内存地址的16进制</span><br><span class="line">注意:</span><br><span class="line">	1.Object提供的toString方法返回的是对象的包名.类@对象内存地址的16进制,可以理解为是对象的信息,但是我们在观察对象时,想看到的是对象的属性值,所以我们可以在子类中重写toString方法,重写后对象在调用toString方法,执行的是重写后的toString方法.</span><br><span class="line">	2.重写toString方法,打印对象或拼接对象时,都会自动调用该对象的toString方法</span><br><span class="line">	3.直接输出一个对象时,toString方法会被默认调用</span><br></pre></td></tr></table></figure>

<h2 id="3-hashCode"><a href="#3-hashCode" class="headerlink" title="3.hashCode"></a>3.hashCode</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:获取对象的哈希码值,近似可以理解为对象的内存地址</span><br><span class="line">注意:</span><br><span class="line">1.提高具有哈希结构的容器的效率</span><br><span class="line">2.两个引用,如果指定的是同一个对象,则哈希值肯定是一样的</span><br><span class="line">3.两个引用,如果指向的是不同的对象,则哈希值是不一样的</span><br><span class="line">4.哈希值主要根据地址号来的,不能完全等价于地址</span><br></pre></td></tr></table></figure>

<h2 id="4-finalize"><a href="#4-finalize" class="headerlink" title="4.finalize"></a>4.finalize</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:系统回收该对象的内存时,才会被调用</span><br><span class="line">注意:</span><br><span class="line">	1.当对象被回收时,系统自动调用该对象的finalize方法,子类可以重写该方法做一些释放资源的操作</span><br><span class="line">	2.当某个对象没有任何引用时,则jvm就认为这个对象是一个垃圾对象,就会使用垃圾回收机制来销毁对象,在销毁前,就先调用finalize</span><br><span class="line">	3.垃圾回收机制的调用,是由系统来决定的,也可以通过System.gc主动触发垃圾回收机制</span><br></pre></td></tr></table></figure>

<h2 id="5-Math"><a href="#5-Math" class="headerlink" title="5.Math"></a>5.Math</h2><p>作用:数学运算与随机数</p>
<p>提供的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static double random();</span><br><span class="line">	作用:随机获取0-1之间的数</span><br><span class="line">	使用:要想获得特定区间的随机数,random*区间最大值+1;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int abs(int a);</span><br><span class="line">	作用:获取其指定数据的绝对值	</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static double floor(double a);</span><br><span class="line">	作用:向下取整</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static double ceil(double a);</span><br><span class="line">	作用:向上取整</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int max(int a , int b)</span><br><span class="line">	作用:获取两数之间的最大值</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int min(int a , int b);</span><br><span class="line">	作用:获取两束之间的最小值</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static double pow(double a,double b)</span><br><span class="line">	作用:计算a的b次幂</span><br></pre></td></tr></table></figure>

<h2 id="6-字符串"><a href="#6-字符串" class="headerlink" title="6.字符串"></a>6.字符串</h2><h3 id="6-1String"><a href="#6-1String" class="headerlink" title="6.1String"></a>6.1String</h3><blockquote>
<p><strong>细节:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.String用于保存字符串,也是一组字符序列</span><br><span class="line">2.字符串常量对象是用双引号括起来的字符序列</span><br><span class="line">3.字符串的字符使用Unicode字符编码,一个字符占两个字节</span><br><span class="line">4.String 实现了很多构造器,构造器重载</span><br><span class="line">5.String是fianl类不能被继承</span><br><span class="line">6.Stirng保存字符串时保存在private final char value[];</span><br><span class="line">7.value是final类型,赋值后不能修改(地址不能修改,值可以修改),一个字符串对象一旦分配,其内容是不可变的,指向改变</span><br><span class="line">8.String 这个类实现了Serializable,说明String可以串行化,可以网络传播</span><br><span class="line">9.String这个类实现了Comparable,说明String对象可以比较</span><br></pre></td></tr></table></figure>

<p><strong>创建方式:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.直接赋值</span><br><span class="line">	String s = &quot;hhhh&quot;;</span><br><span class="line">先从常量池查看是否有&quot;hhhhhh&quot;数据空间,如果有,直接指向:如果没有,则重新创建,然后指向,s最终指向的是常量池的地址空间</span><br><span class="line">2.调用构造器</span><br><span class="line">	String s = new String(&quot;xxxx&quot;);</span><br><span class="line">	先从堆中创建空间,里面维护了value属性,指向常量池的&quot;xxxx&quot;的空间,如果常量池没有&quot;xxxx&quot;重新创建,如果有,直接通过value指向,最终指向的是堆中的空间</span><br></pre></td></tr></table></figure>

<p><strong>常见方法:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">replace</span><span class="params">(String old,String newStr)</span></span><br><span class="line">	作用:替换</span><br><span class="line">	<span class="number">1</span>参:要被替换的字符串</span><br><span class="line">	<span class="number">2</span>参:替换后的字符串	</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">length</span><span class="params">()</span></span><br><span class="line">	作用:获取字符串长度</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span></span><br><span class="line">	作用:获取字符串中指定位置的字符</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">char</span>[] toCharArray()</span><br><span class="line">	作用:将字符串转换为字符数组</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span></span><br><span class="line">	作用:比较字符串内容是否相同</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equalsIgnoreCase</span><span class="params">(String anotherString)</span></span><br><span class="line">	作用:忽略大小写比较字符串内容是否相同</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">trim</span><span class="params">()</span></span><br><span class="line">	作用:忽略前后空白</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">endsWith</span><span class="params">(String suffix)</span></span><br><span class="line">	作用:判断字符串是否以指定的字符串结束</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span></span><br><span class="line">	作用:判断字符串以什么开始</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toUpperCase</span><span class="params">()</span></span><br><span class="line">	作用:将字符串中的小写字母转换为大写字母</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toLowerCase</span><span class="params">()</span></span><br><span class="line">	作用:将字符串中的大写字母转换为小写字母</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(String s)</span></span><br><span class="line">	作用:判断s是否在调用该方法的字符串中存在</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(String str)</span></span><br><span class="line">	作用:获取指定的子字符串在字符串中最后一次出现的位置</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span></span><br><span class="line">	作用:获取指定的子字符串在字符串中第一次出现的位置</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span></span><br><span class="line">	作用:截取指定位置的字符串,从开始位置到字符串末尾</span><br><span class="line">	beginIndex:开始位置</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex , <span class="type">int</span> endIndex)</span></span><br><span class="line">	作用:截取指定位置的字符串</span><br><span class="line">	<span class="number">1</span>参:开始位置</span><br><span class="line">	<span class="number">2</span>参:结束位置	</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex)</span><br><span class="line">	作用:切割</span><br><span class="line">	<span class="number">1</span>参:按什么字符串切割</span><br></pre></td></tr></table></figure>

<p>构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[])</span></span><br><span class="line">	将传入的字符数组转换为字符串</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[],<span class="type">int</span> offset,<span class="type">int</span> count)</span></span><br><span class="line">	在<span class="type">char</span>数组中,从offset开始截取count位字符	</span><br></pre></td></tr></table></figure>


</blockquote>
<h3 id="6-2StringBuffer和StringBuilder"><a href="#6-2StringBuffer和StringBuilder" class="headerlink" title="6.2StringBuffer和StringBuilder"></a>6.2StringBuffer和StringBuilder</h3><p><strong>长度可变</strong></p>
<h4 id="1-StringBuffer"><a href="#1-StringBuffer" class="headerlink" title="1.StringBuffer"></a>1.StringBuffer</h4><p>​	特点:jdk1.0出现,线程安全的,效率低</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">StringBuffer是一个容器</span><br><span class="line">	1.StringBuffer的直接父类是AbstractStringBuilder</span><br><span class="line">	2.StringBuffer实现了Serializable,即StringBuffer的对象可以串行化</span><br><span class="line">	3.在父类中有一个属性char[] value,不是final</span><br><span class="line">	4.该value数组中存放字符串内容,引出存放在堆中的StringBuffer是一个public final class,所以StringBuffer不能被继承</span><br><span class="line">	5.因为StringBuffer字符内容是存在char[]value,所以增加和删除不用每次都更换地址,即每次都创建新的对象,故效率高于String</span><br></pre></td></tr></table></figure>

<h4 id="2-StringBuilder"><a href="#2-StringBuilder" class="headerlink" title="2.StringBuilder"></a>2.StringBuilder</h4><p>特性:JDK1.5出现,线程不安全,效率高</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.一个可变字符序列,此类提供了一个与StringBuffer兼容的API,但不保证同步(StringBuilder不是线程安全的),该类被设计用做StringBuffer的一个简易替换,用在字符串缓存区被单个线程使用的时候,如果可能,简易有先采用StringBuilder,在大多数实现中,他比StringBuffer要快</span><br><span class="line">2.在StringBuilder上主要操作的是append和insert方法,可重载这些方法,以便于接受任意类型的数据</span><br><span class="line">3.单线程的情况下使用StringBuilder</span><br></pre></td></tr></table></figure>

<h4 id="3-提供的方法"><a href="#3-提供的方法" class="headerlink" title="3.提供的方法"></a>3.提供的方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.StringBuilder append(Object obj)</span><br><span class="line">	作用:给字符串尾部拼接字符串</span><br><span class="line">2.StringBuilder insert(int offset , String str)</span><br><span class="line">	作用:插入</span><br><span class="line">	1参:插入开始的位置</span><br><span class="line">	2参.插入的数据</span><br><span class="line">3.StringBuilder delete(int start,int end)</span><br><span class="line">	作用:删除指定区间的数据</span><br><span class="line">	1参:开始位置,包含</span><br><span class="line">	2餐:结束位置,不包含</span><br><span class="line">4.StringBuilder deleteCharAt(int index)</span><br><span class="line">	作用:删除指定位置的字符</span><br><span class="line">	1参:指定位置</span><br><span class="line">5.StringBuilder replace(int start ,int end,String str)</span><br><span class="line">	作用:替换</span><br><span class="line">	1.参:要替换的数据的开始位置,包含</span><br><span class="line">	2.参:要替换的数据的结束位置,不包含</span><br><span class="line">	3.替换后的字符串</span><br><span class="line">6.toString()</span><br><span class="line">	作用:将可变字符转换为不可变字符</span><br><span class="line">	StringBuffer str = new StringBuffer();</span><br><span class="line">	String s = str.toString();</span><br><span class="line">	</span><br><span class="line">	不可变字符转可变字符</span><br><span class="line">	String str = &quot;hello&quot;;</span><br><span class="line">	StringBuffer s = new StringBuffer(str);</span><br></pre></td></tr></table></figure>

<h1 id="十八-BigDecimal和BigInteger"><a href="#十八-BigDecimal和BigInteger" class="headerlink" title="十八.BigDecimal和BigInteger"></a>十八.BigDecimal和BigInteger</h1><h2 id="1-BigDeciamal"><a href="#1-BigDeciamal" class="headerlink" title="1.BigDeciamal"></a>1.BigDeciamal</h2><p>适合保存精度更高的浮点型</p>
<p>构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BigDeciaml(Object obj);</span><br></pre></td></tr></table></figure>

<p>提供方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BigDecimal subtract(BigDecimal subtrahend)</span><br><span class="line">	作用:减法,使用调用该方法的对象的值减去传入的对象的值,返回计算结果</span><br><span class="line">BigDecimal add(BigDecimal augend)</span><br><span class="line">	作用:加法</span><br><span class="line">BigDeciamal multiply(BigDecimal multiplicand)</span><br><span class="line">	作用:乘法</span><br><span class="line">BigDeciaml divide(BigDecimal divisor)</span><br><span class="line">	作用:除法</span><br><span class="line">xxx xxxValue();</span><br><span class="line">	作用:获取BigDeciaml的值</span><br></pre></td></tr></table></figure>

<h2 id="2-BigInterger"><a href="#2-BigInterger" class="headerlink" title="2.BigInterger"></a>2.BigInterger</h2><p>BigInteger适合保存比较大的整型</p>
<p>方法同上</p>
<h1 id="十九-时间相关类"><a href="#十九-时间相关类" class="headerlink" title="十九.时间相关类"></a>十九.时间相关类</h1><h2 id="1-Date"><a href="#1-Date" class="headerlink" title="1.Date"></a>1.Date</h2><p>概念:日期</p>
<p>创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//public Date();获取当前系统时间</span></span><br><span class="line"><span class="comment">//public Date(long date);</span></span><br><span class="line"><span class="comment">//获取距离1970年1月1日00.00.00的时间,单位毫秒</span></span><br><span class="line">	</span><br><span class="line">	<span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">        System.out.println(date);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(date1);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Date</span>()默认输出的格式为国外</span><br><span class="line">就需要格式转换,通过创建SimpleDateFormat对象可以指定格式: yyyy年MM月dd日  hh:mm:ss E</span><br><span class="line">E代表星期中的天数</span><br><span class="line"></span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy年MM月dd日 hh:mm:ss E&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​	format:将时间对象转换为指定格式的字符串<br>​	parse:将指定格式的字符串转换为时间</p>
<p>before,after</p>
<h2 id="2-Calendar"><a href="#2-Calendar" class="headerlink" title="2.Calendar"></a>2.Calendar</h2><p>概念:日历</p>
<p>创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static Calender getInstance()</span><br></pre></td></tr></table></figure>

<p>方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">get</span><br><span class="line">System.out.println(&quot;年&quot;+instance.get(Calendar.YEAR));</span><br><span class="line">System.out.println(&quot;月&quot;+(instance.get(Calendar.MONTH)+1));//Calender&#x27;是按照0开始编号</span><br><span class="line">System.out.println(&quot;日&quot;+instance.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">System.out.println(&quot;小时&quot;+instance.get(Calendar.HOUR));</span><br><span class="line">System.out.println(&quot;分钟&quot;+instance.get(Calendar.MINUTE));</span><br><span class="line">System.out.println(&quot;秒&quot;+instance.get(Calendar.SECOND));</span><br><span class="line">set</span><br><span class="line">add</span><br><span class="line">getTime</span><br></pre></td></tr></table></figure>

<h2 id="3-第三代时间"><a href="#3-第三代时间" class="headerlink" title="3.第三代时间"></a>3.第三代时间</h2><p>在JDK8中加入了LocalDate(日期)，LocalTime(时间)，LocalDateTime（日期时间）</p>
<ul>
<li><p>LocalDate只包含日期，可以获取日期字段</p>
</li>
<li><p>LocalTime只包含时间，可以获取时间字段</p>
</li>
<li><p>LocalDateTime包含日期+时间，可以获取日期和时间字段</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用now返回表示当前时间的对象</span></span><br><span class="line">   <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">   System.out.println(now);</span><br><span class="line">   System.out.println(<span class="string">&quot;年:&quot;</span>+now.getYear());</span><br><span class="line">   System.out.println(<span class="string">&quot;月:&quot;</span>+now.getMonth());</span><br><span class="line">   System.out.println(<span class="string">&quot;月:&quot;</span>+now.getMonthValue());</span><br><span class="line">   System.out.println(<span class="string">&quot;日:&quot;</span>+now.getDayOfMonth());</span><br><span class="line">   System.out.println(<span class="string">&quot;时:&quot;</span>+now.getHour());</span><br><span class="line">   System.out.println(<span class="string">&quot;分:&quot;</span>+now.getMinute());</span><br><span class="line">   System.out.println(<span class="string">&quot;秒:&quot;</span>+now.getSecond());</span><br><span class="line"></span><br><span class="line"> <span class="comment">//可以获取年月日</span></span><br><span class="line">   <span class="type">LocalDate</span> <span class="variable">now1</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">   System.out.println(now1.getYear());</span><br><span class="line">   <span class="comment">//可以获取时分秒</span></span><br><span class="line">   <span class="type">LocalTime</span> <span class="variable">now2</span> <span class="operator">=</span> LocalTime.now();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//使用DateTimeFormatter  格式日期类</span></span><br><span class="line"><span class="type">LocalDateTime</span> <span class="variable">now3</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dateTimeFormatter</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy年MM月dd日  HH时mm分ss秒&quot;</span>);</span><br><span class="line">String str=dateTimeFormatter.format(now3);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure>

<h1 id="二十-泛型"><a href="#二十-泛型" class="headerlink" title="二十.泛型"></a>二十.泛型</h1><p>作用:将数据类型作为参数传递</p>
<p>语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定义:</span><br><span class="line">	&lt;泛型1,泛型2...&gt;</span><br><span class="line">	情况1:在方法上</span><br><span class="line">		访问权限修饰符 修饰符 &lt;泛型1,泛型2...&gt; 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	情况2:在类上定义</span><br><span class="line">    	访问权限修饰符 class 类名&lt;泛型1,泛型2...&gt;&#123;&#125;</span><br><span class="line"> </span><br><span class="line"> 使用:</span><br><span class="line"> 	泛型名</span><br><span class="line"> 		情况1:在方法中使用</span><br><span class="line"> 			在方法中任意使用数据类型的地方都可以使用该泛型作为数据类型</span><br><span class="line"> 		情况2:在类中使用</span><br><span class="line">        	在类中任意使用数据类型的地方都可以使用该泛型作为数据类型</span><br></pre></td></tr></table></figure>

<p>注意:<strong>泛型中只能使用引用数据类型</strong></p>
<h1 id="二十一-集合"><a href="#二十一-集合" class="headerlink" title="二十一.集合"></a>二十一.集合</h1><h3 id="1-作用-2"><a href="#1-作用-2" class="headerlink" title="1.作用"></a>1.作用</h3><blockquote>
<p>动态的存储一组数据类型相同的数据</p>
</blockquote>
<h3 id="2-特点-1"><a href="#2-特点-1" class="headerlink" title="2.特点"></a>2.特点</h3><blockquote>
<p>长度可变</p>
</blockquote>
<h3 id="3-名称"><a href="#3-名称" class="headerlink" title="3.名称"></a>3.名称</h3><blockquote>
<p>长度:集合中存在的元素个数</p>
<p>下标:元素在集合中的位置</p>
<p>元素:集合中存储的数据</p>
</blockquote>
<h3 id="4-体系结构"><a href="#4-体系结构" class="headerlink" title="4.体系结构"></a>4.体系结构</h3><blockquote>
<h2 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1.Collection"></a>1.Collection</h2><p>分类:List,Set</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;List</span><br><span class="line">特点:有序(存入和取出顺序一致),由下标,可以重复</span><br><span class="line">子类:</span><br><span class="line">	ArrayList:</span><br><span class="line">		特点:JDK1.2出现,线程不安全的</span><br><span class="line">		数据结构:数组</span><br><span class="line">		特点:查询效率高,增删效率低</span><br><span class="line">	LinkedList</span><br><span class="line">      特点:查询效率低,增删效率高</span><br><span class="line">      数据结构:链表</span><br><span class="line">   Vector:</span><br><span class="line">      特点:JDK1.0出现,线程安全</span><br><span class="line">      数据结构:数组</span><br><span class="line">      </span><br><span class="line">&gt;Set</span><br><span class="line">特点:无序,无下标,元素不允许重复</span><br><span class="line">子类:</span><br><span class="line">	HashSet</span><br><span class="line">		底层:HashMap</span><br><span class="line">		数据结构:</span><br><span class="line">			JDK1.8以前数组+链表</span><br><span class="line">			JDK1.8之后数组+链表+红黑树</span><br><span class="line">	TreeSet</span><br><span class="line">      数据结构:红黑树</span><br><span class="line">      注意:指定比较规则</span><br><span class="line">  LinkedHashSet</span><br><span class="line">      特点:有序</span><br><span class="line">      数据结构:数组+双向链表</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="Collection提供的方法"><a href="#Collection提供的方法" class="headerlink" title="Collection提供的方法"></a>Collection提供的方法</h2><blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;增:</span><br><span class="line">boolean add(E e)</span><br><span class="line">	作用:一次添加一个数据</span><br><span class="line">	参数:要添加的数据</span><br><span class="line">	返回值:是否添加成功</span><br><span class="line">boolean addAll(Collection&lt;? extends E&gt; c);</span><br><span class="line">作用:一次添加一组数据</span><br><span class="line">参数:要添加的数据集合</span><br><span class="line">返回值:</span><br><span class="line">	是否添加成功,哪怕只添加一个也算成功,全部失败才是失败</span><br><span class="line"></span><br><span class="line">&gt;删:</span><br><span class="line">boolean remove(Object o)</span><br><span class="line">	作用:一次删除一个数据</span><br><span class="line">	参数:要删除的数据</span><br><span class="line">	返回值:是否删除成功</span><br><span class="line">	注意:如果集合中有多个要删除的数据,智能删除第一个</span><br><span class="line">boolean removeAll(Collection&lt;?&gt; c)</span><br><span class="line">作用:一次删除一组数据</span><br><span class="line">参数:要删除的数据集合</span><br><span class="line">返回值:是否删除成功</span><br><span class="line">注意:如果原集合中多次出现删除集合中的数据,那么元集合中的该数据会全部被删除</span><br><span class="line">&gt;void clear()</span><br><span class="line">作用:清空集合中的数据</span><br><span class="line">&gt;查:</span><br><span class="line">int size()</span><br><span class="line">	作用:查询集合长度</span><br><span class="line">boolean contains(Object o);</span><br><span class="line">作用:判断集合中是否包含指定元素</span><br><span class="line">&gt;boolean containsAll(Collection&lt;?&gt; C)</span><br><span class="line">作用:判断集合中是否全部包含指定的集合中的元素</span><br><span class="line">注意:判断的是是否全部包含</span><br><span class="line">&gt;boolean isEmpty();</span><br><span class="line">作用:判断集合是否为空集合</span><br><span class="line">注意:空集合表示集合中没有元素,而不是集合为null</span><br><span class="line">&gt;Iterator&lt;E&gt; Iterator()</span><br><span class="line">作用:获取当前集合的迭代器</span><br><span class="line">迭代器方法:</span><br><span class="line">	boolean hasNext();判断下一个是否有值</span><br><span class="line">	E next(); 移动游标,并返回指向的数据</span><br></pre></td></tr></table></figure>

<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;遍历:</span><br><span class="line">迭代器</span><br><span class="line">foreach</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="5-List提供的方法"><a href="#5-List提供的方法" class="headerlink" title="5.List提供的方法"></a>5.List提供的方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增:</span><br><span class="line">	void add(int index, E element)</span><br><span class="line">	作用:给指定位置插入一个数据</span><br><span class="line">    void addAll(int index,Collection&lt;E&gt; C)</span><br><span class="line">    作用:给指定位置插入一组数据</span><br><span class="line">    </span><br><span class="line">删:</span><br><span class="line">	E remove(int index)</span><br><span class="line">		作用:删除指定位置的数据</span><br><span class="line"></span><br><span class="line">改:</span><br><span class="line">	E set(int index,E element)</span><br><span class="line">		作用:修改指定位置的元素</span><br><span class="line">		参数:1参,指定的位置;2参,修改后的元素</span><br><span class="line">	</span><br><span class="line">查:</span><br><span class="line">	E get(int index)</span><br><span class="line">		作用:获取指定位置的元素</span><br></pre></td></tr></table></figure>

<h3 id="6-HashSet的剔重原理"><a href="#6-HashSet的剔重原理" class="headerlink" title="6.HashSet的剔重原理"></a>6.HashSet的剔重原理</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.存入对象先判断对象的hashCode值是否与已经存储的数据hashcode值是否相同</span><br><span class="line">2.如果相等,在使用本次存入的对象与集合中的对象使用equals方法一一比较</span><br><span class="line">3.如果equals也相同,认为对象已经存储,将不再存入该对象</span><br></pre></td></tr></table></figure>

<h3 id="7-TreeSet存储"><a href="#7-TreeSet存储" class="headerlink" title="7.TreeSet存储"></a>7.TreeSet存储</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TreeSet存储的数据</span><br><span class="line">要么拥有比较性(让存储的对象的类实现Comparable)</span><br><span class="line">要么指定比较器(创建TreeSet传入Comparator对象)</span><br></pre></td></tr></table></figure>

<h1 id="二十二-Map"><a href="#二十二-Map" class="headerlink" title="二十二.Map"></a>二十二.Map</h1><h3 id="1-作用-3"><a href="#1-作用-3" class="headerlink" title="1.作用:"></a>1.作用:</h3><p>​			存储一组键值对应的数据类型的数据</p>
<h3 id="2-方法"><a href="#2-方法" class="headerlink" title="2.方法"></a>2.方法</h3><blockquote>
<p>名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">键:key</span><br><span class="line">值:value</span><br></pre></td></tr></table></figure>

<p>体系结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Map</span><br><span class="line">	HashMap</span><br><span class="line">		特点:使用键值对的中键的hashcode值进行排序,允许空键空值,JDK1.2,线程不安全的</span><br><span class="line">	Hashtable</span><br><span class="line">		特点:使用键值对的中键的hashcode值进行排序,不允许空键空值,JDK1.0,线程安全的</span><br><span class="line">	TreeMap</span><br><span class="line">		特点:要求键要么拥有比较性,要么指定key的比较器</span><br><span class="line">	Properties</span><br><span class="line">		特点:HashMap的子类,可以加载读取文件中的内容,也可以向文件中写入内容</span><br><span class="line">注意:</span><br><span class="line">	key值不能重复</span><br></pre></td></tr></table></figure>

<p>Map提供的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">增</span><br><span class="line">	V put(K key, V value);</span><br><span class="line">		作用:添加</span><br><span class="line">		注意:</span><br><span class="line">			如果map中不存在该key,返回值为null</span><br><span class="line">			如果map中存在该key那么此时就是替换,返回被替换的值</span><br><span class="line">	void putAll(Map&lt;? extends K, ? extends V&gt; m);</span><br><span class="line">		作用:添加一组键值对</span><br><span class="line">删</span><br><span class="line">	V remove(Object key);</span><br><span class="line">		作用:通过key删除指定的键值对</span><br><span class="line">		返回值:被删除的值</span><br><span class="line">	void clear();</span><br><span class="line">		作用:清空</span><br><span class="line">查</span><br><span class="line">	int size();</span><br><span class="line">		作用:查询map中键值对的个数</span><br><span class="line">	boolean isEmpty();</span><br><span class="line">		作用:判断是否为空map</span><br><span class="line">	boolean containsKey(Object key);</span><br><span class="line">		作用:判断是否包含指定的key</span><br><span class="line">	boolean containsValue(Object value);</span><br><span class="line">		作用:判断是否包含指定的value</span><br><span class="line">	V get(Object key);</span><br><span class="line">		作用:获取key指定的值</span><br><span class="line">	Set&lt;K&gt; keySet();</span><br><span class="line">		作用:获取所有key的集合</span><br><span class="line">	Collection&lt;V&gt; values();</span><br><span class="line">		作用:获取所有值的集合</span><br><span class="line">	Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="line">		作用:获取所有键值对的集合	</span><br><span class="line">改</span><br><span class="line">	V put(K key, V value);</span><br><span class="line">		注意:如果存储数据时,key已经存在,此时就是修改**Map接口的遍历方式**</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-特点"><a href="#3-特点" class="headerlink" title="3.特点:"></a>3.特点:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Map和collection并列存在,用于保存具有映射关系的数据Key-Value</span><br><span class="line">2.Map中的Key和Value可以是任何引用数据类型,会封装到HashMap&amp;$Node对象中</span><br><span class="line">3.Map中的Key不允许重复,有相同的key时,采用替换机制,新出现的替换已有的,原因和HashSet一样</span><br><span class="line">4.Map中value可重复</span><br><span class="line">5.Map的key可以为null,value也可以为null,key只能有一个null,value为null可以有多个</span><br><span class="line">6.常用的String类可作为Map的key</span><br><span class="line">7.key和value之间存在一对一关系，及通过指定可以总能找到对应的value。</span><br></pre></td></tr></table></figure>



<h3 id="4-Map接口的遍历方式"><a href="#4-Map接口的遍历方式" class="headerlink" title="4.Map接口的遍历方式"></a><strong>4.Map接口的遍历方式</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map=<span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">     map.put(<span class="string">&quot;舒克&quot;</span>,<span class="string">&quot;贝塔&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;李大头&quot;</span>,<span class="string">&quot;李大脑袋&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;郭德纲&quot;</span>,<span class="string">&quot;于谦&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;岳云鹏&quot;</span>,<span class="string">&quot;孙越&quot;</span>);</span><br><span class="line">     map.put(<span class="literal">null</span>,<span class="string">&quot;kk&quot;</span>);</span><br><span class="line">     map.put(<span class="string">&quot;king&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;===========第一种遍历===========&quot;</span>);</span><br><span class="line">     <span class="comment">//第一种遍历，先取出所有的Key，再通过Key取出对应的value</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">keyset</span> <span class="operator">=</span> map.keySet();</span><br><span class="line">    <span class="comment">//(1)增强for</span></span><br><span class="line"><span class="keyword">for</span> (Object key :keyset) &#123;</span><br><span class="line">    System.out.println(key+<span class="string">&quot;-&quot;</span>+map.get(key));</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//（2）迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator</span> <span class="operator">=</span> keyset.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span>  iterator.next();</span><br><span class="line">    System.out.println(key + <span class="string">&quot;-&quot;</span> + map.get(key));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;===========第二种遍历===========&quot;</span>);</span><br><span class="line"><span class="comment">//第二种，把所有的value取出</span></span><br><span class="line"><span class="type">Collection</span> <span class="variable">values</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="comment">//可以使用collection使用的所有遍历方式</span></span><br><span class="line"><span class="comment">//(1)迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator1</span> <span class="operator">=</span> values.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator1.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span>  iterator1.next();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//(2)for增强</span></span><br><span class="line"><span class="keyword">for</span> (Object o :values) &#123;</span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;============第三种遍历============&quot;</span>);</span><br><span class="line"><span class="comment">//第三种遍历方式，通过EntrySet获取</span></span><br><span class="line"><span class="type">Set</span> <span class="variable">entryset</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line"><span class="comment">//（1）增强for</span></span><br><span class="line"><span class="keyword">for</span> (Object entryset1 :entryset) &#123;</span><br><span class="line">    <span class="comment">//将entryset1转成Map.entry</span></span><br><span class="line">    Map.Entry m=(Map.Entry) entryset1;</span><br><span class="line">    System.out.println(m.getKey()+<span class="string">&quot;-&quot;</span>+m.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//（2）迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">iterator2</span> <span class="operator">=</span> entryset.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator2.hasNext()) &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">next</span> <span class="operator">=</span>  iterator2.next();</span><br><span class="line">     <span class="comment">//将iterator2转成Map.entry</span></span><br><span class="line">    Map.Entry m1=(Map.Entry) next;</span><br><span class="line">    System.out.println(m1.getKey()+<span class="string">&quot;-&quot;</span>+m1.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="5-开发中如何选择集合实现类"><a href="#5-开发中如何选择集合实现类" class="headerlink" title="5.开发中如何选择集合实现类*"></a>5.<em>开发中如何选择集合实现类</em>*</h3><ol start="3">
<li><pre><code>/*开发中如何选择集合实现类**
  
1. **先判断存储的类型（一组对象或一组键值对）**

2. **一组对象（单列）：collection接口**
   **允许重复：List**
            **增删多：LinkedList   底层维护了一个双向链表**
            **改查多：ArrayList    底层维护Object类型的可变数组**
   **不允许重复  Set**
            **无序:HashSet 底层是HashMap  维护了一个哈希表即数组+链表+红黑树**
            **排序：TreeSet**
            **插入和取出顺序一致：LinkedHashSet，维护数组+双向链表**

3. **一对键值对（双列）：Map**
   **键无序：HashMap  底层是：哈希表  jdk7：数组+链表   jdk8：数组+链表+红黑树**
   **键排序：TreeMap

   **键插入和取出顺序一致：LinkedHashMap
   
   **读取文件：Properties
   */
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 6.扩容机制</span><br><span class="line"></span><br></pre></td></tr></table></figure>
**扩容机制：**

1. HashMap底层维护了Node类型的数组table，默认为nll
2. 当创建对象时，将加载因子（loadfactor）初始化为0.75
3. 当添加key-value时，通过key的哈希值得到table的索引，然后判断该索引处是否有元素，如果没有元素直接添加，如果该索引处有元素，判断钙元素的key是否和准备加入的key相等，如果相等，则直接替换val：如果不相等需要判断是树结构还是链表结构，做出相应的处理，如果添加时发现容量不够，则需要扩容
4. 第一次添加，则需要扩容table容量为16，临界值为12
5. 以后再扩容，则需要扩容table容量为原来的2倍32，临界值为原来的2倍，即24，以此类推
6. 在java8中，如果一条链表的元素个数超过TREEIFY_THRESHOLD(默认为8)，并且table的大小&gt;=MIN_TREEIFY_CAPACITY(默认64)就会进行树化
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 7.HashTable</span><br><span class="line"></span><br></pre></td></tr></table></figure>
1. 存放的元素时键值对 k-v
2. hashtable的键和值都不能为空
3. hashtable使用方法和HashMap基本一样
4. hashtable是线程安全的
5. hashtable底层有数组hashtable$Entry[]初始值为11，threshold=8
6. 扩容按照自己的扩容机制进行
7. 扩容时执行addEntry（hash，key，value，index）；添加一个k-v封装在Entry
8. 当count&gt;=threshold时就进行扩容
9. 新的扩容时  （旧容量&lt;&lt;1）+1
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   ### 8.Properties</span><br><span class="line"></span><br><span class="line">4. properties类继承自hashtable类并且实现了Map接口，也是使用一种键值对的形式保存数据</span><br><span class="line"></span><br><span class="line">5. 使用特点和hashtable类似，不能有空的键和空的值</span><br><span class="line"></span><br><span class="line">6. properties可以用于从  xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改</span><br><span class="line"></span><br><span class="line">7. 说明xxx.properties文件通常作为配置文件</span><br><span class="line"></span><br><span class="line">### 9.collection工具类</span><br><span class="line"></span><br><span class="line">1.  Collections是一个操作Set、List、Map等集合的工具类</span><br><span class="line">2.  Collections中提供了一系列静态的方法对集合元素进行排序、查询、修改等操作</span><br><span class="line">3.  排序操作：（均为static方法）</span><br><span class="line">    - resverse（List）：反转List中元素的顺序</span><br><span class="line">    - shuffle（List）：对List集合元素进行随机排序</span><br><span class="line">    - sort（List）：根据元素的自然顺序对指定的lisdt集合元素按升序排序</span><br><span class="line">    - sort（List，Comparator）：根据指定的Comparator产生的顺序对List集合元素进行排序</span><br><span class="line">    - swap（List，int，int）：将指定list集合中i处元素和j处元素进行交换</span><br><span class="line"></span><br><span class="line">4.查找，替换</span><br><span class="line"></span><br><span class="line">- Object max（Collection）:根据元素的自然顺序，返回给的集合中最大的元素</span><br><span class="line">- Object  max（Collection，Comparator）根据Comparator指定的顺序，返回给定集合中最大的元素4</span><br><span class="line">- Object min（Collection）</span><br><span class="line">- Object  min（Collection，Comparator）</span><br><span class="line">- int  frequency（Collection，Object）将返回指定集合中指定元素出现的次数</span><br><span class="line">- void copy（List dest，List dest）将src中的内容复制到dest中</span><br><span class="line">- boolean  replaceAll（List list，Object oldVal，Object newVal）使用新值替换List对象的所有旧值</span><br><span class="line"></span><br><span class="line"># 二十三.异常</span><br><span class="line"></span><br><span class="line">### 1.概念:</span><br><span class="line"></span><br><span class="line">在java语言中,将程序执行中发生的不正常情况称为异常</span><br><span class="line"></span><br><span class="line">### 2.分类:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<p>1.Error:java虚拟机无法解决的严重问题,如jvm系统内部错误,资源耗尽等</p>
<p>2.Exception:因编程错误,或偶然的外部因素导致的一般性问题,可以使用正对性的代码处理,例如空指针访问,网络中断等.</p>
<p>Exception分为两大类,运行时异常和编译时异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">检查时异常</span><br><span class="line">		概念:因语法问题导致的错误</span><br><span class="line">		解决:修改语法</span><br><span class="line">	运行时异常</span><br><span class="line">		概念:但是因为编写时思路问题,或传入的数据导致程序无法正常运行</span><br><span class="line">		解决:更换思路,修改传入的数据,加入容错判断</span><br><span class="line"></span><br><span class="line">体系结构:</span><br><span class="line"></span><br><span class="line">​	Throwable:</span><br><span class="line"></span><br><span class="line">​				Error(错误)</span><br><span class="line"></span><br><span class="line">​				Exception(异常)	:CheckedException(检查时异常),RuntimeException(运行时异常)</span><br><span class="line"></span><br><span class="line">### 3.五大运行异常</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li><p>NullPointerException 空指针异常</p>
<p>当应用程序试图在需要对象的地方使用null时，抛出该异常</p>
</li>
<li><p>ArithmeticException  数学运算异常</p>
<p>当出现异常的运算条件时，抛出此异常</p>
</li>
<li><p>ArrayIndexOutOfBoundsException数组下标越界异常</p>
<p>用非法索引访问数组时抛出异常，如果索引为负或大于等于数组，则为非法索引</p>
</li>
<li><p>ClassCastException类型转换异常</p>
<p>当时图将对象强制转换为不是实例的子类时，抛出该异常</p>
</li>
<li><p>NumberFormatException数字格式不正确异常</p>
<p>当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常&#x3D;&gt;使用异常我们可以确保输入是满足条件数字</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 4.编译异常</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>SQLException    操作数据库时查询表可能发生异常</p>
<p>IOException   操作文件时发生异常</p>
<p>FileNotFoundException     当操作一个不存在的文件时，发生异常</p>
<p>ClassNotFoundException    加载类，而类不存在时，发生异常</p>
<p>EOFException    操作文件，到文件末尾，发生异常</p>
<p>IllegalArguementException    参数异常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 5.异常处理方式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>try-catch<br>    语法:<br>    try{<br>        异常代码<br>    }catch(异常类型 变量名){<br>        处理方式<br>    }catch(异常类型 变量名){<br>        处理方式<br>    }…..<br>    catch(异常类型 变量名){<br>        处理方式<br>    }finally{<br>        必须执行的代码<br>    }<br>注意:<br>    1.如果发生异常,则异常后面的代码不再执行,直接进入catch<br>    2.如果没有异常发生,则顺序执行try的代码块,不会进入catch<br>    3.如果希望不管是否发生异常,都执行某段代码(关闭连接,释放资源)则使用finally<br>    4.可以有多个catch语句，捕获不同的异常（进行不同的业务处理），要求父类异常在后，子类异常在前，比如（Exception在后，NULLpointerException在前）如果发生异常，只会匹配一个catch<br>    5.也可以使用try-finally配合使用，<strong>这种用法相当于没有捕获异常</strong>，因此程序会崩。应用场景，就是执行一段代码，不管是否发生异常，都必须执行某个业务逻辑<br>    6.捕获异常后，有return时，执行return但不会返回return的后缀，  执行finally</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>throws:<br>    将发生的异常抛出,交给调用者自行处理,最顶尖的处理者是JVM<br>    语法:<br>        throws 异常类型1,异常类型2….<br>        使用位置方法的形参之后</p>
<p>基本介绍:<br>    1.如果一个方法中的语句执行时,可能生成某种异常,但是并不能确定如何处理这种异常,则此方法应显示声明抛出异常,表明该方法将不对异常进行处理,而是由方法的调用者处理<br>    2.在方法声明时,可以使用throws抛出异常,throws后面的异常类型可以是方法中产生的异常类型,也可以是它的父类.<br>    3.throws可以抛出多个异常</p>
<p>细节:	<br>    1. 对于编译异常，程序中必须处理，比如：try-catch或者throws<br>    2. 对于运行时异常，程序中如果没有处理，默认就是throws的处理方式<br>    3. 子类重写父类方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要么和父类抛出的异常一致，要么为父类抛出异常类型的子类<br>    4. 在throws过程中，如果有方法try-catch，就相当于处理异常，就可以不必thows</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>throw<br>    声明异常<br>    语法:<br>        throw 异常对象;<br>    位置:方法中	</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 6.自定义异常</span><br><span class="line"></span><br><span class="line">当程序中出现某些错误时,但是该错误信息并没有在Throwable子类中描述处理,这个时候可以自己设计异常类,用于描述错误信息.</span><br><span class="line"></span><br><span class="line">1.步骤:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>1.定义类:自定义异常类,<br>2.异常类类名继承Exception或者RuntimeException<br>3.编写其构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 二十四.数据结构</span><br><span class="line"></span><br><span class="line">### 1.栈</span><br><span class="line"></span><br><span class="line">​	先进后出</span><br><span class="line"></span><br><span class="line">代码示例:</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class Stack &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        stack01();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void  stack01()&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; integers = new ArrayList&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt;5; i++) &#123;</span><br><span class="line">            integers.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        while (integers.size()&gt;0)&#123;</span><br><span class="line">            Integer remove = integers.remove(integers.size() - 1);</span><br><span class="line">            System.out.print(remove+&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">            System.out.println(integers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2.队列"></a>2.队列</h3><p>​	先进先出</p>
<p>代码示例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        queue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">queue</span><span class="params">()</span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (list.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">remove</span> <span class="operator">=</span> list.remove(<span class="number">0</span>);</span><br><span class="line">            System.out.print(remove+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-单链表"><a href="#3-单链表" class="headerlink" title="3.单链表"></a>3.单链表</h3><p>​	<img src="C:\Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230417193112848.png" alt="image-20230417193112848"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleLinkedList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;4&quot;</span>,<span class="literal">null</span>);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;3&quot;</span>,node4);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;2&quot;</span>,node3);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(<span class="string">&quot;1&quot;</span>,node2);</span><br><span class="line"></span><br><span class="line">        System.out.print(node1.getData()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        System.out.print(node1.next().getData()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        System.out.print(node1.next().next().getData()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">        System.out.print(node1.next().next().next().getData()+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Object data, Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Node next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">next</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="二十五-线程"><a href="#二十五-线程" class="headerlink" title="二十五.线程"></a>二十五.线程</h1><h3 id="1-作用-4"><a href="#1-作用-4" class="headerlink" title="1.作用:"></a>1.作用:</h3><p>​	使代码可以同时执行多个事物</p>
<h3 id="2-名词"><a href="#2-名词" class="headerlink" title="2.名词"></a>2.名词</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">进程:一个正在执行的程序</span><br><span class="line">进程是程序的一次执行过程,或是正在运行的一个程序.是动态过程:有他自身的产生,存在,消亡</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程: 一个执行路径</span><br><span class="line">线程是由进程创建的,是进程的一个实体,一个进程可以有多个线程</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单线程:同一时刻,只允许执行一个线程</span><br><span class="line">多线程:同一时刻,可以执行多个线程</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主线程:一个线程创建时自带的一条线程,称为主线程</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">子线程:除主线程外都是子线程</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">守护线程(后台线程):</span><br><span class="line">	特点:如果一个进程的前台线程全部被销毁,此时不管是否有守护线程正在执行,此时进程都将被回收</span><br><span class="line">前台线程:</span><br><span class="line">	特点:如果一个进程中有前台线程存活,此时系统将不会回收进程</span><br></pre></td></tr></table></figure>

<h3 id="3-组成"><a href="#3-组成" class="headerlink" title="3.组成:"></a>3.组成:</h3><h3 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程抢夺CPU执行权后可执行的时间</span><br></pre></td></tr></table></figure>

<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个线程一个栈内存,多个线程共享一个堆内存</span><br></pre></td></tr></table></figure>

<h3 id="4-线程的创建"><a href="#4-线程的创建" class="headerlink" title="4.线程的创建"></a>4.线程的创建</h3><h3 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一:</span><br><span class="line">	创建Thread的子类对象</span><br><span class="line">	步骤:</span><br><span class="line">		1.创建一个类</span><br><span class="line">		2.使其继承Thread</span><br><span class="line">		3.重写run方法</span><br><span class="line">	注意:当前线程启动后,将执行如方法中的代码</span><br><span class="line">    	4.创建该类对象</span><br><span class="line">    优点:可以创建无数个该类对象</span><br><span class="line">    </span><br><span class="line">  方式二:</span><br><span class="line">  	使用匿名内部类的形式创建Thread的子类对象</span><br><span class="line">  		步骤:</span><br><span class="line">  			Thread 对象名 = new Thread()&#123;</span><br><span class="line">  				重写run方法</span><br><span class="line">  			&#125;</span><br><span class="line">  		优点:便于书写</span><br><span class="line">        缺点:只能创建一个该线程对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式一:普通方式创建Runnable的子类对象</span><br><span class="line">	步骤:</span><br><span class="line">		1.创建一个类</span><br><span class="line">		2.使其实现Runnable接口</span><br><span class="line">		3.重写run方法</span><br><span class="line">		4.创建该类对象</span><br><span class="line">		5.在创建线程对象时传入该类对象(线程任务对象)</span><br><span class="line"></span><br><span class="line">方式二:</span><br><span class="line">	使用匿名内部类创建Runnable的子类对象</span><br><span class="line">		步骤:</span><br><span class="line">		1.Runnable 对象名 = new Runnable()&#123;</span><br><span class="line">			重写run方法</span><br><span class="line">		&#125;;</span><br><span class="line">		2.创建线程对象时传入该类对象(线程任务对象)</span><br></pre></td></tr></table></figure>

<h3 id="5-线程使用"><a href="#5-线程使用" class="headerlink" title="5.线程使用"></a>5.线程使用</h3><h5 id="5-线程的启动"><a href="#5-线程的启动" class="headerlink" title="5.线程的启动"></a>5.线程的启动</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程对象.start();</span><br><span class="line">注意:</span><br><span class="line">	1.当线程启动后会开启新的执行路径,执行run方法中的代码</span><br><span class="line">	2.如果直接使用线程对象调用run方法,不会开启新的执行路径</span><br></pre></td></tr></table></figure>

<h5 id="6-线程的销毁"><a href="#6-线程的销毁" class="headerlink" title="6.线程的销毁"></a>6.线程的销毁</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程已经启动,无法控制,需要等待执行完run方法中的代码</span><br></pre></td></tr></table></figure>

<h5 id="7-获取当前线程对象"><a href="#7-获取当前线程对象" class="headerlink" title="7.获取当前线程对象"></a>7.获取当前线程对象</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread.currentThread();</span><br></pre></td></tr></table></figure>

<h5 id="8-线程名城"><a href="#8-线程名城" class="headerlink" title="8.线程名城"></a>8.线程名城</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取线程名称:</span><br><span class="line">	线程对象.getName();</span><br><span class="line">修改线程名称</span><br><span class="line">	线程对象.setName(name);</span><br><span class="line">注意:在启动前修改	</span><br></pre></td></tr></table></figure>

<h5 id="9-线程优先级"><a href="#9-线程优先级" class="headerlink" title="9.线程优先级"></a>9.线程优先级</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:提高线程抢夺到CPU执行权的概率</span><br><span class="line"></span><br><span class="line">语法:</span><br><span class="line">	线程对象.setPriority(int);</span><br><span class="line">注意:</span><br><span class="line">	1.取值范围1-10;</span><br><span class="line">	2.必须在线程启动前</span><br></pre></td></tr></table></figure>

<h5 id="10-线程休眠"><a href="#10-线程休眠" class="headerlink" title="10.线程休眠"></a>10.线程休眠</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:让线程暂时停止运行</span><br><span class="line">方法:</span><br><span class="line">	static void sleep(休眠时间);</span><br><span class="line">注意:</span><br><span class="line">	1.单位毫秒</span><br><span class="line">	2.使用类调用,使当前线程休眠</span><br><span class="line">	3.线程休眠期间不会抢夺CPU执行权</span><br></pre></td></tr></table></figure>

<h5 id="11-线程礼让"><a href="#11-线程礼让" class="headerlink" title="11.线程礼让"></a>11.线程礼让</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:将获取道德cpu执行权让出,重新参与抢夺</span><br><span class="line">方法:</span><br><span class="line">	static native void yield();</span><br></pre></td></tr></table></figure>

<h5 id="12-线程合并"><a href="#12-线程合并" class="headerlink" title="12.线程合并"></a>12.线程合并</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:合并线程</span><br><span class="line">方法:</span><br><span class="line">	public final void join();</span><br></pre></td></tr></table></figure>

<h5 id="13-守护线程"><a href="#13-守护线程" class="headerlink" title="13.守护线程"></a>13.守护线程</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">有名:后台线程</span><br><span class="line">特点:当一个进程中有前台线程存活,此时该进程就不会被系统回收</span><br><span class="line">如果一个进程中只剩余后台线程,此时不管后台线程中的代码是否运行完毕,系统都将回收该进程</span><br><span class="line">方法:</span><br><span class="line">	public final void setDaemon(boolean on);</span><br><span class="line">	true:表示守护线程,默认为false,表示前台线程</span><br><span class="line">	注意:</span><br><span class="line">		1.创建线程对象与主线程默认为前台线程</span><br><span class="line">		2.必须在线程启动前</span><br></pre></td></tr></table></figure>

<h3 id="6-线程的生命周期"><a href="#6-线程的生命周期" class="headerlink" title="6.线程的生命周期"></a>6.线程的生命周期</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程可以处于以下状态之一</span><br><span class="line"></span><br><span class="line">1. NEW: 尚未启动的线程处于此状态</span><br><span class="line">2. RUNNABLE:在java虚拟机中执行的线程处于此状态；内部会分为ready和running两部分，执行哪一个由调度器决定</span><br><span class="line">3. BLOCKED: 被阻塞等待监视器锁定的线程处于此状态</span><br><span class="line">4. WAITING ：正在等待另一个线程执行特定动作的线程处于此状态</span><br><span class="line">5. TIMED_WAITING :正在等待另一个线程执行动作达到指定等待时间的线程处于此状态（超时等待）</span><br><span class="line">6. TERMINATED:一退出的线程出于此状态</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230418171549456.png" alt="image-20230418171549456"></p>
<h3 id="7-Thread和Runnable的区别"><a href="#7-Thread和Runnable的区别" class="headerlink" title="7.Thread和Runnable的区别"></a>7.Thread和Runnable的区别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 从java设计来看，通过继承Thread或者实现Runnable接口来创建线程本质上没有区别，从jdk帮助文档我们可以见到Tread类本身就实现了Runnable接口</span><br><span class="line">2. 实现Runnable接口方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制</span><br></pre></td></tr></table></figure>

<h3 id="8-线程安全问题"><a href="#8-线程安全问题" class="headerlink" title="8.线程安全问题"></a>8.线程安全问题</h3><h5 id="原因"><a href="#原因" class="headerlink" title="原因:"></a>原因:</h5><p>多个线程操作同一数据,会导致线程安全问题</p>
<h5 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h5><p>保证同时只能有一个线程操作该数据</p>
<h5 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方案一:同步代码块</span><br><span class="line">	语法:</span><br><span class="line">		synchronized(锁对象)&#123;</span><br><span class="line">			要同步的代码</span><br><span class="line">		&#125;</span><br><span class="line">	注意:</span><br><span class="line">	1.所有对象都可以作为锁对象</span><br><span class="line">    2.多个线程的锁对象要是同一个对象</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方案二:同步方法</span><br><span class="line">	语法:</span><br><span class="line">		访问权限修饰符 synchronized 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">		&#125;</span><br><span class="line">	注意:</span><br><span class="line">    	1.同步方法法人锁对象是this</span><br><span class="line">    	2.多个线程的锁对象要是同一个对象</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方案三:同步静态方法</span><br><span class="line">	语法:</span><br><span class="line">		访问权限修饰符 synchronized static 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	注意:</span><br><span class="line">    	1.同步静态方法的锁对象是该类的对象</span><br><span class="line">    		类对象:当JVM加载类时.会产生一个对象,该对象就是该类的类对象,一个类只有一个类对象</span><br><span class="line">    	2.多个线程的锁对象要是同一个对象	</span><br></pre></td></tr></table></figure>

<h3 id="9-死锁"><a href="#9-死锁" class="headerlink" title="9.死锁"></a>9.死锁</h3><h5 id="原因-1"><a href="#原因-1" class="headerlink" title="原因:"></a>原因:</h5><p>多个线程互相持有对方所需的锁资源</p>
<h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">线程<span class="number">1</span>:</span><br><span class="line">	xxx</span><br><span class="line">	<span class="title function_">synchronized</span> <span class="params">(A)</span>&#123;</span><br><span class="line">		xxx</span><br><span class="line">		<span class="title function_">synchronized</span> <span class="params">(B)</span>&#123;</span><br><span class="line">			xxx</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">线程<span class="number">2</span>:</span><br><span class="line">	xxx</span><br><span class="line">	<span class="title function_">synchronized</span> <span class="params">(B)</span>&#123;</span><br><span class="line">		xxx</span><br><span class="line">		<span class="title function_">synchronized</span> <span class="params">(A)</span>&#123;</span><br><span class="line">			xxx</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>避免思路</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">不要在同步中使用</span><br></pre></td></tr></table></figure>

<h3 id="10-线程间通讯"><a href="#10-线程间通讯" class="headerlink" title="10.线程间通讯"></a>10.线程间通讯</h3><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.线程间通讯的方法是由Object提供的</span><br><span class="line">2.只能在同步中使用</span><br><span class="line">3.只能使用所在的同步的锁对象调用</span><br></pre></td></tr></table></figure>

<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">唤醒线程</span><br><span class="line">	notify():随机唤醒一个</span><br><span class="line">	notifyAll():唤醒所有</span><br><span class="line">	注意:只能唤醒以同一个对象调用wait方法的线程</span><br><span class="line"></span><br><span class="line">线程休眠:</span><br><span class="line">	wait() 无限休眠</span><br><span class="line">	wait(int ms) 有限期休眠(休眠ms毫秒)</span><br><span class="line">	wait(int ms,int ns)有限期休眠</span><br><span class="line">	注意:</span><br><span class="line">		ms为毫秒,ns为纳秒	</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="11-wait和sleep的区别"><a href="#11-wait和sleep的区别" class="headerlink" title="11.wait和sleep的区别"></a>11.wait和sleep的区别</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.wait在休眠期会释放所持有的锁资源,sleep不会</span><br><span class="line">2.wait必须在同步使用,sleep没有限制</span><br><span class="line">3.wait必须使用所在的同步锁对象调用,sleep使用Thread类或者Thread类的对象调用</span><br><span class="line">4.wait由Object提供,sleep由Thread类提供</span><br></pre></td></tr></table></figure>

<h3 id="13-线程池"><a href="#13-线程池" class="headerlink" title="13.线程池"></a>13.线程池</h3><h5 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h5><p>​	优化线程</p>
<h5 id="原因-2"><a href="#原因-2" class="headerlink" title="原因:"></a>原因:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个线程大约占1MB的运行内存</span><br><span class="line">大量创建线程时可能会导致内存溢出</span><br><span class="line">大量的创建线程也导致需要对象线程频繁的创建与回收</span><br></pre></td></tr></table></figure>

<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.使用空闲的线程执行新的任务(线程复用)</span><br><span class="line">2.使用一个容器来管理线程的创建,回收,复用等</span><br><span class="line">注意:java中提出线程池来完成以上操作</span><br></pre></td></tr></table></figure>

<h5 id="线程池的体系结构"><a href="#线程池的体系结构" class="headerlink" title="线程池的体系结构"></a>线程池的体系结构</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Executor(接口)</span><br><span class="line">	提供的方法:</span><br><span class="line">		void execute(Runnable command);</span><br><span class="line">		作用:执行线程任务,子接口提供了submit优于该方法</span><br><span class="line">	子类或子接口</span><br><span class="line">    	ExecutorService(接口)</span><br><span class="line">    		提供的方法:</span><br><span class="line">    			void shutdown();</span><br><span class="line">    			作用:关闭线程池</span><br><span class="line">    			boolean isShutdown();</span><br><span class="line">    			作用:判断线程池是否关闭</span><br><span class="line">    			Future&lt;T&gt; submit(线程任务)</span><br><span class="line">    			作用:提交线程任务</span><br><span class="line">    		子类或子接口:</span><br><span class="line">            	ScheduledExecutorService(接口)</span><br><span class="line">            	ThreadPoolExecutor(类)</span><br><span class="line">            		构造函数:</span><br><span class="line">            			public ThreadPoolExecutor(int corePoolSize,</span><br><span class="line">            						int maxmumPoolSize,</span><br><span class="line">            						long keepAliveTime,</span><br><span class="line">            						TimeUnit unit,</span><br><span class="line">            						BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="line">            						ThreadFactory threadFactory,</span><br><span class="line">            						RejectedExecutionHandler handler)</span><br><span class="line">            						</span><br><span class="line">            		corePoolSize:h核心线程数,线程池中最少有几个线程</span><br><span class="line">                    maximumPoolSize:最大线程数,线程中最多可以容纳的线程数</span><br><span class="line">                    keepAliveTime:销毁时间,当线程执行完任务后,多久销毁</span><br><span class="line">                    until:时间单位</span><br><span class="line">                    workQueue:存储执行的线程任务的集合(队列形式)</span><br><span class="line">                    threadFactory:创建线程</span><br><span class="line">                    handler:优化线程,使其线程复用的算法</span><br></pre></td></tr></table></figure>

<h5 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:创建线程池</span><br><span class="line">原因:应为ThreadPoolExecutor过于麻烦,所以JDK提供该类帮助我们创建线程池提供的方法</span><br><span class="line"></span><br><span class="line">	1.固定线程池</span><br><span class="line">	特点:线程池中的线程数量恒定,当线程任务小于线程数量时,随机在线程池中挑选线程执行任务,当线程任务大于线程数量,会先执行前面的任务,后等前面任务执行完毕后,使用执行完毕的线程,执行剩余任务.</span><br><span class="line">    static ExecutorService newFixedThreadPool(int nThreads)</span><br><span class="line">    	nThreads:线程池中线程的数量</span><br><span class="line">    	</span><br><span class="line">    2.可变线程池</span><br><span class="line">    特点:线程池中的线程数量可变</span><br><span class="line">    static ExecutorService newCachedThreadPool()</span><br><span class="line">    </span><br><span class="line">    3.单例线程池</span><br><span class="line">    特点:一个线程池只有一个线程</span><br><span class="line">    static ExecutorService newSingleThreadExecutor()</span><br><span class="line">    </span><br><span class="line">    4.抢占线程池</span><br><span class="line">    static ExecutorService newWorkStealingPool()</span><br><span class="line">    </span><br><span class="line">    5.调度线程池</span><br><span class="line">    特点:该线程池执行任务可以延迟,也可以延迟重复执行</span><br><span class="line">    static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</span><br><span class="line">    corePoolSize:线程池中线程的数量</span><br><span class="line">    </span><br><span class="line">    6.单例调度线程池</span><br><span class="line">    特点:调度线程池中只有一个线程</span><br><span class="line">    static ScheduledExecutorService newSingleThreadScheduledExecutor();</span><br></pre></td></tr></table></figure>

<h5 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">步骤:</span><br><span class="line">1.创建线程池</span><br><span class="line">2.提交任务</span><br><span class="line">3.关闭线程池</span><br></pre></td></tr></table></figure>

<h5 id="调度线程池-ScheduledExecutorService"><a href="#调度线程池-ScheduledExecutorService" class="headerlink" title="调度线程池:ScheduledExecutorService"></a>调度线程池:ScheduledExecutorService</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提供的方法:</span><br><span class="line">	public ScheduledFuture&lt;?&gt; schedule(线程任务,long delay,TimeUnit unit)</span><br><span class="line">	作用:延迟执行   </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command</span><br><span class="line">											long initialDelay</span><br><span class="line">											long period</span><br><span class="line">											TimeUnit unit);</span><br><span class="line">	作用:延迟重复执行</span><br><span class="line">    1参,执行的任务</span><br><span class="line">    2参,延迟时间</span><br><span class="line">    3参,间隔时间 = 本次任务开始时间 - 上次任务开始时间</span><br><span class="line">    注意:如果上次任务执行时间&gt;间隔时间,那么当上次任务执行完毕后,本次任务直接开始</span><br><span class="line">   4参,时间单位</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ScheduledFuture&lt;?&gt; scheduleWithFixedDaley(Runnable command,</span><br><span class="line">											long initialDelay</span><br><span class="line">											long delay</span><br><span class="line">											TimeUnit unit);</span><br><span class="line">	作用:延迟重复执行</span><br><span class="line">    1参,执行任务</span><br><span class="line">    2参,延迟时间</span><br><span class="line">    3参,间隔时间= 本次任务开始时间-上次任务结束时间</span><br><span class="line">    4时间单位</span><br></pre></td></tr></table></figure>

<h3 id="14-Callable"><a href="#14-Callable" class="headerlink" title="14.Callable"></a>14.Callable</h3><p>作用:有返回值的线程任务对象</p>
<p>注意:无法在创建Thread对象时传入,必须配合线程池使用</p>
<h3 id="15-Lock"><a href="#15-Lock" class="headerlink" title="15.Lock"></a>15.Lock</h3><p>作用:简化同步</p>
<h5 id="同步"><a href="#同步" class="headerlink" title="同步:"></a>同步:</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">同步代码块</span><br><span class="line">	synchronize(锁对象)&#123;</span><br><span class="line">		//关锁</span><br><span class="line">		代码</span><br><span class="line">		//开锁</span><br><span class="line">	&#125;</span><br><span class="line">同步方法</span><br><span class="line">	访问权限修饰符 synchronize 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">		//关锁</span><br><span class="line">		方法</span><br><span class="line">		//开锁</span><br><span class="line">	&#125;</span><br><span class="line">同步静态方法</span><br><span class="line">	访问权限修饰符 synchronize static 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">		//关锁</span><br><span class="line">		方法</span><br><span class="line">		//开锁</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h5 id="lock体系"><a href="#lock体系" class="headerlink" title="lock体系"></a>lock体系</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Lock</span><br><span class="line">	提供的方法:</span><br><span class="line">		void lock():关锁</span><br><span class="line">		void unLock():开锁</span><br><span class="line">		</span><br><span class="line">	Condition newCondition():获取锁对象</span><br><span class="line">			void await():无限期休眠</span><br><span class="line">			void signal():随机唤醒一个</span><br><span class="line">			void signalAll():唤醒所有</span><br><span class="line">	子类:</span><br><span class="line">		ReentrantLock</span><br><span class="line">		</span><br><span class="line">ReadWriteLock</span><br><span class="line">	提供的方法:</span><br><span class="line">		Lock readLock():获取读锁</span><br><span class="line">		Lock writeLock():获取写锁</span><br><span class="line">		注意:</span><br><span class="line">			读-写	互斥</span><br><span class="line">			读-读 不互斥</span><br><span class="line">			写-写	互斥</span><br><span class="line">	子类</span><br><span class="line">		ReentrantReadWriteLock</span><br></pre></td></tr></table></figure>



<h1 id="二十六-x2F-设计模式"><a href="#二十六-x2F-设计模式" class="headerlink" title="二十六&#x2F;设计模式"></a>二十六&#x2F;设计模式</h1><p>作用:解决特定问题的思路</p>
<h3 id="1-生成者与消费者"><a href="#1-生成者与消费者" class="headerlink" title="1.生成者与消费者"></a>1.生成者与消费者</h3><p>1.生产者消费者模式解决进销存业务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">生产</span><br><span class="line">	无限生产</span><br><span class="line">销售</span><br><span class="line">	无限销售</span><br><span class="line">工厂</span><br><span class="line">	生产的方法</span><br><span class="line">	出货的方法</span><br><span class="line">库存数量</span><br><span class="line">商品数量上限:100</span><br><span class="line">商品数量下限:0</span><br></pre></td></tr></table></figure>

<h3 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2.单例模式"></a>2.单例模式</h3><p>解决的问题</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个类只能有一个对象</span><br></pre></td></tr></table></figure>

<p>分类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">懒汉式</span><br><span class="line">	步骤:</span><br><span class="line">		1,私有化构造函数</span><br><span class="line">		2,提供一个公共的属性,记录该类的唯一对象</span><br><span class="line">		3,提供一个公共的静态方法返回该类创建好的对象</span><br><span class="line">	优点:</span><br><span class="line">		节省内存</span><br><span class="line">	缺点:</span><br><span class="line">		有线程安全问题</span><br><span class="line">饿汉式</span><br><span class="line">	步骤:</span><br><span class="line">		1,私有化构造函数</span><br><span class="line">		2,提供一个公共的属性,记录该类的唯一对象,并创建该对象</span><br><span class="line">		3,提供一个公共的静态方法返回该类创建好的对象</span><br><span class="line">	优点:</span><br><span class="line">		不存在线程安全问题</span><br><span class="line">	缺点:</span><br><span class="line">		浪费内存</span><br><span class="line">		</span><br><span class="line">线程安全的懒汉式</span><br><span class="line">	代码:</span><br><span class="line">		public class C &#123;</span><br><span class="line">       private static C c;</span><br><span class="line">       private C()&#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       public synchronized C getInstance()&#123;</span><br><span class="line">           if (c == null)&#123;</span><br><span class="line">               c = new C();</span><br><span class="line">           &#125;</span><br><span class="line">           return c;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">优点:</span><br><span class="line">	线程安全</span><br><span class="line">缺点:</span><br><span class="line">	效率慢</span><br><span class="line">	</span><br><span class="line">内部类饿汉式</span><br><span class="line">	代码:</span><br><span class="line">   public class D &#123;</span><br><span class="line">       private D()&#123;</span><br><span class="line">       &#125;</span><br><span class="line">       public static D getInstance()&#123;</span><br><span class="line">           return InClass.getD();</span><br><span class="line">       &#125;</span><br><span class="line">       static class InClass&#123;</span><br><span class="line">           private static D d = new D();</span><br><span class="line">           public static D getD()&#123;</span><br><span class="line">               return d;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-工程模式"><a href="#3-工程模式" class="headerlink" title="3.工程模式"></a>3.工程模式</h3><p><strong>解决问题</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">特定编号生产特定商品</span><br></pre></td></tr></table></figure>

<pre><code>家具厂
    沙发
    椅子
    床
    衣柜
    茶几
    ...

分析:
    类
        家具厂类
            家具接口对象 生产的方法(编号)&#123;
                switch(编号)&#123;
                    case 1:
            &#125;
        &#125;
    家具接口
    沙发类 实现 家具接口
    椅子类 实现 家具接口
    床类 实现 家具接口
    衣柜类 实现 家具接口
    茶几类 实现 家具接口
</code></pre>
<h1 id="二十七-IO流"><a href="#二十七-IO流" class="headerlink" title="二十七.IO流"></a>二十七.IO流</h1><h3 id="1-作用-5"><a href="#1-作用-5" class="headerlink" title="1.作用"></a>1.作用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传输数据</span><br></pre></td></tr></table></figure>

<h3 id="2-分类-1"><a href="#2-分类-1" class="headerlink" title="2.分类"></a>2.分类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">按照流向分类</span><br><span class="line">	输入流</span><br><span class="line">	输出流</span><br><span class="line"></span><br><span class="line">按照传输的最小数据单位分类</span><br><span class="line">	字节流</span><br><span class="line">		最小单位:byte</span><br><span class="line">	字符流</span><br><span class="line">    	最小单位char</span><br><span class="line">    	</span><br><span class="line">    	</span><br><span class="line">   按照功能分类</span><br><span class="line">   		节点流:</span><br><span class="line">   			从数据源到程序,或从程序直接到数据源</span><br><span class="line">   		包装流(过滤流)</span><br><span class="line">        	在节点流的基础上增强功能</span><br><span class="line">        	注意:所有的包装流都使用了装饰者模式</span><br></pre></td></tr></table></figure>

<h3 id="3-字节流"><a href="#3-字节流" class="headerlink" title="3.字节流"></a>3.字节流</h3><p>体系结构:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InputStream(字节输入流顶级接口)</span><br><span class="line">	方法:</span><br><span class="line">		int read();一次读取一个字节,返回值为读取到的字节</span><br><span class="line">		int read(byte b[]):一次读取一组字节数据到数组B中,返回值为读取到的字节长度,当返回值为-1时表示读取结束</span><br><span class="line">		int read(byte[],int off,int len);一次读取一组字节数据到数组b中,从off位置开始存储,存储len个字节</span><br><span class="line">		返回值为读取到的字节长度,当返回值为-1时表示读取结束</span><br><span class="line">		</span><br><span class="line">		void close(); 关闭流对象</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<h4 id="3-1-OutputStream-字节输出流顶级接口"><a href="#3-1-OutputStream-字节输出流顶级接口" class="headerlink" title="3.1.OutputStream(字节输出流顶级接口)"></a>3.1.OutputStream(字节输出流顶级接口)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法:</span><br><span class="line">	void write(int b);一次写入一个字节</span><br><span class="line">	void write(byte b[]);一次写入一组字节</span><br><span class="line">	void write(byte b[],int off,int len);一次写入一组字节,从off位置开始,写入len</span><br><span class="line">	void flush():冲刷</span><br><span class="line">	void close();关流</span><br></pre></td></tr></table></figure>

<h4 id="3-2文件字节流"><a href="#3-2文件字节流" class="headerlink" title="3.2文件字节流"></a>3.2文件字节流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FileInputStream</span><br><span class="line">	分类:</span><br><span class="line">		输入流:文件到程序</span><br><span class="line">		节点流</span><br><span class="line">FileOutputStream</span><br><span class="line">	分类:</span><br><span class="line">		输出流:程序到文件</span><br><span class="line">		节点流</span><br></pre></td></tr></table></figure>

<h4 id="3-3内存流"><a href="#3-3内存流" class="headerlink" title="3.3内存流"></a>3.3内存流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:在读取数据过程中,因数据不全导致的乱码问题</span><br><span class="line">ByteArrayInputStream</span><br><span class="line">ByteArrayOutputStream</span><br><span class="line">	特有方法:</span><br><span class="line">		byte toByteArray();将内存流中的数据获取出来</span><br></pre></td></tr></table></figure>

<h4 id="3-4缓冲流"><a href="#3-4缓冲流" class="headerlink" title="3.4缓冲流"></a>3.4缓冲流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:提高读写效率</span><br><span class="line">注意:</span><br><span class="line">	包装流</span><br><span class="line">	BufferedInputStream</span><br><span class="line">	BufferedOutputStream</span><br><span class="line">	</span><br><span class="line">注意:默认缓冲区大小为8kb	</span><br></pre></td></tr></table></figure>

<h4 id="3-5对象流"><a href="#3-5对象流" class="headerlink" title="3.5对象流"></a>3.5对象流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用:将对象写入到文件中,或从文件中读取对象</span><br><span class="line">注意:</span><br><span class="line">	1.读写的对象所属的类要实现序列化接口</span><br><span class="line">	2.一个对象流只能读写一个对象</span><br><span class="line">	3.存储的所有数据都必须进行序列化</span><br><span class="line">	4.static修饰的属性,transient修饰的属性不参与序列化</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">ObjectInputStream</span><br><span class="line">	readObject():读取对象,只读第一个</span><br><span class="line">ObjectOutputStream</span><br><span class="line">	wirteObject();写入对象</span><br></pre></td></tr></table></figure>

<h3 id="4-字符流"><a href="#4-字符流" class="headerlink" title="4.字符流"></a>4.字符流</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念:"></a>概念:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">传输的数据单位最小为字符(char)</span><br></pre></td></tr></table></figure>

<h4 id="字符流体系"><a href="#字符流体系" class="headerlink" title="字符流体系"></a>字符流体系</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reader</span><br><span class="line">	概念:所有字符输入流的父类</span><br><span class="line">	提供方法:</span><br><span class="line">		int read(),一次获取一个字符,返回值为读取到的字符.</span><br><span class="line">		int read(char c[]):一次去取一组字符到数组c中,返回值为读取到的字符长度,当为-1时表示读取结束</span><br><span class="line">		int read(char c[],int off,int len)</span><br><span class="line">			一次去取一组字符到数组c中,从off位置开始存储,存储len个,返回值为读取到的字符长度,当为-1时别是读取结束</span><br><span class="line">		void close() 关闭	</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Wirter</span><br><span class="line">	概念:所有字符输出流的父类</span><br><span class="line">	提供的方法:</span><br><span class="line">		void write(int c)</span><br><span class="line">		void write(char cbuf[])</span><br><span class="line">		void write(char cbuf[],int off,int len)</span><br><span class="line">		void write(String str)</span><br><span class="line">		void flush()</span><br><span class="line">		void close()</span><br></pre></td></tr></table></figure>

<h4 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FileReader</span><br><span class="line">FileWriter</span><br></pre></td></tr></table></figure>

<h4 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BufferedReader</span><br><span class="line">	readLine();读取一行</span><br><span class="line">BufferedWriter</span><br><span class="line">	nextLine():写入下一行</span><br></pre></td></tr></table></figure>

<h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InputStreamReader</span><br><span class="line">OutputStreamWriter</span><br></pre></td></tr></table></figure>

<h4 id="标准输出流"><a href="#标准输出流" class="headerlink" title="标准输出流"></a>标准输出流</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PrintStream</span><br><span class="line">	注意:字节流</span><br></pre></td></tr></table></figure>

<h3 id="5-File"><a href="#5-File" class="headerlink" title="5.File"></a>5.File</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">概念:文件或文件夹对应的类</span><br></pre></td></tr></table></figure>

<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建File类的对象</span><br><span class="line">2.调用属性或方法</span><br></pre></td></tr></table></figure>

<h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">公共构造函数</span><br><span class="line">	File(String pathname)</span><br><span class="line">		pathname:文件或文件夹的路径</span><br><span class="line">	File(String parent,String child)</span><br><span class="line">    	parent:上级文件夹的路径</span><br><span class="line">    	child:当前文件的名称.后缀名</span><br><span class="line">    File(File parent,String child)</span><br><span class="line">    	parent:上级文件夹的file对象</span><br><span class="line">    	child:当前文件的名称.后缀名</span><br><span class="line">    	</span><br><span class="line">    File(URI uri)</span><br><span class="line">    	uri:资源所在位置</span><br><span class="line">    	如:</span><br><span class="line">    		URI uri = URI.create(&quot;D:\\a.txt&quot;);</span><br><span class="line">    		File file = new File(uri);</span><br><span class="line">  </span><br><span class="line">  注意:</span><br><span class="line">  	路径分为绝对路径和相对路径</span><br><span class="line">  		绝对路径:从盘符开始</span><br><span class="line">  		相对路径:相对于项目路径下</span><br><span class="line">  			注意:</span><br><span class="line">  				. 当前路径</span><br><span class="line">  				..上级文件夹</span><br></pre></td></tr></table></figure>

<h4 id="属性"><a href="#属性" class="headerlink" title="属性:"></a>属性:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static separator:获取当前系统的路径分隔符</span><br></pre></td></tr></table></figure>

<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir():创建一级文件夹</span><br><span class="line">mkdirs():创建多级文件夹</span><br><span class="line">createNewFile():创建一级文件</span><br><span class="line"></span><br><span class="line">delete():删除一级文件或一级文件夹</span><br><span class="line"></span><br><span class="line">getParent():获取上级文件夹路径</span><br><span class="line">getParentFile():获取上级文件夹的file对象</span><br><span class="line"></span><br><span class="line">getPath():获取当前路径</span><br><span class="line">getAbsolutePath():获取当前文件的绝对路径</span><br><span class="line">getAbsoluteFile():获取绝对路径文件</span><br><span class="line">isDirectory():判断是否为文件夹</span><br><span class="line">isFile()判断是否为文件</span><br><span class="line">exists():判断文件或文件夹是否存在</span><br><span class="line">length():获取文件大小,单位字节</span><br><span class="line">renameTo():修改文件名称</span><br><span class="line"></span><br><span class="line">File[] listFiles();</span><br><span class="line">File[] listFiles(FileFilter ff);</span><br><span class="line">File[] listFiles(FilenameFilter ff);</span><br><span class="line">	获取当前文件夹下的文件或文件夹</span><br><span class="line">	注意:</span><br><span class="line">		FileFilter是文件过滤器</span><br><span class="line">		重写的是boolean accept(File pathname)</span><br><span class="line">		当返回值为true表示可以通过,反之false不通过</span><br><span class="line">		</span><br><span class="line">		FilenameFilter文件名称过滤器</span><br><span class="line">			重写的是boolean accept(File f , String name)</span><br><span class="line">			当返回值为true表示可以通过,反之false不通过</span><br><span class="line">			f:父级文件对象</span><br><span class="line">			name:当前文件名称</span><br></pre></td></tr></table></figure>

<h1 id="二十八-网络编程"><a href="#二十八-网络编程" class="headerlink" title="二十八.网络编程"></a>二十八.网络编程</h1><h3 id="1-网络相关概念"><a href="#1-网络相关概念" class="headerlink" title="1.网络相关概念"></a>1.网络相关概念</h3><p><strong>概念</strong>:两台设备之间通过网络实现数据通信</p>
<p><strong>网络通信</strong>:将数据通过网络从一台设备传输到另一台设备</p>
<p>java.net包提供了一系列的类或接口,供程序员使用,完成网络通信</p>
<h4 id="常用名词"><a href="#常用名词" class="headerlink" title="常用名词"></a>常用名词</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">互联网(Internet):点与点相连</span><br><span class="line">万维网(www):端与端相连</span><br><span class="line">物联网:物物互联</span><br><span class="line">网络编程:让计算机与计算机之间建立连接.</span><br></pre></td></tr></table></figure>

<h3 id="2-OSI网络架构"><a href="#2-OSI网络架构" class="headerlink" title="2.OSI网络架构"></a>2.OSI网络架构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简介</span><br><span class="line">	open System Interconnect开放式系统互联</span><br><span class="line">	存在于概念和理论上的一种模型,他的缺点是分层太多,增加了网络工作的复杂性,所以没有大规模应用</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230424171347594.png" alt="image-20230424171347594"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一层:物理层为设备之间的数据通信提供传输信号和物理介质(双绞线,光导纤维)</span><br><span class="line">作用:建立/维护/断开物理连接.</span><br><span class="line"></span><br><span class="line">第二层:链路层在物理层上,通过规程或协议(差错控制)来控制传输数据的正确性(MAC)</span><br><span class="line">	作用:接受来自物理层的位流形式的数据,并封装成帧,传送到上一层,同样,也将来自上层的数据帧,拆装为位流形式的数据转发到物理层,并且还负责处理接收端发回的确认帧的信息,以便提供可靠的数据传输</span><br><span class="line">	</span><br><span class="line">第三层:网络层负责定义了能够标识所有网络节点的逻辑地址(IP地址)</span><br><span class="line">	作用:逻辑寻址,Ip地址,在下两层的基础上向资源子网提供服务</span><br><span class="line">	</span><br><span class="line">第四层:传输层负责是否选择差错回复协议,数据流重用,错误顺序排序(tcp,udp)</span><br><span class="line">	作用:提供可靠的和不可靠的传输机制TCP/UDP</span><br><span class="line">	</span><br><span class="line">第五层:会话层负责使应用建立和维持会话,使通信在失败时继续恢复通信(断电续传)</span><br><span class="line">	作用:建立/终止/管理实体间会话连接</span><br><span class="line">	</span><br><span class="line">第六层:表示层负责定义转换数据格式及加密,允许选择以二进制或ASCII格式传输</span><br><span class="line">	作用:分装数据格式(加密解密,压缩解压缩)</span><br><span class="line">	</span><br><span class="line">第七层:应用层负责文件访问和管理/可靠运输服务,远程操作服务(HTTP/FTP/SMTP)</span><br><span class="line">	作用:人与机器电脑交互的窗口</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="3-IP地址"><a href="#3-IP地址" class="headerlink" title="3.IP地址"></a>3.IP地址</h3><h4 id="ip地址"><a href="#ip地址" class="headerlink" title="ip地址:"></a>ip地址:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.概念:用于标识网络中的每台计算机/主机</span><br><span class="line">2.查看ip地址:ipconfig</span><br><span class="line">3.ip地址的表现形式:点分十进制  xx.xx.xx.xx</span><br><span class="line">4.每一个十进制的范围是0-255</span><br><span class="line">5.IP地址的组成= 网络地址+主机地址</span><br><span class="line">6.ipv6是互联网工程任务组设计的用于代替ipv4的下一代ip协议，其地址数量号称可以为全世界每一粒沙子编上一个地址</span><br><span class="line">7.由于ipv4最大的问题在于网络地址资源有限，严重制约了互联网的应用和发展。ipv6的使用，不仅解决了网络地址资源数量的问题，而且也解决了多种接入设备连入互联网的障碍</span><br></pre></td></tr></table></figure>

<h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.www.baidu.com</span><br><span class="line">2.好处:方便记忆,解决记忆ip的困难</span><br><span class="line">3.概念:将ip地址映射成域名</span><br></pre></td></tr></table></figure>

<h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.概念:用于标识计算机上某个特定的网络程序</span><br><span class="line">2.表现形式:以整数形式,范围0-65535</span><br><span class="line">3.0-1024已经被占用,比如:ssh 22, ftp 21,smtp 25,http 80</span><br><span class="line">4.常见的网络端口号</span><br><span class="line">	tomcat:8080</span><br><span class="line">	musql:3306</span><br><span class="line">	oracle:1521</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="4-通信协议"><a href="#4-通信协议" class="headerlink" title="4.通信协议"></a>4.通信协议</h3><h4 id="TCP-x2F-IP网络框架"><a href="#TCP-x2F-IP网络框架" class="headerlink" title="TCP&#x2F;IP网络框架"></a>TCP&#x2F;IP网络框架</h4><p><img src="C:\Users\fjc23\AppData\Roaming\Typora\typora-user-images\image-20230424174928746.png" alt="image-20230424174928746"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP协议:传输控制协议</span><br><span class="line">是一种面向连接的/可靠的/基于字节流的传输层通信协议.数据大小无限制.建立连接的过程需要三次握手,断开连接的过程需要四次挥手,  在连接中可进行大数据量的传输；传输完毕，需释放已建立的连接，效率低。</span><br><span class="line"></span><br><span class="line">UDP协议:用户数据报协议</span><br><span class="line">	是一种无连接的传输层协议,提供面向事物的简单不可靠信息传送服务,每个包的大小64kb,因无需连接，故是不可靠的；发送数据结束时无需释放资源（因为不是面向连接的），速度快；</span><br></pre></td></tr></table></figure>

<h3 id="5-InetAddress"><a href="#5-InetAddress" class="headerlink" title="5.InetAddress"></a>5.InetAddress</h3><p><strong>功能:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.获取本机InetAddress对象,getLocalHost</span><br><span class="line">2.根据指定主机名/域名获取IP地址对象,getByName</span><br><span class="line">3.获取InetAddress对象的主机名getHostNmae</span><br><span class="line">4.获取InetAddress对象的地址getHostAddress</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取主机名+ip地址</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">localHost</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">System.out.println(localHost);</span><br><span class="line"><span class="comment">//获取主机名</span></span><br><span class="line"><span class="type">String</span> <span class="variable">hostName</span> <span class="operator">=</span> localHost.getHostName();</span><br><span class="line">System.out.println(hostName);</span><br><span class="line"></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">byName</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;DESKTOP-HT1OC9N&quot;</span>);</span><br><span class="line">System.out.println(byName);</span><br></pre></td></tr></table></figure>

<h3 id="6-Socket编程"><a href="#6-Socket编程" class="headerlink" title="6.Socket编程"></a>6.Socket编程</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socket:套接字,网络中的一个节点</span><br><span class="line">通讯要求:地址+端口号</span><br></pre></td></tr></table></figure>

<h4 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP:面向有连接,安全可靠的,速度慢</span><br><span class="line">	特点:三次握手,四次挥手</span><br><span class="line"></span><br><span class="line">UDP:面向无连接,不安全,速度快</span><br></pre></td></tr></table></figure>

<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简介:是一种面向连接的/可靠的/基于字节流的传输层通信协议,数据大小无限制,建立连接过程需要三次握手,断开连接的过程需要四次挥手</span><br><span class="line">注意:分为客户端Socket与服务器ServerSocket</span><br></pre></td></tr></table></figure>

<h4 id="服务端开发步骤"><a href="#服务端开发步骤" class="headerlink" title="服务端开发步骤"></a>服务端开发步骤</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建ServerSocket,指定端口</span><br><span class="line">2.调用accept等待客户端接入</span><br><span class="line">3.使用输入流,接收客户端请求中的数据</span><br><span class="line">4.使用输出流,给客户端回馈数据(可选)</span><br><span class="line">5.关闭释放资源</span><br></pre></td></tr></table></figure>

<h4 id="客户端开发步骤"><a href="#客户端开发步骤" class="headerlink" title="客户端开发步骤"></a>客户端开发步骤</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建Socket对象,指定服务器IP+端口</span><br><span class="line">2.使用输出流,发起请求,给服务器发送数据</span><br><span class="line">3.使用输入流,界海服务器返回的数据(可选)</span><br><span class="line">4.关闭释放资源</span><br></pre></td></tr></table></figure>

<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">简介:UDP协议是一种不可靠的网络协议,提供面向事务的简单不可靠信息传送服务,每个包的大小64kb</span><br><span class="line">分为:接收端与发送端</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="发送端开发步骤"><a href="#发送端开发步骤" class="headerlink" title="发送端开发步骤"></a>发送端开发步骤</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建发送端的Socket对象(DatagramSocket)</span><br><span class="line">2.创建数据,并打包</span><br><span class="line">3.调用DatagramSocket对象的方法发送数据</span><br><span class="line">4.关闭发送端</span><br></pre></td></tr></table></figure>

<h4 id="接收端开发步骤"><a href="#接收端开发步骤" class="headerlink" title="接收端开发步骤"></a>接收端开发步骤</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.创建发送端Socket(DatagramSocket)</span><br><span class="line">2.创建一个数据包,用于接收数据</span><br><span class="line">3.调用DatagramSocket对象的方法接受数据</span><br><span class="line">4.解析数据包,在控制台显示</span><br><span class="line">5.关闭接收端</span><br></pre></td></tr></table></figure>

<h1 id="二十九-反射"><a href="#二十九-反射" class="headerlink" title="二十九.反射"></a>二十九.反射</h1><h3 id="1-反射机制"><a href="#1-反射机制" class="headerlink" title="1.反射机制"></a>1.反射机制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.反射机制允许程序在执行期间借助于Reflection API取得任何类的内部信息(如成员变量,成员方法,构造器)并能操作对象的属性及方法,反射在设计模式和框架底层都会用到</span><br><span class="line">2.加载完类之后,在堆中就产生了一个class对象(一个类只有一个class对象)这个对象包含了类的完整结构信息,通过这个对象得到类的结构,这个对象就像一面镜子,透过这个镜子看到类的结构,所以称为反射</span><br></pre></td></tr></table></figure>



<h3 id="2-类对象"><a href="#2-类对象" class="headerlink" title="2.类对象"></a>2.类对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">一个类被加载时会产生一个对象,该对象称为该类的类对象,该对象属于Class类的对象</span><br><span class="line"></span><br><span class="line">类对象中包含该类的所有信息,如包,实现的接口,类名,属性,方法,构造函数,注解等内容</span><br><span class="line"></span><br><span class="line">注意:一个类只有一个类对象</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="3-java反射机制可完成的任务"><a href="#3-java反射机制可完成的任务" class="headerlink" title="3.java反射机制可完成的任务:"></a>3.java反射机制可完成的任务:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.在运算时判断任意一个对象所属的类</span><br><span class="line">2.在运行时构造任意一个类的对象</span><br><span class="line">3.在运行时得到任意一个类所具有的成员变量和方法</span><br><span class="line">4.在运行时调用任意一个对象的成员变量和方法&#x27;</span><br><span class="line">5.生成动态代理</span><br></pre></td></tr></table></figure>

<h3 id="4-反射相关的主要类"><a href="#4-反射相关的主要类" class="headerlink" title="4.反射相关的主要类"></a>4.反射相关的主要类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. java.lang.Class代表一个类,Class对象表示某个类加载后在堆中的对象</span><br><span class="line">2.java.lang.reflect.Field 代表类的成员变量,Filed对象表示某个类的成员变量//getFiled不能得到私有属性</span><br><span class="line">3.java.lang.reflect.Method 代表类方法,Method对象表示某个类的方法</span><br><span class="line">4.java.lang.reflect.Constructor 代表类的构造方法Constructor对象表示构造器(),括号内可以指定参数类型,String.class</span><br></pre></td></tr></table></figure>

<h3 id="5-反射的优缺点"><a href="#5-反射的优缺点" class="headerlink" title="5.反射的优缺点"></a>5.反射的优缺点</h3><p>​	<strong>优点</strong></p>
<p>​	可以动态的创建和使用对象,使用灵活,没有反射机制,框架技术就失去了底层支撑</p>
<p>​	<strong>缺点</strong></p>
<p>​	使用反射机制基本都是解释执行,对执行速度有影响</p>
<h3 id="6-如何获取类对象"><a href="#6-如何获取类对象" class="headerlink" title="6.如何获取类对象"></a>6.如何获取类对象</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方式1:类名.class</span><br><span class="line">方式2.对象名.getClass()</span><br><span class="line">方式3:Class.forName(&quot;类的全路径&quot;)</span><br><span class="line">	类的全路径:类所属的包名+类名</span><br></pre></td></tr></table></figure>

<h3 id="7-类对象-Class类"><a href="#7-类对象-Class类" class="headerlink" title="7.类对象(Class类)"></a>7.类对象(Class类)</h3><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.Class也是类,因此也继承Object类</span><br><span class="line">2.Class类对象不是new出来的,而是系统创建的</span><br><span class="line">3.对于某个类的Class对象,在内存中只有一份,因为类只加载一次</span><br><span class="line">4.每个类的实例都会记得自己由那个Class实例所生成</span><br><span class="line">5.通过Class可以完整的得到一个类的完整结构,通过一系列API</span><br><span class="line">6.Class对象存放在堆中</span><br><span class="line">7.类的字节码二进制数据,是在方法区的,有的地方称为类的元数据(包括方法代码,变量名,方法名,访问权限)</span><br></pre></td></tr></table></figure>

<h5 id="提供的方法"><a href="#提供的方法" class="headerlink" title="提供的方法"></a>提供的方法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">类相关:</span><br><span class="line">	包</span><br><span class="line">		Pckage getPackage()</span><br><span class="line">	类名</span><br><span class="line">    	String getSimpleName()</span><br><span class="line">    类的全路径名</span><br><span class="line">    	String getName()</span><br><span class="line">    父类的类对象</span><br><span class="line">    	Class&lt;? super T&gt; getSuperclass()</span><br><span class="line">    接口的类对象</span><br><span class="line">    	Class&lt;?&gt;[] getInterface()</span><br><span class="line">    调用缺省构造函数,返回该Class对象的一个实例</span><br><span class="line">     Object newInstance()</span><br><span class="line">    	</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">属性相关</span><br><span class="line">	获取所有的公共属性,包含父类提供的公共属性</span><br><span class="line">		Field[] getFields();</span><br><span class="line">	获取所有的属性,不包含父类提供的</span><br><span class="line">    	Field[] getDeclaredField()</span><br><span class="line">    获取指定的公共属性</span><br><span class="line">    	Field getField(String name)</span><br><span class="line">    获取指定的属性</span><br><span class="line">    	Field getDeclaredField(String name)</span><br><span class="line">    Field提供的方法</span><br><span class="line">    	Object get(Object obj);</span><br><span class="line">    		作用:获取指定对象的该属性值</span><br><span class="line">    		1参:指定对象</span><br><span class="line">    	void set(Object obj,Object v)</span><br><span class="line">    		作用:修改指定对象的改属性值</span><br><span class="line">    		1参:指定的对象</span><br><span class="line">    		2参:修改后的值</span><br><span class="line">    	setAccessible(boolean flag) 是否略过访问权限修饰符</span><br><span class="line">        	默认为false,表示不略过</span><br><span class="line">        	当值为true表示略过</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">方法相关</span><br><span class="line">	获取所有的公共方法,包含父类提供的</span><br><span class="line">		Method[] getMethods()</span><br><span class="line">	</span><br><span class="line">	获取所有的方法,不包含父类</span><br><span class="line">		Method[] getDeclaredMethods()</span><br><span class="line">		</span><br><span class="line">	获取单独一个公共的方法</span><br><span class="line">    	Method getMethod(String name,Class&lt;?&gt;...parameterTypes)</span><br><span class="line">    	1参:要获取的方法名</span><br><span class="line">    	2参:该方法的形参列表对应的数据类型的对象</span><br><span class="line">    	注意:按顺序书写,基本数据类型的类对象是数据类型.class,其包装类的类对象是类名.class</span><br><span class="line">    	</span><br><span class="line">    	获取单独一个方法</span><br><span class="line">    	Method getDeclaredMethod(Stirng name,Class&lt;?&gt;...parameterTypes)</span><br><span class="line">    	1参:要获取的方法名</span><br><span class="line">    	2参:该方法的形参列表对应的数据类型的类对象</span><br><span class="line">    	注意:按顺序书写,基本数据类型的类对象是数据类型.class,其包装类的类对象是类名.class</span><br><span class="line">    	</span><br><span class="line">    	Method提供的方法</span><br><span class="line">    	Object invoke(Object obj,Object...args)</span><br><span class="line">    		作用:执行该方法</span><br><span class="line">    		1.执行该方法的对象</span><br><span class="line">    		2参:执行该方法所需要的实参列表</span><br><span class="line">    		返回值:执行该方法的返回值</span><br><span class="line">    		</span><br><span class="line">    	setAccessible(boolean flag) 是否略过访问权限修饰符</span><br><span class="line">        	默认为false,表示不略过</span><br><span class="line">        	当值为true表示略过	</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">构造函数相关</span><br><span class="line">	Constructor&lt;?&gt;[] getConstructors()</span><br><span class="line">		作用:获取该类中所有的公共构造函数</span><br><span class="line">		</span><br><span class="line">	Constructor&lt;?&gt;[] getDeclaredConstructors()</span><br><span class="line">    	作用:获取所有的构造函数</span><br><span class="line">    	</span><br><span class="line">    Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;...parameterTypes)</span><br><span class="line">    	作用:获取指定的一个构造函数</span><br><span class="line">    	参数:构造函数对比的形参列表的数据类型的类对象</span><br><span class="line">    	</span><br><span class="line">    Constructor提供的方法</span><br><span class="line">        	Class&lt;?&gt;[] getInterface()</span><br><span class="line">    调用缺省构造函数,返回该Class对象的一个实例</span><br><span class="line">     Object newInstance()</span><br></pre></td></tr></table></figure>

<h1 id="三十-枚举"><a href="#三十-枚举" class="headerlink" title="三十.枚举"></a>三十.枚举</h1><h3 id="1-使用步骤"><a href="#1-使用步骤" class="headerlink" title="1.使用步骤"></a>1.使用步骤</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.定义</span><br><span class="line">2.使用</span><br></pre></td></tr></table></figure>

<h3 id="2-定义"><a href="#2-定义" class="headerlink" title="2.定义:"></a>2.定义:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">	访问权限修饰符 enum 枚举名(</span><br><span class="line">		属性名1,属性名2,属性名2,....属性名n</span><br><span class="line">		)</span><br></pre></td></tr></table></figure>

<h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3.使用"></a>3.使用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">情况1:</span><br><span class="line">	使用枚举的属性</span><br><span class="line">	语法:枚举名.属性名</span><br><span class="line"></span><br><span class="line">情况2:</span><br><span class="line">	枚举作为形参</span><br><span class="line">	传递实参时必须传入枚举的属性</span><br></pre></td></tr></table></figure>

<h3 id="4-自定义枚举"><a href="#4-自定义枚举" class="headerlink" title="4.自定义枚举"></a>4.自定义枚举</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1不需要提供set方法,枚举对象值通常为只读</span><br><span class="line">2.对枚举对象/属性使用final static共同修饰,实现底层优化</span><br><span class="line">3.枚举对象名通常全部大写,常量的命名规范</span><br><span class="line">4.枚举对象根据需要,也可以有多个属性]</span><br></pre></td></tr></table></figure>

<h4 id="5-特点"><a href="#5-特点" class="headerlink" title="5.特点"></a>5.特点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.构造器私有化</span><br><span class="line">2.本类内创建一组对象 public static final 类型名</span><br><span class="line">3.对外暴露对象(通过为对象添加public static final修饰符)</span><br><span class="line">4.可以提供get方法,不提供set方法</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong>：</p>
<ol>
<li>当我们使用enum关键字开发一个枚举时，默认会继承Enum类，而且是一个final类</li>
<li>传统的public final static  Season01 SPRING&#x3D;new Season01(“春天”,”温暖”);简化成 SPRING(“春天”,”温暖”);，这里必须知道它调用的那个构造器</li>
<li>如果使用无参构造器  创建枚举对象，则实参列表和小括号可以省略</li>
<li>当有多个枚举对象时，使用逗号间隔，最后用分号结尾</li>
<li>枚举对象必须放在枚举类的首行</li>
</ol>
<p><strong>常用方法：</strong></p>
<p><strong>说明；</strong>使用关键字enum时，会隐式继承enum，这样我们就可以使用Enum类相关的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Enum</span>&lt;E <span class="keyword">extends</span> <span class="title class_">Enum</span>&lt;E&gt;&gt;</span><br><span class="line">            <span class="keyword">implements</span> <span class="title class_">Comparable</span>&lt;E&gt;, Serializable&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>toString :Enum类已经重写过，返回当前对象名，子类可以重写该方法，用于返回对象的属性信息</li>
<li>name：返回当前对象名，子类中不能重写</li>
<li>ordinal：返回当前对象的位置号，默认从0开始</li>
<li>values：返回当前枚举类中所有常量</li>
<li>valueOf：将字符串装换成枚举对象，要求字符串必须为已有的常量名，否则报异常</li>
<li>compareTo：比较两个枚举常量，比较的就是位置号</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Week[] values = Week.values();</span><br><span class="line">    <span class="keyword">for</span> (Week week:values) &#123;<span class="comment">//增强for循环</span></span><br><span class="line">        System.out.println(week);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>细节：</strong></p>
<ul>
<li>使用enum关键字后，就不能继承其他类，因为enum会隐式继承Enum，而java是单继承机制</li>
<li>枚举和普通类一样，可以实现接口：enum  类名   implements  接口1，接口2{}</li>
</ul>
<h1 id="三十一-注解"><a href="#三十一-注解" class="headerlink" title="三十一.注解"></a>三十一.注解</h1><blockquote>
<p>作用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解释代码的代码,称为注解,又名元代码</span><br></pre></td></tr></table></figure>

<p>注释与注解的区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注释:不会影响代码</span><br><span class="line">注解:对代码有一定的约束作用</span><br></pre></td></tr></table></figure>

<p>常见的注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">	作用:说明当前方法为重写的方法</span><br><span class="line">@SuppressWarnings(&quot;all&quot;)</span><br><span class="line">	作用:忽略警告</span><br><span class="line">	</span><br><span class="line">元注解</span><br><span class="line">	概念:解释注解的注解</span><br><span class="line">@Target</span><br><span class="line">  作用:注解使用位置</span><br><span class="line">  值:</span><br><span class="line">  TYPE:类,接口,枚举上使用</span><br><span class="line">		FIELD:属性上使用</span><br><span class="line">		METHOD:方法使用</span><br><span class="line">		PARAMETER:参数上使用</span><br><span class="line">		CONSTRUCTOR:构造函数</span><br><span class="line">		LOCAL_VARIABLE:局部变量使用</span><br><span class="line">		ANNOTATION_TYPE:注解使用</span><br><span class="line">		PACKAGE:包使用</span><br><span class="line">		注意:没有写可以在任何地方使用</span><br><span class="line">		</span><br><span class="line">@Retention</span><br><span class="line">  作用:注解作用时机</span><br><span class="line">  值:</span><br><span class="line">  	SOURCE:java源程序中存在</span><br><span class="line">			CLASS:字节码文件中存在</span><br><span class="line">			RUNTIME:运行时存在</span><br><span class="line">			</span><br><span class="line">@Documented</span><br><span class="line">  作用:可以生成API文档</span><br><span class="line">  </span><br><span class="line">@Inherited</span><br><span class="line">  作用:说明当前注解是否可以被子类继承,默认不能被子类继承</span><br></pre></td></tr></table></figure>

<p>自定义注解</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">语法:</span><br><span class="line">	访问权限修饰符 @interface 注解名&#123;</span><br><span class="line">		数据类型 属性名1() [default 默认值];</span><br><span class="line">		数据类型 属性名2() [default 默认值];</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>注解的使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@注解名(属性名 = 属性值,属性名 = 属性值,...);</span><br><span class="line">注意:</span><br><span class="line">	1,当注解中的属性有默认值,可以在使用注解时不用赋值</span><br><span class="line">	2,当注解中所有属性都有默认值或没有属性时,可以省略小括号不写</span><br><span class="line">		@注解名</span><br><span class="line">	3,当注解中只有一个属性,并且该属性的属性名为value,此时在使用注解时可以省略属性名不写</span><br><span class="line">		@注解名(属性值)</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">冯家鹏</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/05/01/JAVA%E5%9F%BA%E7%A1%80/">http://example.com/2023/05/01/JAVA基础/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://github.com/fenjiapeng/fjp.github.io" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">半糖</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">java基础知识</a></div><div class="post_share"><div class="social-share" data-image="https://b.zhutix.com/bizhi/Flunt_Emoji/05.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/05/03/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" title="java基础练习--学生管理系统"><img class="cover" src="https://b.zhutix.com/bizhi/Flunt_Emoji/14.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">java基础练习--学生管理系统</div></div></a></div><div class="next-post pull-right"><a href="/2023/05/01/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/" title="第一篇博客"><img class="cover" src="https://b.zhutix.com/bizhi/Flunt_Emoji/01.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">第一篇博客</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/toux.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">冯家鹏</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/fenjiapeng/fjp.github.io"><i class="fab fa-github"></i><span>关注</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到半糖的博客,地址"fenjiapeng.github.io"</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA%E5%9F%BA%E7%A1%80"><span class="toc-text">JAVA基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5W"><span class="toc-text">一、准备阶段W</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-JAVA%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">1.JAVA的执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%BC%80%E5%8F%91%E7%BB%86%E8%8A%82"><span class="toc-text">2.开发细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-text">3..命名规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%99"><span class="toc-text">规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E8%8C%83"><span class="toc-text">规范</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">二、数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B4%E5%9E%8B"><span class="toc-text">1.整型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B5%AE%E7%82%B9%E5%9E%8B"><span class="toc-text">2.浮点型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="toc-text">3.字符型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Boolean"><span class="toc-text">4.Boolean</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">5.引用数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">6.基本数据类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">三、运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">1.算数运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">2.关系运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">3.逻辑运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">4.三元运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="toc-text">四、自动拆装箱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%8E%9F%E7%90%86"><span class="toc-text">2.原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">3.应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%80-%E3%80%81%E5%B0%86%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%94%BE%E5%85%A5%E9%9B%86%E5%90%88%E7%B1%BB"><span class="toc-text">场景一 、将基本数据类型放入集合类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%8C%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%A7%E5%B0%8F%E6%AF%94%E8%BE%83"><span class="toc-text">场景二、包装类和基本类型的大小比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%B8%89%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-text">场景三、包装类型的运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E5%9B%9B%E3%80%81%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">场景四、三目运算符的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E4%BA%94%E3%80%81%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%8E%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">场景五、函数参数与返回值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E8%AF%AD%E5%8F%A5%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-text">五、语句的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5"><span class="toc-text">六、分支语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-if-%E5%88%A4%E6%96%AD%E8%AF%AD%E5%8F%A5"><span class="toc-text">1.if 判断语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-switch"><span class="toc-text">2.switch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%BE%93%E5%85%A5%EF%BC%9AScanner"><span class="toc-text">3.输入：Scanner</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-text">七、循环语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-while"><span class="toc-text">1.while</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-do-while"><span class="toc-text">2.do-while</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-for"><span class="toc-text">3.for</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-text">4.转义字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">5.流程控制语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%96%B9%E6%B3%95%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-text">八、方法（函数）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8"><span class="toc-text">1.作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BC%98%E7%82%B9"><span class="toc-text">2.优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%AD%A5%E9%AA%A4"><span class="toc-text">3.步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AE%9A%E4%B9%89"><span class="toc-text">4.定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%B0%83%E7%94%A8"><span class="toc-text">5.调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A4%9A%E9%87%8D%E8%B0%83%E7%94%A8"><span class="toc-text">6.多重调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%87%8D%E8%BD%BD"><span class="toc-text">7.重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E9%80%92%E5%BD%92"><span class="toc-text">8.递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">九、数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">一维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8-1"><span class="toc-text">1.作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%89%B9%E7%82%B9"><span class="toc-text">2.特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%AD%A5%E9%AA%A4-1"><span class="toc-text">3.步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A3%B0%E6%98%8E"><span class="toc-text">4.声明:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%9B%E5%BB%BA"><span class="toc-text">5.创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BD%BF%E7%94%A8"><span class="toc-text">6.使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-text">可变参数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">十、面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B"><span class="toc-text">1.面向过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%B1%BB"><span class="toc-text">4.类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">5.类和对象的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%BB%84%E6%88%90"><span class="toc-text">6.类的定义与组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-1"><span class="toc-text">1).定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%84%E6%88%90"><span class="toc-text">2).组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">成员变量和局部变量的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">7.对象的创建与使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-this"><span class="toc-text">8.this</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80-%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-text">十一.三大特征</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">1.访问权限修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B0%81%E8%A3%85"><span class="toc-text">2.封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BB%A7%E6%89%BF"><span class="toc-text">3.继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E5%86%99"><span class="toc-text">重写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#super"><span class="toc-text">super</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A4%9A%E6%80%81"><span class="toc-text">4.多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-text">对象的多态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-text">方法的多态:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#instanceof"><span class="toc-text">instanceof</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C-%E3%80%81%E4%B8%89%E5%A4%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-text">十二 、三大修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#abstract"><span class="toc-text">abstract</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%B1%BB"><span class="toc-text">修饰类:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95"><span class="toc-text">修饰方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#final"><span class="toc-text">final</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="toc-text">修饰变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95-1"><span class="toc-text">修饰方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%B1%BB-1"><span class="toc-text">修饰类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">使用场景:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%86%E8%8A%82"><span class="toc-text">细节:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static"><span class="toc-text">static</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E5%B1%9E%E6%80%A7"><span class="toc-text">修饰属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E6%96%B9%E6%B3%95-2"><span class="toc-text">修饰方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">修饰代码块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">继承关系中的执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%97%B6-%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%B1%BB%E8%B0%83%E7%94%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%98%AF"><span class="toc-text">创建对象时,在一个类调用的顺序是:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">代码块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89-%E6%8E%A5%E5%8F%A3"><span class="toc-text">十三.接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AB%E4%B9%89"><span class="toc-text">含义:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-text">使用步骤:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-text">使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BD%BF%E7%94%A8"><span class="toc-text">接口的特殊使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%86%E8%8A%82-1"><span class="toc-text">细节:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-text">接口的多态</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">十四.内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="toc-text">1.概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%86%E7%B1%BB"><span class="toc-text">2.分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">3.成员内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">4.静态内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">5.局部内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-text">6.匿名内部类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%94-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">十五.包装类</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%85%AD-System"><span class="toc-text">十六.System</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%83-Object"><span class="toc-text">十七.Object</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-equals"><span class="toc-text">1.equals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-toString"><span class="toc-text">2.toString</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-hashCode"><span class="toc-text">3.hashCode</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-finalize"><span class="toc-text">4.finalize</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Math"><span class="toc-text">5.Math</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">6.字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1String"><span class="toc-text">6.1String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2StringBuffer%E5%92%8CStringBuilder"><span class="toc-text">6.2StringBuffer和StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-StringBuffer"><span class="toc-text">1.StringBuffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-StringBuilder"><span class="toc-text">2.StringBuilder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">3.提供的方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%85%AB-BigDecimal%E5%92%8CBigInteger"><span class="toc-text">十八.BigDecimal和BigInteger</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-BigDeciamal"><span class="toc-text">1.BigDeciamal</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-BigInterger"><span class="toc-text">2.BigInterger</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B9%9D-%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="toc-text">十九.时间相关类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Date"><span class="toc-text">1.Date</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Calendar"><span class="toc-text">2.Calendar</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AC%AC%E4%B8%89%E4%BB%A3%E6%97%B6%E9%97%B4"><span class="toc-text">3.第三代时间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81-%E6%B3%9B%E5%9E%8B"><span class="toc-text">二十.泛型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%80-%E9%9B%86%E5%90%88"><span class="toc-text">二十一.集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8-2"><span class="toc-text">1.作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%89%B9%E7%82%B9-1"><span class="toc-text">2.特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%90%8D%E7%A7%B0"><span class="toc-text">3.名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">4.体系结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Collection"><span class="toc-text">1.Collection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collection%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">Collection提供的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-text">特殊情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-List%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">5.List提供的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-HashSet%E7%9A%84%E5%89%94%E9%87%8D%E5%8E%9F%E7%90%86"><span class="toc-text">6.HashSet的剔重原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-TreeSet%E5%AD%98%E5%82%A8"><span class="toc-text">7.TreeSet存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%8C-Map"><span class="toc-text">二十二.Map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8-3"><span class="toc-text">1.作用:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95"><span class="toc-text">2.方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%89%B9%E7%82%B9"><span class="toc-text">3.特点:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Map%E6%8E%A5%E5%8F%A3%E7%9A%84%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="toc-text">4.Map接口的遍历方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BC%80%E5%8F%91%E4%B8%AD%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E9%9B%86%E5%90%88%E5%AE%9E%E7%8E%B0%E7%B1%BB"><span class="toc-text">5.开发中如何选择集合实现类*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%98%9F%E5%88%97"><span class="toc-text">2.队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">3.单链表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%BA%94-%E7%BA%BF%E7%A8%8B"><span class="toc-text">二十五.线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8-4"><span class="toc-text">1.作用:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%90%8D%E8%AF%8D"><span class="toc-text">2.名词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%84%E6%88%90"><span class="toc-text">3.组成:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E6%97%B6%E9%97%B4%E7%89%87"><span class="toc-text">CPU时间片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-text">内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-text">4.线程的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BFThread"><span class="toc-text">继承Thread</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-text">实现Runnable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8"><span class="toc-text">5.线程使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%AF%E5%8A%A8"><span class="toc-text">5.线程的启动</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-text">6.线程的销毁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1"><span class="toc-text">7.获取当前线程对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-%E7%BA%BF%E7%A8%8B%E5%90%8D%E5%9F%8E"><span class="toc-text">8.线程名城</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">9.线程优先级</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0"><span class="toc-text">10.线程休眠</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-%E7%BA%BF%E7%A8%8B%E7%A4%BC%E8%AE%A9"><span class="toc-text">11.线程礼让</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-%E7%BA%BF%E7%A8%8B%E5%90%88%E5%B9%B6"><span class="toc-text">12.线程合并</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-text">13.守护线程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">6.线程的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Thread%E5%92%8CRunnable%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7.Thread和Runnable的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">8.线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0"><span class="toc-text">原因:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-text">解决思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%A1%88"><span class="toc-text">方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E6%AD%BB%E9%94%81"><span class="toc-text">9.死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0-1"><span class="toc-text">原因:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-text">举例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF"><span class="toc-text">10.线程间通讯</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-text">注意</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-text">方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-wait%E5%92%8Csleep%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">11.wait和sleep的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">13.线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-text">作用:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0-2"><span class="toc-text">原因:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-text">线程池的体系结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Executors"><span class="toc-text">Executors</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">线程池的使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%BA%BF%E7%A8%8B%E6%B1%A0-ScheduledExecutorService"><span class="toc-text">调度线程池:ScheduledExecutorService</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-Callable"><span class="toc-text">14.Callable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-Lock"><span class="toc-text">15.Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5"><span class="toc-text">同步:</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#lock%E4%BD%93%E7%B3%BB"><span class="toc-text">lock体系</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%85%AD-x2F-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-text">二十六&#x2F;设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%9F%E6%88%90%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">1.生成者与消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">2.单例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B7%A5%E7%A8%8B%E6%A8%A1%E5%BC%8F"><span class="toc-text">3.工程模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B8%83-IO%E6%B5%81"><span class="toc-text">二十七.IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%9C%E7%94%A8-5"><span class="toc-text">1.作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%86%E7%B1%BB-1"><span class="toc-text">2.分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-text">3.字节流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-OutputStream-%E5%AD%97%E8%8A%82%E8%BE%93%E5%87%BA%E6%B5%81%E9%A1%B6%E7%BA%A7%E6%8E%A5%E5%8F%A3"><span class="toc-text">3.1.OutputStream(字节输出流顶级接口)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2%E6%96%87%E4%BB%B6%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-text">3.2文件字节流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3%E5%86%85%E5%AD%98%E6%B5%81"><span class="toc-text">3.3内存流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">3.4缓冲流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-text">3.5对象流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%97%E7%AC%A6%E6%B5%81"><span class="toc-text">4.字符流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-text">概念:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E4%BD%93%E7%B3%BB"><span class="toc-text">字符流体系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-text">文件流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-text">缓冲流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-text">转换流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-text">标准输出流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-File"><span class="toc-text">5.File</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-1"><span class="toc-text">使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7"><span class="toc-text">属性:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1"><span class="toc-text">方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E5%85%AB-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-text">二十八.网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">1.网络相关概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%90%8D%E8%AF%8D"><span class="toc-text">常用名词</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-OSI%E7%BD%91%E7%BB%9C%E6%9E%B6%E6%9E%84"><span class="toc-text">2.OSI网络架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-IP%E5%9C%B0%E5%9D%80"><span class="toc-text">3.IP地址</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ip%E5%9C%B0%E5%9D%80"><span class="toc-text">ip地址:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%9F%E5%90%8D"><span class="toc-text">域名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-text">端口号</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-text">4.通信协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-x2F-IP%E7%BD%91%E7%BB%9C%E6%A1%86%E6%9E%B6"><span class="toc-text">TCP&#x2F;IP网络框架</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-InetAddress"><span class="toc-text">5.InetAddress</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Socket%E7%BC%96%E7%A8%8B"><span class="toc-text">6.Socket编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">TCP和UDP的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP"><span class="toc-text">TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4"><span class="toc-text">服务端开发步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4"><span class="toc-text">客户端开发步骤</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP"><span class="toc-text">UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E7%AB%AF%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4"><span class="toc-text">发送端开发步骤</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E6%94%B6%E7%AB%AF%E5%BC%80%E5%8F%91%E6%AD%A5%E9%AA%A4"><span class="toc-text">接收端开发步骤</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E5%8D%81%E4%B9%9D-%E5%8F%8D%E5%B0%84"><span class="toc-text">二十九.反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-text">1.反射机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.类对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%8F%AF%E5%AE%8C%E6%88%90%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="toc-text">3.java反射机制可完成的任务:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%BB%E8%A6%81%E7%B1%BB"><span class="toc-text">4.反射相关的主要类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8F%8D%E5%B0%84%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">5.反射的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-text">6.如何获取类对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E7%B1%BB%E5%AF%B9%E8%B1%A1-Class%E7%B1%BB"><span class="toc-text">7.类对象(Class类)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="toc-text">基本介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">提供的方法</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E5%8D%81-%E6%9E%9A%E4%B8%BE"><span class="toc-text">三十.枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E6%AD%A5%E9%AA%A4"><span class="toc-text">1.使用步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89"><span class="toc-text">2.定义:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8"><span class="toc-text">3.使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE"><span class="toc-text">4.自定义枚举</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%89%B9%E7%82%B9"><span class="toc-text">5.特点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E5%8D%81%E4%B8%80-%E6%B3%A8%E8%A7%A3"><span class="toc-text">三十一.注解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text"></span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/05/18/JDBC/" title="JDBC"><img src="https://b.zhutix.com/bizhi/Flunt_Emoji/14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JDBC"/></a><div class="content"><a class="title" href="/2023/05/18/JDBC/" title="JDBC">JDBC</a><time datetime="2023-05-17T17:11:25.000Z" title="发表于 2023-05-18 01:11:25">2023-05-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/" title="mysql笔记"><img src="https://b.zhutix.com/bizhi/Flunt_Emoji/01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mysql笔记"/></a><div class="content"><a class="title" href="/2023/05/17/mysql%E7%AC%94%E8%AE%B0/" title="mysql笔记">mysql笔记</a><time datetime="2023-05-17T12:07:49.000Z" title="发表于 2023-05-17 20:07:49">2023-05-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/05/IO/" title="IO"><img src="https://b.zhutix.com/bizhi/Flunt_Emoji/05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IO"/></a><div class="content"><a class="title" href="/2023/05/05/IO/" title="IO">IO</a><time datetime="2023-05-05T12:33:38.000Z" title="发表于 2023-05-05 20:33:38">2023-05-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/03/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" title="java基础练习--图书管理系统"><img src="https://b.zhutix.com/bizhi/Flunt_Emoji/05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java基础练习--图书管理系统"/></a><div class="content"><a class="title" href="/2023/05/03/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" title="java基础练习--图书管理系统">java基础练习--图书管理系统</a><time datetime="2023-05-03T09:43:47.000Z" title="发表于 2023-05-03 17:43:47">2023-05-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/03/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" title="java基础练习--学生管理系统"><img src="https://b.zhutix.com/bizhi/Flunt_Emoji/14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="java基础练习--学生管理系统"/></a><div class="content"><a class="title" href="/2023/05/03/java%E5%9F%BA%E7%A1%80%E7%BB%83%E4%B9%A0-%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" title="java基础练习--学生管理系统">java基础练习--学生管理系统</a><time datetime="2023-05-03T05:57:55.000Z" title="发表于 2023-05-03 13:57:55">2023-05-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://b.zhutix.com/bizhi/Flunt_Emoji/05.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 冯家鹏</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">半糖版权所有</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'f5e8e147b666e727d6c5',
      clientSecret: '3b3ab2104fab3b35be8eb2331822786f39b1463a',
      repo: 'talk',
      owner: 'fenjiapeng',
      admin: ['fenjiapeng'],
      id: '03453b49c32dc7d7f09c6c1d4c96710e',
      updateCountCallback: commentCount
    },null))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !false) {
  if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>